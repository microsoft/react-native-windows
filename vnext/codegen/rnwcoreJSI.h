/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook {
namespace react {


  class JSI_EXPORT NativeActionSheetManagerCxxSpecJSI : public TurboModule {
protected:
  NativeActionSheetManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void showActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function callback) = 0;
  virtual void showShareActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function failureCallback, jsi::Function successCallback) = 0;
  virtual void dismissActionSheet(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeActionSheetManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeActionSheetManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ActionSheetManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeActionSheetManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeActionSheetManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void showActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::showActionSheetWithOptions) == 3,
          "Expected showActionSheetWithOptions(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showActionSheetWithOptions, jsInvoker_, instance_, std::move(options), std::move(callback));
    }
    void showShareActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function failureCallback, jsi::Function successCallback) override {
      static_assert(
          bridging::getParameterCount(&T::showShareActionSheetWithOptions) == 4,
          "Expected showShareActionSheetWithOptions(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showShareActionSheetWithOptions, jsInvoker_, instance_, std::move(options), std::move(failureCallback), std::move(successCallback));
    }
    void dismissActionSheet(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::dismissActionSheet) == 1,
          "Expected dismissActionSheet(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dismissActionSheet, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - AlertManagerBaseArgs

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct AlertManagerBaseArgs {
  P0 title;
  P1 message;
  P2 buttons;
  P3 type;
  P4 defaultValue;
  P5 cancelButtonKey;
  P6 destructiveButtonKey;
  P7 preferredButtonKey;
  P8 keyboardType;
  P9 userInterfaceStyle;
  bool operator==(const AlertManagerBaseArgs &other) const {
    return title == other.title && message == other.message && buttons == other.buttons && type == other.type && defaultValue == other.defaultValue && cancelButtonKey == other.cancelButtonKey && destructiveButtonKey == other.destructiveButtonKey && preferredButtonKey == other.preferredButtonKey && keyboardType == other.keyboardType && userInterfaceStyle == other.userInterfaceStyle;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct AlertManagerBaseArgsBridging {
  static AlertManagerBaseArgs<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AlertManagerBaseArgs<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "buttons"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "defaultValue"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "cancelButtonKey"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "destructiveButtonKey"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "preferredButtonKey"), jsInvoker),
      bridging::fromJs<P8>(rt, value.getProperty(rt, "keyboardType"), jsInvoker),
      bridging::fromJs<P9>(rt, value.getProperty(rt, "userInterfaceStyle"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String messageToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array buttonsToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String typeToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String defaultValueToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String cancelButtonKeyToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String destructiveButtonKeyToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String preferredButtonKeyToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String keyboardTypeToJs(jsi::Runtime &rt, P8 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String userInterfaceStyleToJs(jsi::Runtime &rt, P9 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const AlertManagerBaseArgs<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          if (value.title) {
            result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
          }
    if (value.message) {
            result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
          }
    if (value.buttons) {
            result.setProperty(rt, "buttons", bridging::toJs(rt, value.buttons.value(), jsInvoker));
          }
    if (value.type) {
            result.setProperty(rt, "type", bridging::toJs(rt, value.type.value(), jsInvoker));
          }
    if (value.defaultValue) {
            result.setProperty(rt, "defaultValue", bridging::toJs(rt, value.defaultValue.value(), jsInvoker));
          }
    if (value.cancelButtonKey) {
            result.setProperty(rt, "cancelButtonKey", bridging::toJs(rt, value.cancelButtonKey.value(), jsInvoker));
          }
    if (value.destructiveButtonKey) {
            result.setProperty(rt, "destructiveButtonKey", bridging::toJs(rt, value.destructiveButtonKey.value(), jsInvoker));
          }
    if (value.preferredButtonKey) {
            result.setProperty(rt, "preferredButtonKey", bridging::toJs(rt, value.preferredButtonKey.value(), jsInvoker));
          }
    if (value.keyboardType) {
            result.setProperty(rt, "keyboardType", bridging::toJs(rt, value.keyboardType.value(), jsInvoker));
          }
    if (value.userInterfaceStyle) {
            result.setProperty(rt, "userInterfaceStyle", bridging::toJs(rt, value.userInterfaceStyle.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeAlertManagerCxxSpecJSI : public TurboModule {
protected:
  NativeAlertManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void alertWithArgs(jsi::Runtime &rt, jsi::Object args, jsi::Function callback) = 0;

};

template <typename T>
class JSI_EXPORT NativeAlertManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeAlertManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("AlertManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAlertManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAlertManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void alertWithArgs(jsi::Runtime &rt, jsi::Object args, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::alertWithArgs) == 3,
          "Expected alertWithArgs(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::alertWithArgs, jsInvoker_, instance_, std::move(args), std::move(callback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - AlertBaseDialogOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct AlertBaseDialogOptions {
  P0 title;
  P1 message;
  P2 buttonPositive;
  P3 buttonNegative;
  P4 buttonNeutral;
  P5 items;
  P6 cancelable;
  P7 defaultButton;
  P8 rootTag;
  bool operator==(const AlertBaseDialogOptions &other) const {
    return title == other.title && message == other.message && buttonPositive == other.buttonPositive && buttonNegative == other.buttonNegative && buttonNeutral == other.buttonNeutral && items == other.items && cancelable == other.cancelable && defaultButton == other.defaultButton && rootTag == other.rootTag;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct AlertBaseDialogOptionsBridging {
  static AlertBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6, P7, P8> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AlertBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6, P7, P8> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "buttonPositive"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "buttonNegative"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "buttonNeutral"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "items"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "cancelable"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "defaultButton"), jsInvoker),
      bridging::fromJs<P8>(rt, value.getProperty(rt, "rootTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String messageToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String buttonPositiveToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String buttonNegativeToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String buttonNeutralToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array itemsToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }
  static bool cancelableToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
  static int defaultButtonToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }
  static int rootTagToJs(jsi::Runtime &rt, P8 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const AlertBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6, P7, P8> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          if (value.title) {
            result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
          }
    if (value.message) {
            result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
          }
    if (value.buttonPositive) {
            result.setProperty(rt, "buttonPositive", bridging::toJs(rt, value.buttonPositive.value(), jsInvoker));
          }
    if (value.buttonNegative) {
            result.setProperty(rt, "buttonNegative", bridging::toJs(rt, value.buttonNegative.value(), jsInvoker));
          }
    if (value.buttonNeutral) {
            result.setProperty(rt, "buttonNeutral", bridging::toJs(rt, value.buttonNeutral.value(), jsInvoker));
          }
    if (value.items) {
            result.setProperty(rt, "items", bridging::toJs(rt, value.items.value(), jsInvoker));
          }
    if (value.cancelable) {
            result.setProperty(rt, "cancelable", bridging::toJs(rt, value.cancelable.value(), jsInvoker));
          }
    if (value.defaultButton) {
            result.setProperty(rt, "defaultButton", bridging::toJs(rt, value.defaultButton.value(), jsInvoker));
          }
    if (value.rootTag) {
            result.setProperty(rt, "rootTag", bridging::toJs(rt, value.rootTag.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeDialogManagerWindowsCxxSpecJSI : public TurboModule {
protected:
  NativeDialogManagerWindowsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) = 0;

};

template <typename T>
class JSI_EXPORT NativeDialogManagerWindowsCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDialogManagerWindowsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("Alert", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDialogManagerWindowsCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDialogManagerWindowsCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) override {
      static_assert(
          bridging::getParameterCount(&T::showAlert) == 4,
          "Expected showAlert(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showAlert, jsInvoker_, instance_, std::move(config), std::move(onError), std::move(onAction));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - NativeAnimatedModuleBaseEndResult

template <typename P0>
struct NativeAnimatedModuleBaseEndResult {
  P0 finished;
  bool operator==(const NativeAnimatedModuleBaseEndResult &other) const {
    return finished == other.finished;
  }
};

template <typename P0>
struct NativeAnimatedModuleBaseEndResultBridging {
  static NativeAnimatedModuleBaseEndResult<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeAnimatedModuleBaseEndResult<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "finished"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool finishedToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativeAnimatedModuleBaseEndResult<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
          return result;
        }
      };


#pragma mark - NativeAnimatedModuleBaseEventMapping

template <typename P0, typename P1>
struct NativeAnimatedModuleBaseEventMapping {
  P0 nativeEventPath;
  P1 animatedValueTag;
  bool operator==(const NativeAnimatedModuleBaseEventMapping &other) const {
    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
  }
};

template <typename P0, typename P1>
struct NativeAnimatedModuleBaseEventMappingBridging {
  static NativeAnimatedModuleBaseEventMapping<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeAnimatedModuleBaseEventMapping<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativeAnimatedModuleBaseEventMapping<P0, P1> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeAnimatedModuleCxxSpecJSI : public TurboModule {
protected:
  NativeAnimatedModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startOperationBatch(jsi::Runtime &rt) = 0;
  virtual void finishOperationBatch(jsi::Runtime &rt) = 0;
  virtual void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) = 0;
  virtual void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
  virtual void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
  virtual void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
  virtual void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
  virtual void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) = 0;
  virtual void stopAnimation(jsi::Runtime &rt, double animationId) = 0;
  virtual void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) = 0;
  virtual void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) = 0;
  virtual void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
  virtual void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
  virtual void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void dropAnimatedNode(jsi::Runtime &rt, double tag) = 0;
  virtual void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) = 0;
  virtual void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) = 0;

};

template <typename T>
class JSI_EXPORT NativeAnimatedModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeAnimatedModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("NativeAnimatedModule", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAnimatedModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAnimatedModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startOperationBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startOperationBatch) == 1,
          "Expected startOperationBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startOperationBatch, jsInvoker_, instance_);
    }
    void finishOperationBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::finishOperationBatch) == 1,
          "Expected finishOperationBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::finishOperationBatch, jsInvoker_, instance_);
    }
    void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::createAnimatedNode) == 3,
          "Expected createAnimatedNode(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createAnimatedNode, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::updateAnimatedNodeConfig) == 3,
          "Expected updateAnimatedNodeConfig(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::updateAnimatedNodeConfig, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 3,
          "Expected getValue(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(tag), std::move(saveValueCallback));
    }
    void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::startListeningToAnimatedNodeValue) == 2,
          "Expected startListeningToAnimatedNodeValue(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
    }
    void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::stopListeningToAnimatedNodeValue) == 2,
          "Expected stopListeningToAnimatedNodeValue(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
    }
    void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
      static_assert(
          bridging::getParameterCount(&T::connectAnimatedNodes) == 3,
          "Expected connectAnimatedNodes(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
    }
    void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
      static_assert(
          bridging::getParameterCount(&T::disconnectAnimatedNodes) == 3,
          "Expected disconnectAnimatedNodes(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
    }
    void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) override {
      static_assert(
          bridging::getParameterCount(&T::startAnimatingNode) == 5,
          "Expected startAnimatingNode(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startAnimatingNode, jsInvoker_, instance_, std::move(animationId), std::move(nodeTag), std::move(config), std::move(endCallback));
    }
    void stopAnimation(jsi::Runtime &rt, double animationId) override {
      static_assert(
          bridging::getParameterCount(&T::stopAnimation) == 2,
          "Expected stopAnimation(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopAnimation, jsInvoker_, instance_, std::move(animationId));
    }
    void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) override {
      static_assert(
          bridging::getParameterCount(&T::setAnimatedNodeValue) == 3,
          "Expected setAnimatedNodeValue(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAnimatedNodeValue, jsInvoker_, instance_, std::move(nodeTag), std::move(value));
    }
    void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) override {
      static_assert(
          bridging::getParameterCount(&T::setAnimatedNodeOffset) == 3,
          "Expected setAnimatedNodeOffset(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag), std::move(offset));
    }
    void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::flattenAnimatedNodeOffset) == 2,
          "Expected flattenAnimatedNodeOffset(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::flattenAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
    }
    void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::extractAnimatedNodeOffset) == 2,
          "Expected extractAnimatedNodeOffset(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::extractAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
    }
    void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
      static_assert(
          bridging::getParameterCount(&T::connectAnimatedNodeToView) == 3,
          "Expected connectAnimatedNodeToView(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connectAnimatedNodeToView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
    }
    void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
      static_assert(
          bridging::getParameterCount(&T::disconnectAnimatedNodeFromView) == 3,
          "Expected disconnectAnimatedNodeFromView(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnectAnimatedNodeFromView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
    }
    void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::restoreDefaultValues) == 2,
          "Expected restoreDefaultValues(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::restoreDefaultValues, jsInvoker_, instance_, std::move(nodeTag));
    }
    void dropAnimatedNode(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::dropAnimatedNode) == 2,
          "Expected dropAnimatedNode(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dropAnimatedNode, jsInvoker_, instance_, std::move(tag));
    }
    void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) override {
      static_assert(
          bridging::getParameterCount(&T::addAnimatedEventToView) == 4,
          "Expected addAnimatedEventToView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addAnimatedEventToView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(eventMapping));
    }
    void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::removeAnimatedEventFromView) == 4,
          "Expected removeAnimatedEventFromView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeAnimatedEventFromView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(animatedNodeTag));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) override {
      static_assert(
          bridging::getParameterCount(&T::queueAndExecuteBatchedOperations) == 2,
          "Expected queueAndExecuteBatchedOperations(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::queueAndExecuteBatchedOperations, jsInvoker_, instance_, std::move(operationsAndArgs));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - NativeAnimatedTurboModuleBaseEndResult

template <typename P0>
struct NativeAnimatedTurboModuleBaseEndResult {
  P0 finished;
  bool operator==(const NativeAnimatedTurboModuleBaseEndResult &other) const {
    return finished == other.finished;
  }
};

template <typename P0>
struct NativeAnimatedTurboModuleBaseEndResultBridging {
  static NativeAnimatedTurboModuleBaseEndResult<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeAnimatedTurboModuleBaseEndResult<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "finished"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool finishedToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativeAnimatedTurboModuleBaseEndResult<P0> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
          return result;
        }
      };


#pragma mark - NativeAnimatedTurboModuleBaseEventMapping

template <typename P0, typename P1>
struct NativeAnimatedTurboModuleBaseEventMapping {
  P0 nativeEventPath;
  P1 animatedValueTag;
  bool operator==(const NativeAnimatedTurboModuleBaseEventMapping &other) const {
    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
  }
};

template <typename P0, typename P1>
struct NativeAnimatedTurboModuleBaseEventMappingBridging {
  static NativeAnimatedTurboModuleBaseEventMapping<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeAnimatedTurboModuleBaseEventMapping<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativeAnimatedTurboModuleBaseEventMapping<P0, P1> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeAnimatedTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeAnimatedTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startOperationBatch(jsi::Runtime &rt) = 0;
  virtual void finishOperationBatch(jsi::Runtime &rt) = 0;
  virtual void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) = 0;
  virtual void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
  virtual void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
  virtual void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
  virtual void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
  virtual void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) = 0;
  virtual void stopAnimation(jsi::Runtime &rt, double animationId) = 0;
  virtual void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) = 0;
  virtual void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) = 0;
  virtual void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
  virtual void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
  virtual void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void dropAnimatedNode(jsi::Runtime &rt, double tag) = 0;
  virtual void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) = 0;
  virtual void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) = 0;

};

template <typename T>
class JSI_EXPORT NativeAnimatedTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeAnimatedTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("NativeAnimatedTurboModule", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAnimatedTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAnimatedTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startOperationBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startOperationBatch) == 1,
          "Expected startOperationBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startOperationBatch, jsInvoker_, instance_);
    }
    void finishOperationBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::finishOperationBatch) == 1,
          "Expected finishOperationBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::finishOperationBatch, jsInvoker_, instance_);
    }
    void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::createAnimatedNode) == 3,
          "Expected createAnimatedNode(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createAnimatedNode, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::updateAnimatedNodeConfig) == 3,
          "Expected updateAnimatedNodeConfig(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::updateAnimatedNodeConfig, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 3,
          "Expected getValue(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(tag), std::move(saveValueCallback));
    }
    void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::startListeningToAnimatedNodeValue) == 2,
          "Expected startListeningToAnimatedNodeValue(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
    }
    void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::stopListeningToAnimatedNodeValue) == 2,
          "Expected stopListeningToAnimatedNodeValue(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
    }
    void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
      static_assert(
          bridging::getParameterCount(&T::connectAnimatedNodes) == 3,
          "Expected connectAnimatedNodes(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
    }
    void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
      static_assert(
          bridging::getParameterCount(&T::disconnectAnimatedNodes) == 3,
          "Expected disconnectAnimatedNodes(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
    }
    void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) override {
      static_assert(
          bridging::getParameterCount(&T::startAnimatingNode) == 5,
          "Expected startAnimatingNode(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startAnimatingNode, jsInvoker_, instance_, std::move(animationId), std::move(nodeTag), std::move(config), std::move(endCallback));
    }
    void stopAnimation(jsi::Runtime &rt, double animationId) override {
      static_assert(
          bridging::getParameterCount(&T::stopAnimation) == 2,
          "Expected stopAnimation(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopAnimation, jsInvoker_, instance_, std::move(animationId));
    }
    void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) override {
      static_assert(
          bridging::getParameterCount(&T::setAnimatedNodeValue) == 3,
          "Expected setAnimatedNodeValue(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAnimatedNodeValue, jsInvoker_, instance_, std::move(nodeTag), std::move(value));
    }
    void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) override {
      static_assert(
          bridging::getParameterCount(&T::setAnimatedNodeOffset) == 3,
          "Expected setAnimatedNodeOffset(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag), std::move(offset));
    }
    void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::flattenAnimatedNodeOffset) == 2,
          "Expected flattenAnimatedNodeOffset(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::flattenAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
    }
    void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::extractAnimatedNodeOffset) == 2,
          "Expected extractAnimatedNodeOffset(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::extractAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
    }
    void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
      static_assert(
          bridging::getParameterCount(&T::connectAnimatedNodeToView) == 3,
          "Expected connectAnimatedNodeToView(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connectAnimatedNodeToView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
    }
    void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
      static_assert(
          bridging::getParameterCount(&T::disconnectAnimatedNodeFromView) == 3,
          "Expected disconnectAnimatedNodeFromView(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnectAnimatedNodeFromView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
    }
    void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::restoreDefaultValues) == 2,
          "Expected restoreDefaultValues(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::restoreDefaultValues, jsInvoker_, instance_, std::move(nodeTag));
    }
    void dropAnimatedNode(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::dropAnimatedNode) == 2,
          "Expected dropAnimatedNode(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dropAnimatedNode, jsInvoker_, instance_, std::move(tag));
    }
    void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) override {
      static_assert(
          bridging::getParameterCount(&T::addAnimatedEventToView) == 4,
          "Expected addAnimatedEventToView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addAnimatedEventToView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(eventMapping));
    }
    void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::removeAnimatedEventFromView) == 4,
          "Expected removeAnimatedEventFromView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeAnimatedEventFromView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(animatedNodeTag));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) override {
      static_assert(
          bridging::getParameterCount(&T::queueAndExecuteBatchedOperations) == 2,
          "Expected queueAndExecuteBatchedOperations(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::queueAndExecuteBatchedOperations, jsInvoker_, instance_, std::move(operationsAndArgs));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeAppStateCxxSpecJSI : public TurboModule {
protected:
  NativeAppStateCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void getCurrentAppState(jsi::Runtime &rt, jsi::Function success, jsi::Function error) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeAppStateCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeAppStateCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("AppState", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAppStateCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAppStateCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void getCurrentAppState(jsi::Runtime &rt, jsi::Function success, jsi::Function error) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentAppState) == 3,
          "Expected getCurrentAppState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentAppState, jsInvoker_, instance_, std::move(success), std::move(error));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - AppThemeBaseHighContrastColors

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct AppThemeBaseHighContrastColors {
  P0 ButtonFaceColor;
  P1 ButtonTextColor;
  P2 GrayTextColor;
  P3 HighlightColor;
  P4 HighlightTextColor;
  P5 HotlightColor;
  P6 WindowColor;
  P7 WindowTextColor;
  bool operator==(const AppThemeBaseHighContrastColors &other) const {
    return ButtonFaceColor == other.ButtonFaceColor && ButtonTextColor == other.ButtonTextColor && GrayTextColor == other.GrayTextColor && HighlightColor == other.HighlightColor && HighlightTextColor == other.HighlightTextColor && HotlightColor == other.HotlightColor && WindowColor == other.WindowColor && WindowTextColor == other.WindowTextColor;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct AppThemeBaseHighContrastColorsBridging {
  static AppThemeBaseHighContrastColors<P0, P1, P2, P3, P4, P5, P6, P7> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AppThemeBaseHighContrastColors<P0, P1, P2, P3, P4, P5, P6, P7> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "ButtonFaceColor"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "ButtonTextColor"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "GrayTextColor"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "HighlightColor"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "HighlightTextColor"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "HotlightColor"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "WindowColor"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "WindowTextColor"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String ButtonFaceColorToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String ButtonTextColorToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String GrayTextColorToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String HighlightColorToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String HighlightTextColorToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String HotlightColorToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String WindowColorToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String WindowTextColorToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const AppThemeBaseHighContrastColors<P0, P1, P2, P3, P4, P5, P6, P7> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "ButtonFaceColor", bridging::toJs(rt, value.ButtonFaceColor, jsInvoker));
    result.setProperty(rt, "ButtonTextColor", bridging::toJs(rt, value.ButtonTextColor, jsInvoker));
    result.setProperty(rt, "GrayTextColor", bridging::toJs(rt, value.GrayTextColor, jsInvoker));
    result.setProperty(rt, "HighlightColor", bridging::toJs(rt, value.HighlightColor, jsInvoker));
    result.setProperty(rt, "HighlightTextColor", bridging::toJs(rt, value.HighlightTextColor, jsInvoker));
    result.setProperty(rt, "HotlightColor", bridging::toJs(rt, value.HotlightColor, jsInvoker));
    result.setProperty(rt, "WindowColor", bridging::toJs(rt, value.WindowColor, jsInvoker));
    result.setProperty(rt, "WindowTextColor", bridging::toJs(rt, value.WindowTextColor, jsInvoker));
          return result;
        }
      };


#pragma mark - AppThemeBaseAppThemeData

template <typename P0, typename P1>
struct AppThemeBaseAppThemeData {
  P0 isHighContrast;
  P1 highContrastColors;
  bool operator==(const AppThemeBaseAppThemeData &other) const {
    return isHighContrast == other.isHighContrast && highContrastColors == other.highContrastColors;
  }
};

template <typename P0, typename P1>
struct AppThemeBaseAppThemeDataBridging {
  static AppThemeBaseAppThemeData<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AppThemeBaseAppThemeData<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "isHighContrast"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "highContrastColors"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isHighContrastToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object highContrastColorsToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const AppThemeBaseAppThemeData<P0, P1> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "isHighContrast", bridging::toJs(rt, value.isHighContrast, jsInvoker));
    result.setProperty(rt, "highContrastColors", bridging::toJs(rt, value.highContrastColors, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativeAppThemeCxxSpecJSI : public TurboModule {
protected:
  NativeAppThemeCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeAppThemeCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeAppThemeCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("AppTheme", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAppThemeCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAppThemeCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeBlobModuleCxxSpecJSI : public TurboModule {
protected:
  NativeBlobModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void addNetworkingHandler(jsi::Runtime &rt) = 0;
  virtual void addWebSocketHandler(jsi::Runtime &rt, double id) = 0;
  virtual void removeWebSocketHandler(jsi::Runtime &rt, double id) = 0;
  virtual void sendOverSocket(jsi::Runtime &rt, jsi::Object blob, double socketID) = 0;
  virtual void createFromParts(jsi::Runtime &rt, jsi::Array parts, jsi::String withId) = 0;
  virtual void release(jsi::Runtime &rt, jsi::String blobId) = 0;

};

template <typename T>
class JSI_EXPORT NativeBlobModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeBlobModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("BlobModule", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeBlobModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeBlobModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void addNetworkingHandler(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::addNetworkingHandler) == 1,
          "Expected addNetworkingHandler(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addNetworkingHandler, jsInvoker_, instance_);
    }
    void addWebSocketHandler(jsi::Runtime &rt, double id) override {
      static_assert(
          bridging::getParameterCount(&T::addWebSocketHandler) == 2,
          "Expected addWebSocketHandler(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addWebSocketHandler, jsInvoker_, instance_, std::move(id));
    }
    void removeWebSocketHandler(jsi::Runtime &rt, double id) override {
      static_assert(
          bridging::getParameterCount(&T::removeWebSocketHandler) == 2,
          "Expected removeWebSocketHandler(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeWebSocketHandler, jsInvoker_, instance_, std::move(id));
    }
    void sendOverSocket(jsi::Runtime &rt, jsi::Object blob, double socketID) override {
      static_assert(
          bridging::getParameterCount(&T::sendOverSocket) == 3,
          "Expected sendOverSocket(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendOverSocket, jsInvoker_, instance_, std::move(blob), std::move(socketID));
    }
    void createFromParts(jsi::Runtime &rt, jsi::Array parts, jsi::String withId) override {
      static_assert(
          bridging::getParameterCount(&T::createFromParts) == 3,
          "Expected createFromParts(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createFromParts, jsInvoker_, instance_, std::move(parts), std::move(withId));
    }
    void release(jsi::Runtime &rt, jsi::String blobId) override {
      static_assert(
          bridging::getParameterCount(&T::release) == 2,
          "Expected release(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::release, jsInvoker_, instance_, std::move(blobId));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeFileReaderModuleCxxSpecJSI : public TurboModule {
protected:
  NativeFileReaderModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value readAsDataURL(jsi::Runtime &rt, jsi::Object data) = 0;
  virtual jsi::Value readAsText(jsi::Runtime &rt, jsi::Object data, jsi::String encoding) = 0;

};

template <typename T>
class JSI_EXPORT NativeFileReaderModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeFileReaderModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("FileReaderModule", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeFileReaderModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeFileReaderModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value readAsDataURL(jsi::Runtime &rt, jsi::Object data) override {
      static_assert(
          bridging::getParameterCount(&T::readAsDataURL) == 2,
          "Expected readAsDataURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readAsDataURL, jsInvoker_, instance_, std::move(data));
    }
    jsi::Value readAsText(jsi::Runtime &rt, jsi::Object data, jsi::String encoding) override {
      static_assert(
          bridging::getParameterCount(&T::readAsText) == 3,
          "Expected readAsText(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readAsText, jsInvoker_, instance_, std::move(data), std::move(encoding));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeBugReportingCxxSpecJSI : public TurboModule {
protected:
  NativeBugReportingCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startReportAProblemFlow(jsi::Runtime &rt) = 0;
  virtual void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::Object extraFiles) = 0;
  virtual void setCategoryID(jsi::Runtime &rt, jsi::String categoryID) = 0;

};

template <typename T>
class JSI_EXPORT NativeBugReportingCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeBugReportingCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("BugReporting", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeBugReportingCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeBugReportingCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startReportAProblemFlow(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startReportAProblemFlow) == 1,
          "Expected startReportAProblemFlow(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startReportAProblemFlow, jsInvoker_, instance_);
    }
    void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::Object extraFiles) override {
      static_assert(
          bridging::getParameterCount(&T::setExtraData) == 3,
          "Expected setExtraData(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setExtraData, jsInvoker_, instance_, std::move(extraData), std::move(extraFiles));
    }
    void setCategoryID(jsi::Runtime &rt, jsi::String categoryID) override {
      static_assert(
          bridging::getParameterCount(&T::setCategoryID) == 2,
          "Expected setCategoryID(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setCategoryID, jsInvoker_, instance_, std::move(categoryID));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - ExceptionsManagerBaseStackFrame

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct ExceptionsManagerBaseStackFrame {
  P0 column;
  P1 file;
  P2 lineNumber;
  P3 methodName;
  P4 collapse;
  bool operator==(const ExceptionsManagerBaseStackFrame &other) const {
    return column == other.column && file == other.file && lineNumber == other.lineNumber && methodName == other.methodName && collapse == other.collapse;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct ExceptionsManagerBaseStackFrameBridging {
  static ExceptionsManagerBaseStackFrame<P0, P1, P2, P3, P4> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    ExceptionsManagerBaseStackFrame<P0, P1, P2, P3, P4> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "column"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "file"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "lineNumber"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "methodName"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "collapse"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<double> columnToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> fileToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> lineNumberToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String methodNameToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static bool collapseToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const ExceptionsManagerBaseStackFrame<P0, P1, P2, P3, P4> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "column", bridging::toJs(rt, value.column, jsInvoker));
    result.setProperty(rt, "file", bridging::toJs(rt, value.file, jsInvoker));
    result.setProperty(rt, "lineNumber", bridging::toJs(rt, value.lineNumber, jsInvoker));
    result.setProperty(rt, "methodName", bridging::toJs(rt, value.methodName, jsInvoker));
    if (value.collapse) {
            result.setProperty(rt, "collapse", bridging::toJs(rt, value.collapse.value(), jsInvoker));
          }
          return result;
        }
      };


#pragma mark - ExceptionsManagerBaseExceptionData

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct ExceptionsManagerBaseExceptionData {
  P0 message;
  P1 originalMessage;
  P2 name;
  P3 componentStack;
  P4 stack;
  P5 id;
  P6 isFatal;
  P7 extraData;
  bool operator==(const ExceptionsManagerBaseExceptionData &other) const {
    return message == other.message && originalMessage == other.originalMessage && name == other.name && componentStack == other.componentStack && stack == other.stack && id == other.id && isFatal == other.isFatal && extraData == other.extraData;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct ExceptionsManagerBaseExceptionDataBridging {
  static ExceptionsManagerBaseExceptionData<P0, P1, P2, P3, P4, P5, P6, P7> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    ExceptionsManagerBaseExceptionData<P0, P1, P2, P3, P4, P5, P6, P7> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "originalMessage"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "componentStack"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "stack"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "isFatal"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "extraData"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String messageToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> originalMessageToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> componentStackToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array stackToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
  static double idToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }
  static bool isFatalToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object extraDataToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const ExceptionsManagerBaseExceptionData<P0, P1, P2, P3, P4, P5, P6, P7> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "message", bridging::toJs(rt, value.message, jsInvoker));
    result.setProperty(rt, "originalMessage", bridging::toJs(rt, value.originalMessage, jsInvoker));
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "componentStack", bridging::toJs(rt, value.componentStack, jsInvoker));
    result.setProperty(rt, "stack", bridging::toJs(rt, value.stack, jsInvoker));
    result.setProperty(rt, "id", bridging::toJs(rt, value.id, jsInvoker));
    result.setProperty(rt, "isFatal", bridging::toJs(rt, value.isFatal, jsInvoker));
    if (value.extraData) {
            result.setProperty(rt, "extraData", bridging::toJs(rt, value.extraData.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeExceptionsManagerCxxSpecJSI : public TurboModule {
protected:
  NativeExceptionsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void reportFatalException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) = 0;
  virtual void reportSoftException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) = 0;
  virtual void reportException(jsi::Runtime &rt, jsi::Object data) = 0;
  virtual void updateExceptionMessage(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) = 0;
  virtual void dismissRedbox(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeExceptionsManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeExceptionsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ExceptionsManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeExceptionsManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeExceptionsManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void reportFatalException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) override {
      static_assert(
          bridging::getParameterCount(&T::reportFatalException) == 4,
          "Expected reportFatalException(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reportFatalException, jsInvoker_, instance_, std::move(message), std::move(stack), std::move(exceptionId));
    }
    void reportSoftException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) override {
      static_assert(
          bridging::getParameterCount(&T::reportSoftException) == 4,
          "Expected reportSoftException(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reportSoftException, jsInvoker_, instance_, std::move(message), std::move(stack), std::move(exceptionId));
    }
    void reportException(jsi::Runtime &rt, jsi::Object data) override {
      static_assert(
          bridging::getParameterCount(&T::reportException) == 2,
          "Expected reportException(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reportException, jsInvoker_, instance_, std::move(data));
    }
    void updateExceptionMessage(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) override {
      static_assert(
          bridging::getParameterCount(&T::updateExceptionMessage) == 4,
          "Expected updateExceptionMessage(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::updateExceptionMessage, jsInvoker_, instance_, std::move(message), std::move(stack), std::move(exceptionId));
    }
    void dismissRedbox(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::dismissRedbox) == 1,
          "Expected dismissRedbox(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dismissRedbox, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDevToolsSettingsManagerCxxSpecJSI : public TurboModule {
protected:
  NativeDevToolsSettingsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void setConsolePatchSettings(jsi::Runtime &rt, jsi::String newConsolePatchSettings) = 0;
  virtual std::optional<jsi::String> getConsolePatchSettings(jsi::Runtime &rt) = 0;
  virtual void setProfilingSettings(jsi::Runtime &rt, jsi::String newProfilingSettings) = 0;
  virtual std::optional<jsi::String> getProfilingSettings(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeDevToolsSettingsManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDevToolsSettingsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("DevToolsSettingsManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDevToolsSettingsManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDevToolsSettingsManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void setConsolePatchSettings(jsi::Runtime &rt, jsi::String newConsolePatchSettings) override {
      static_assert(
          bridging::getParameterCount(&T::setConsolePatchSettings) == 2,
          "Expected setConsolePatchSettings(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setConsolePatchSettings, jsInvoker_, instance_, std::move(newConsolePatchSettings));
    }
    std::optional<jsi::String> getConsolePatchSettings(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConsolePatchSettings) == 1,
          "Expected getConsolePatchSettings(...) to have 1 parameters");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getConsolePatchSettings, jsInvoker_, instance_);
    }
    void setProfilingSettings(jsi::Runtime &rt, jsi::String newProfilingSettings) override {
      static_assert(
          bridging::getParameterCount(&T::setProfilingSettings) == 2,
          "Expected setProfilingSettings(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setProfilingSettings, jsInvoker_, instance_, std::move(newProfilingSettings));
    }
    std::optional<jsi::String> getProfilingSettings(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getProfilingSettings) == 1,
          "Expected getProfilingSettings(...) to have 1 parameters");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getProfilingSettings, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeJSCHeapCaptureCxxSpecJSI : public TurboModule {
protected:
  NativeJSCHeapCaptureCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void captureComplete(jsi::Runtime &rt, jsi::String path, std::optional<jsi::String> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeJSCHeapCaptureCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeJSCHeapCaptureCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("JSCHeapCapture", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeJSCHeapCaptureCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeJSCHeapCaptureCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void captureComplete(jsi::Runtime &rt, jsi::String path, std::optional<jsi::String> error) override {
      static_assert(
          bridging::getParameterCount(&T::captureComplete) == 3,
          "Expected captureComplete(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::captureComplete, jsInvoker_, instance_, std::move(path), std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - ImageEditingManagerBaseOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct ImageEditingManagerBaseOptions {
  P0 offset;
  P1 size;
  P2 displaySize;
  P3 resizeMode;
  P4 allowExternalStorage;
  bool operator==(const ImageEditingManagerBaseOptions &other) const {
    return offset == other.offset && size == other.size && displaySize == other.displaySize && resizeMode == other.resizeMode && allowExternalStorage == other.allowExternalStorage;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct ImageEditingManagerBaseOptionsBridging {
  static ImageEditingManagerBaseOptions<P0, P1, P2, P3, P4> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    ImageEditingManagerBaseOptions<P0, P1, P2, P3, P4> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "offset"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "displaySize"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "resizeMode"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "allowExternalStorage"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object offsetToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object sizeToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Object> displaySizeToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> resizeModeToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static bool allowExternalStorageToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const ImageEditingManagerBaseOptions<P0, P1, P2, P3, P4> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "offset", bridging::toJs(rt, value.offset, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    if (value.displaySize) {
            result.setProperty(rt, "displaySize", bridging::toJs(rt, value.displaySize.value(), jsInvoker));
          }
    if (value.resizeMode) {
            result.setProperty(rt, "resizeMode", bridging::toJs(rt, value.resizeMode.value(), jsInvoker));
          }
    if (value.allowExternalStorage) {
            result.setProperty(rt, "allowExternalStorage", bridging::toJs(rt, value.allowExternalStorage.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeImageEditorCxxSpecJSI : public TurboModule {
protected:
  NativeImageEditorCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void cropImage(jsi::Runtime &rt, jsi::String uri, jsi::Object cropData, jsi::Function successCallback, jsi::Function errorCallback) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageEditorCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeImageEditorCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ImageEditingManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageEditorCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageEditorCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void cropImage(jsi::Runtime &rt, jsi::String uri, jsi::Object cropData, jsi::Function successCallback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::cropImage) == 5,
          "Expected cropImage(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::cropImage, jsInvoker_, instance_, std::move(uri), std::move(cropData), std::move(successCallback), std::move(errorCallback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeImageLoaderAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeImageLoaderAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void abortRequest(jsi::Runtime &rt, double requestId) = 0;
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) = 0;
  virtual jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) = 0;
  virtual jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri, double requestId) = 0;
  virtual jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageLoaderAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeImageLoaderAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ImageLoader", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageLoaderAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageLoaderAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void abortRequest(jsi::Runtime &rt, double requestId) override {
      static_assert(
          bridging::getParameterCount(&T::abortRequest) == 2,
          "Expected abortRequest(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::abortRequest, jsInvoker_, instance_, std::move(requestId));
    }
    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) override {
      static_assert(
          bridging::getParameterCount(&T::getSize) == 2,
          "Expected getSize(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getSize, jsInvoker_, instance_, std::move(uri));
    }
    jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) override {
      static_assert(
          bridging::getParameterCount(&T::getSizeWithHeaders) == 3,
          "Expected getSizeWithHeaders(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getSizeWithHeaders, jsInvoker_, instance_, std::move(uri), std::move(headers));
    }
    jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri, double requestId) override {
      static_assert(
          bridging::getParameterCount(&T::prefetchImage) == 3,
          "Expected prefetchImage(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::prefetchImage, jsInvoker_, instance_, std::move(uri), std::move(requestId));
    }
    jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) override {
      static_assert(
          bridging::getParameterCount(&T::queryCache) == 2,
          "Expected queryCache(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::queryCache, jsInvoker_, instance_, std::move(uris));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeImageLoaderIOSCxxSpecJSI : public TurboModule {
protected:
  NativeImageLoaderIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) = 0;
  virtual jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) = 0;
  virtual jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri) = 0;
  virtual jsi::Value prefetchImageWithMetadata(jsi::Runtime &rt, jsi::String uri, jsi::String queryRootName, double rootTag) = 0;
  virtual jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageLoaderIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeImageLoaderIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ImageLoader", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageLoaderIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageLoaderIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) override {
      static_assert(
          bridging::getParameterCount(&T::getSize) == 2,
          "Expected getSize(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getSize, jsInvoker_, instance_, std::move(uri));
    }
    jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) override {
      static_assert(
          bridging::getParameterCount(&T::getSizeWithHeaders) == 3,
          "Expected getSizeWithHeaders(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getSizeWithHeaders, jsInvoker_, instance_, std::move(uri), std::move(headers));
    }
    jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri) override {
      static_assert(
          bridging::getParameterCount(&T::prefetchImage) == 2,
          "Expected prefetchImage(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::prefetchImage, jsInvoker_, instance_, std::move(uri));
    }
    jsi::Value prefetchImageWithMetadata(jsi::Runtime &rt, jsi::String uri, jsi::String queryRootName, double rootTag) override {
      static_assert(
          bridging::getParameterCount(&T::prefetchImageWithMetadata) == 4,
          "Expected prefetchImageWithMetadata(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::prefetchImageWithMetadata, jsInvoker_, instance_, std::move(uri), std::move(queryRootName), std::move(rootTag));
    }
    jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) override {
      static_assert(
          bridging::getParameterCount(&T::queryCache) == 2,
          "Expected queryCache(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::queryCache, jsInvoker_, instance_, std::move(uris));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeImageStoreAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeImageStoreAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageStoreAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeImageStoreAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ImageStoreManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageStoreAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageStoreAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::getBase64ForTag) == 4,
          "Expected getBase64ForTag(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getBase64ForTag, jsInvoker_, instance_, std::move(uri), std::move(successCallback), std::move(errorCallback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeImageStoreIOSCxxSpecJSI : public TurboModule {
protected:
  NativeImageStoreIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) = 0;
  virtual void hasImageForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function callback) = 0;
  virtual void removeImageForTag(jsi::Runtime &rt, jsi::String uri) = 0;
  virtual void addImageFromBase64(jsi::Runtime &rt, jsi::String base64ImageData, jsi::Function successCallback, jsi::Function errorCallback) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageStoreIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeImageStoreIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ImageStoreManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageStoreIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageStoreIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::getBase64ForTag) == 4,
          "Expected getBase64ForTag(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getBase64ForTag, jsInvoker_, instance_, std::move(uri), std::move(successCallback), std::move(errorCallback));
    }
    void hasImageForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::hasImageForTag) == 3,
          "Expected hasImageForTag(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::hasImageForTag, jsInvoker_, instance_, std::move(uri), std::move(callback));
    }
    void removeImageForTag(jsi::Runtime &rt, jsi::String uri) override {
      static_assert(
          bridging::getParameterCount(&T::removeImageForTag) == 2,
          "Expected removeImageForTag(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeImageForTag, jsInvoker_, instance_, std::move(uri));
    }
    void addImageFromBase64(jsi::Runtime &rt, jsi::String base64ImageData, jsi::Function successCallback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::addImageFromBase64) == 4,
          "Expected addImageFromBase64(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addImageFromBase64, jsInvoker_, instance_, std::move(base64ImageData), std::move(successCallback), std::move(errorCallback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeFrameRateLoggerCxxSpecJSI : public TurboModule {
protected:
  NativeFrameRateLoggerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void setGlobalOptions(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual void setContext(jsi::Runtime &rt, jsi::String context) = 0;
  virtual void beginScroll(jsi::Runtime &rt) = 0;
  virtual void endScroll(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeFrameRateLoggerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeFrameRateLoggerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("FrameRateLogger", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeFrameRateLoggerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeFrameRateLoggerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void setGlobalOptions(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::setGlobalOptions) == 2,
          "Expected setGlobalOptions(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setGlobalOptions, jsInvoker_, instance_, std::move(options));
    }
    void setContext(jsi::Runtime &rt, jsi::String context) override {
      static_assert(
          bridging::getParameterCount(&T::setContext) == 2,
          "Expected setContext(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setContext, jsInvoker_, instance_, std::move(context));
    }
    void beginScroll(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::beginScroll) == 1,
          "Expected beginScroll(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::beginScroll, jsInvoker_, instance_);
    }
    void endScroll(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::endScroll) == 1,
          "Expected endScroll(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::endScroll, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeIntentAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeIntentAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getInitialURL(jsi::Runtime &rt) = 0;
  virtual jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) = 0;
  virtual jsi::Value openURL(jsi::Runtime &rt, jsi::String url) = 0;
  virtual jsi::Value openSettings(jsi::Runtime &rt) = 0;
  virtual jsi::Value sendIntent(jsi::Runtime &rt, jsi::String action, std::optional<jsi::Array> extras) = 0;

};

template <typename T>
class JSI_EXPORT NativeIntentAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeIntentAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("IntentAndroid", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeIntentAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeIntentAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value getInitialURL(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getInitialURL) == 1,
          "Expected getInitialURL(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getInitialURL, jsInvoker_, instance_);
    }
    jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) override {
      static_assert(
          bridging::getParameterCount(&T::canOpenURL) == 2,
          "Expected canOpenURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::canOpenURL, jsInvoker_, instance_, std::move(url));
    }
    jsi::Value openURL(jsi::Runtime &rt, jsi::String url) override {
      static_assert(
          bridging::getParameterCount(&T::openURL) == 2,
          "Expected openURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openURL, jsInvoker_, instance_, std::move(url));
    }
    jsi::Value openSettings(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::openSettings) == 1,
          "Expected openSettings(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openSettings, jsInvoker_, instance_);
    }
    jsi::Value sendIntent(jsi::Runtime &rt, jsi::String action, std::optional<jsi::Array> extras) override {
      static_assert(
          bridging::getParameterCount(&T::sendIntent) == 3,
          "Expected sendIntent(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::sendIntent, jsInvoker_, instance_, std::move(action), std::move(extras));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeLinkingManagerCxxSpecJSI : public TurboModule {
protected:
  NativeLinkingManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getInitialURL(jsi::Runtime &rt) = 0;
  virtual jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) = 0;
  virtual jsi::Value openURL(jsi::Runtime &rt, jsi::String url) = 0;
  virtual jsi::Value openSettings(jsi::Runtime &rt) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeLinkingManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeLinkingManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("LinkingManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeLinkingManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeLinkingManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value getInitialURL(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getInitialURL) == 1,
          "Expected getInitialURL(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getInitialURL, jsInvoker_, instance_);
    }
    jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) override {
      static_assert(
          bridging::getParameterCount(&T::canOpenURL) == 2,
          "Expected canOpenURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::canOpenURL, jsInvoker_, instance_, std::move(url));
    }
    jsi::Value openURL(jsi::Runtime &rt, jsi::String url) override {
      static_assert(
          bridging::getParameterCount(&T::openURL) == 2,
          "Expected openURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openURL, jsInvoker_, instance_, std::move(url));
    }
    jsi::Value openSettings(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::openSettings) == 1,
          "Expected openSettings(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openSettings, jsInvoker_, instance_);
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeModalManagerCxxSpecJSI : public TurboModule {
protected:
  NativeModalManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeModalManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeModalManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ModalManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeModalManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeModalManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeNetworkingAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeNetworkingAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void sendRequest(jsi::Runtime &rt, jsi::String method, jsi::String url, double requestId, jsi::Array headers, jsi::Object data, jsi::String responseType, bool useIncrementalUpdates, double timeout, bool withCredentials) = 0;
  virtual void abortRequest(jsi::Runtime &rt, double requestId) = 0;
  virtual void clearCookies(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeNetworkingAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeNetworkingAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("Networking", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeNetworkingAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNetworkingAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void sendRequest(jsi::Runtime &rt, jsi::String method, jsi::String url, double requestId, jsi::Array headers, jsi::Object data, jsi::String responseType, bool useIncrementalUpdates, double timeout, bool withCredentials) override {
      static_assert(
          bridging::getParameterCount(&T::sendRequest) == 10,
          "Expected sendRequest(...) to have 10 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendRequest, jsInvoker_, instance_, std::move(method), std::move(url), std::move(requestId), std::move(headers), std::move(data), std::move(responseType), std::move(useIncrementalUpdates), std::move(timeout), std::move(withCredentials));
    }
    void abortRequest(jsi::Runtime &rt, double requestId) override {
      static_assert(
          bridging::getParameterCount(&T::abortRequest) == 2,
          "Expected abortRequest(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::abortRequest, jsInvoker_, instance_, std::move(requestId));
    }
    void clearCookies(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::clearCookies) == 2,
          "Expected clearCookies(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::clearCookies, jsInvoker_, instance_, std::move(callback));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeNetworkingIOSCxxSpecJSI : public TurboModule {
protected:
  NativeNetworkingIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void sendRequest(jsi::Runtime &rt, jsi::Object query, jsi::Function callback) = 0;
  virtual void abortRequest(jsi::Runtime &rt, double requestId) = 0;
  virtual void clearCookies(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeNetworkingIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeNetworkingIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("Networking", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeNetworkingIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNetworkingIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void sendRequest(jsi::Runtime &rt, jsi::Object query, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::sendRequest) == 3,
          "Expected sendRequest(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendRequest, jsInvoker_, instance_, std::move(query), std::move(callback));
    }
    void abortRequest(jsi::Runtime &rt, double requestId) override {
      static_assert(
          bridging::getParameterCount(&T::abortRequest) == 2,
          "Expected abortRequest(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::abortRequest, jsInvoker_, instance_, std::move(requestId));
    }
    void clearCookies(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::clearCookies) == 2,
          "Expected clearCookies(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::clearCookies, jsInvoker_, instance_, std::move(callback));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeJSCSamplingProfilerCxxSpecJSI : public TurboModule {
protected:
  NativeJSCSamplingProfilerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void operationComplete(jsi::Runtime &rt, double token, std::optional<jsi::String> result, std::optional<jsi::String> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeJSCSamplingProfilerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeJSCSamplingProfilerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("JSCSamplingProfiler", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeJSCSamplingProfilerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeJSCSamplingProfilerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void operationComplete(jsi::Runtime &rt, double token, std::optional<jsi::String> result, std::optional<jsi::String> error) override {
      static_assert(
          bridging::getParameterCount(&T::operationComplete) == 4,
          "Expected operationComplete(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::operationComplete, jsInvoker_, instance_, std::move(token), std::move(result), std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePermissionsAndroidCxxSpecJSI : public TurboModule {
protected:
  NativePermissionsAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value checkPermission(jsi::Runtime &rt, jsi::String permission) = 0;
  virtual jsi::Value requestPermission(jsi::Runtime &rt, jsi::String permission) = 0;
  virtual jsi::Value shouldShowRequestPermissionRationale(jsi::Runtime &rt, jsi::String permission) = 0;
  virtual jsi::Value requestMultiplePermissions(jsi::Runtime &rt, jsi::Array permissions) = 0;

};

template <typename T>
class JSI_EXPORT NativePermissionsAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePermissionsAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("PermissionsAndroid", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePermissionsAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePermissionsAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value checkPermission(jsi::Runtime &rt, jsi::String permission) override {
      static_assert(
          bridging::getParameterCount(&T::checkPermission) == 2,
          "Expected checkPermission(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::checkPermission, jsInvoker_, instance_, std::move(permission));
    }
    jsi::Value requestPermission(jsi::Runtime &rt, jsi::String permission) override {
      static_assert(
          bridging::getParameterCount(&T::requestPermission) == 2,
          "Expected requestPermission(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::requestPermission, jsInvoker_, instance_, std::move(permission));
    }
    jsi::Value shouldShowRequestPermissionRationale(jsi::Runtime &rt, jsi::String permission) override {
      static_assert(
          bridging::getParameterCount(&T::shouldShowRequestPermissionRationale) == 2,
          "Expected shouldShowRequestPermissionRationale(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::shouldShowRequestPermissionRationale, jsInvoker_, instance_, std::move(permission));
    }
    jsi::Value requestMultiplePermissions(jsi::Runtime &rt, jsi::Array permissions) override {
      static_assert(
          bridging::getParameterCount(&T::requestMultiplePermissions) == 2,
          "Expected requestMultiplePermissions(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::requestMultiplePermissions, jsInvoker_, instance_, std::move(permissions));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - PushNotificationManagerBasePermissions

template <typename P0, typename P1, typename P2>
struct PushNotificationManagerBasePermissions {
  P0 alert;
  P1 badge;
  P2 sound;
  bool operator==(const PushNotificationManagerBasePermissions &other) const {
    return alert == other.alert && badge == other.badge && sound == other.sound;
  }
};

template <typename P0, typename P1, typename P2>
struct PushNotificationManagerBasePermissionsBridging {
  static PushNotificationManagerBasePermissions<P0, P1, P2> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    PushNotificationManagerBasePermissions<P0, P1, P2> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "alert"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "badge"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "sound"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool alertToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static bool badgeToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static bool soundToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const PushNotificationManagerBasePermissions<P0, P1, P2> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "alert", bridging::toJs(rt, value.alert, jsInvoker));
    result.setProperty(rt, "badge", bridging::toJs(rt, value.badge, jsInvoker));
    result.setProperty(rt, "sound", bridging::toJs(rt, value.sound, jsInvoker));
          return result;
        }
      };


#pragma mark - PushNotificationManagerBaseNotification

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct PushNotificationManagerBaseNotification {
  P0 alertTitle;
  P1 fireDate;
  P2 alertBody;
  P3 alertAction;
  P4 userInfo;
  P5 category;
  P6 repeatInterval;
  P7 applicationIconBadgeNumber;
  P8 isSilent;
  P9 soundName;
  bool operator==(const PushNotificationManagerBaseNotification &other) const {
    return alertTitle == other.alertTitle && fireDate == other.fireDate && alertBody == other.alertBody && alertAction == other.alertAction && userInfo == other.userInfo && category == other.category && repeatInterval == other.repeatInterval && applicationIconBadgeNumber == other.applicationIconBadgeNumber && isSilent == other.isSilent && soundName == other.soundName;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct PushNotificationManagerBaseNotificationBridging {
  static PushNotificationManagerBaseNotification<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    PushNotificationManagerBaseNotification<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "alertTitle"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "fireDate"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "alertBody"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "alertAction"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "userInfo"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "category"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "repeatInterval"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "applicationIconBadgeNumber"), jsInvoker),
      bridging::fromJs<P8>(rt, value.getProperty(rt, "isSilent"), jsInvoker),
      bridging::fromJs<P9>(rt, value.getProperty(rt, "soundName"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> alertTitleToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> fireDateToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> alertBodyToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> alertActionToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::Object> userInfoToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> categoryToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> repeatIntervalToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<double> applicationIconBadgeNumberToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<bool> isSilentToJs(jsi::Runtime &rt, P8 value) {
    return bridging::toJs(rt, value);
  }
  static std::optional<jsi::String> soundNameToJs(jsi::Runtime &rt, P9 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const PushNotificationManagerBaseNotification<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          if (value.alertTitle) {
            result.setProperty(rt, "alertTitle", bridging::toJs(rt, value.alertTitle.value(), jsInvoker));
          }
    if (value.fireDate) {
            result.setProperty(rt, "fireDate", bridging::toJs(rt, value.fireDate.value(), jsInvoker));
          }
    if (value.alertBody) {
            result.setProperty(rt, "alertBody", bridging::toJs(rt, value.alertBody.value(), jsInvoker));
          }
    if (value.alertAction) {
            result.setProperty(rt, "alertAction", bridging::toJs(rt, value.alertAction.value(), jsInvoker));
          }
    if (value.userInfo) {
            result.setProperty(rt, "userInfo", bridging::toJs(rt, value.userInfo.value(), jsInvoker));
          }
    if (value.category) {
            result.setProperty(rt, "category", bridging::toJs(rt, value.category.value(), jsInvoker));
          }
    if (value.repeatInterval) {
            result.setProperty(rt, "repeatInterval", bridging::toJs(rt, value.repeatInterval.value(), jsInvoker));
          }
    if (value.applicationIconBadgeNumber) {
            result.setProperty(rt, "applicationIconBadgeNumber", bridging::toJs(rt, value.applicationIconBadgeNumber.value(), jsInvoker));
          }
    if (value.isSilent) {
            result.setProperty(rt, "isSilent", bridging::toJs(rt, value.isSilent.value(), jsInvoker));
          }
    if (value.soundName) {
            result.setProperty(rt, "soundName", bridging::toJs(rt, value.soundName.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativePushNotificationManagerIOSCxxSpecJSI : public TurboModule {
protected:
  NativePushNotificationManagerIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void onFinishRemoteNotification(jsi::Runtime &rt, jsi::String notificationId, jsi::String fetchResult) = 0;
  virtual void setApplicationIconBadgeNumber(jsi::Runtime &rt, double num) = 0;
  virtual void getApplicationIconBadgeNumber(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value requestPermissions(jsi::Runtime &rt, jsi::Object permission) = 0;
  virtual void abandonPermissions(jsi::Runtime &rt) = 0;
  virtual void checkPermissions(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void presentLocalNotification(jsi::Runtime &rt, jsi::Object notification) = 0;
  virtual void scheduleLocalNotification(jsi::Runtime &rt, jsi::Object notification) = 0;
  virtual void cancelAllLocalNotifications(jsi::Runtime &rt) = 0;
  virtual void cancelLocalNotifications(jsi::Runtime &rt, jsi::Object userInfo) = 0;
  virtual jsi::Value getInitialNotification(jsi::Runtime &rt) = 0;
  virtual void getScheduledLocalNotifications(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void removeAllDeliveredNotifications(jsi::Runtime &rt) = 0;
  virtual void removeDeliveredNotifications(jsi::Runtime &rt, jsi::Array identifiers) = 0;
  virtual void getDeliveredNotifications(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void getAuthorizationStatus(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventType) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativePushNotificationManagerIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePushNotificationManagerIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("PushNotificationManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePushNotificationManagerIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePushNotificationManagerIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void onFinishRemoteNotification(jsi::Runtime &rt, jsi::String notificationId, jsi::String fetchResult) override {
      static_assert(
          bridging::getParameterCount(&T::onFinishRemoteNotification) == 3,
          "Expected onFinishRemoteNotification(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onFinishRemoteNotification, jsInvoker_, instance_, std::move(notificationId), std::move(fetchResult));
    }
    void setApplicationIconBadgeNumber(jsi::Runtime &rt, double num) override {
      static_assert(
          bridging::getParameterCount(&T::setApplicationIconBadgeNumber) == 2,
          "Expected setApplicationIconBadgeNumber(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setApplicationIconBadgeNumber, jsInvoker_, instance_, std::move(num));
    }
    void getApplicationIconBadgeNumber(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getApplicationIconBadgeNumber) == 2,
          "Expected getApplicationIconBadgeNumber(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getApplicationIconBadgeNumber, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value requestPermissions(jsi::Runtime &rt, jsi::Object permission) override {
      static_assert(
          bridging::getParameterCount(&T::requestPermissions) == 2,
          "Expected requestPermissions(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::requestPermissions, jsInvoker_, instance_, std::move(permission));
    }
    void abandonPermissions(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::abandonPermissions) == 1,
          "Expected abandonPermissions(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::abandonPermissions, jsInvoker_, instance_);
    }
    void checkPermissions(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::checkPermissions) == 2,
          "Expected checkPermissions(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::checkPermissions, jsInvoker_, instance_, std::move(callback));
    }
    void presentLocalNotification(jsi::Runtime &rt, jsi::Object notification) override {
      static_assert(
          bridging::getParameterCount(&T::presentLocalNotification) == 2,
          "Expected presentLocalNotification(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::presentLocalNotification, jsInvoker_, instance_, std::move(notification));
    }
    void scheduleLocalNotification(jsi::Runtime &rt, jsi::Object notification) override {
      static_assert(
          bridging::getParameterCount(&T::scheduleLocalNotification) == 2,
          "Expected scheduleLocalNotification(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::scheduleLocalNotification, jsInvoker_, instance_, std::move(notification));
    }
    void cancelAllLocalNotifications(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::cancelAllLocalNotifications) == 1,
          "Expected cancelAllLocalNotifications(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::cancelAllLocalNotifications, jsInvoker_, instance_);
    }
    void cancelLocalNotifications(jsi::Runtime &rt, jsi::Object userInfo) override {
      static_assert(
          bridging::getParameterCount(&T::cancelLocalNotifications) == 2,
          "Expected cancelLocalNotifications(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::cancelLocalNotifications, jsInvoker_, instance_, std::move(userInfo));
    }
    jsi::Value getInitialNotification(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getInitialNotification) == 1,
          "Expected getInitialNotification(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getInitialNotification, jsInvoker_, instance_);
    }
    void getScheduledLocalNotifications(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getScheduledLocalNotifications) == 2,
          "Expected getScheduledLocalNotifications(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getScheduledLocalNotifications, jsInvoker_, instance_, std::move(callback));
    }
    void removeAllDeliveredNotifications(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::removeAllDeliveredNotifications) == 1,
          "Expected removeAllDeliveredNotifications(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeAllDeliveredNotifications, jsInvoker_, instance_);
    }
    void removeDeliveredNotifications(jsi::Runtime &rt, jsi::Array identifiers) override {
      static_assert(
          bridging::getParameterCount(&T::removeDeliveredNotifications) == 2,
          "Expected removeDeliveredNotifications(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeDeliveredNotifications, jsInvoker_, instance_, std::move(identifiers));
    }
    void getDeliveredNotifications(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getDeliveredNotifications) == 2,
          "Expected getDeliveredNotifications(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getDeliveredNotifications, jsInvoker_, instance_, std::move(callback));
    }
    void getAuthorizationStatus(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getAuthorizationStatus) == 2,
          "Expected getAuthorizationStatus(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getAuthorizationStatus, jsInvoker_, instance_, std::move(callback));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventType) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventType));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeHeadlessJsTaskSupportCxxSpecJSI : public TurboModule {
protected:
  NativeHeadlessJsTaskSupportCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void notifyTaskFinished(jsi::Runtime &rt, double taskId) = 0;
  virtual jsi::Value notifyTaskRetry(jsi::Runtime &rt, double taskId) = 0;

};

template <typename T>
class JSI_EXPORT NativeHeadlessJsTaskSupportCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeHeadlessJsTaskSupportCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("HeadlessJsTaskSupport", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeHeadlessJsTaskSupportCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeHeadlessJsTaskSupportCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void notifyTaskFinished(jsi::Runtime &rt, double taskId) override {
      static_assert(
          bridging::getParameterCount(&T::notifyTaskFinished) == 2,
          "Expected notifyTaskFinished(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::notifyTaskFinished, jsInvoker_, instance_, std::move(taskId));
    }
    jsi::Value notifyTaskRetry(jsi::Runtime &rt, double taskId) override {
      static_assert(
          bridging::getParameterCount(&T::notifyTaskRetry) == 2,
          "Expected notifyTaskRetry(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::notifyTaskRetry, jsInvoker_, instance_, std::move(taskId));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeI18nManagerCxxSpecJSI : public TurboModule {
protected:
  NativeI18nManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void allowRTL(jsi::Runtime &rt, bool allowRTL) = 0;
  virtual void forceRTL(jsi::Runtime &rt, bool forceRTL) = 0;
  virtual void swapLeftAndRightInRTL(jsi::Runtime &rt, bool flipStyles) = 0;

};

template <typename T>
class JSI_EXPORT NativeI18nManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeI18nManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("I18nManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeI18nManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeI18nManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void allowRTL(jsi::Runtime &rt, bool allowRTL) override {
      static_assert(
          bridging::getParameterCount(&T::allowRTL) == 2,
          "Expected allowRTL(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::allowRTL, jsInvoker_, instance_, std::move(allowRTL));
    }
    void forceRTL(jsi::Runtime &rt, bool forceRTL) override {
      static_assert(
          bridging::getParameterCount(&T::forceRTL) == 2,
          "Expected forceRTL(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::forceRTL, jsInvoker_, instance_, std::move(forceRTL));
    }
    void swapLeftAndRightInRTL(jsi::Runtime &rt, bool flipStyles) override {
      static_assert(
          bridging::getParameterCount(&T::swapLeftAndRightInRTL) == 2,
          "Expected swapLeftAndRightInRTL(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::swapLeftAndRightInRTL, jsInvoker_, instance_, std::move(flipStyles));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeUIManagerCxxSpecJSI : public TurboModule {
protected:
  NativeUIManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Object getConstantsForViewManager(jsi::Runtime &rt, jsi::String viewManagerName) = 0;
  virtual jsi::Array getDefaultEventTypes(jsi::Runtime &rt) = 0;
  virtual jsi::Object lazilyLoadView(jsi::Runtime &rt, jsi::String name) = 0;
  virtual void createView(jsi::Runtime &rt, std::optional<double> reactTag, jsi::String viewName, double rootTag, jsi::Object props) = 0;
  virtual void updateView(jsi::Runtime &rt, double reactTag, jsi::String viewName, jsi::Object props) = 0;
  virtual void focus(jsi::Runtime &rt, std::optional<double> reactTag) = 0;
  virtual void blur(jsi::Runtime &rt, std::optional<double> reactTag) = 0;
  virtual void findSubviewIn(jsi::Runtime &rt, std::optional<double> reactTag, jsi::Array point, jsi::Function callback) = 0;
  virtual void dispatchViewManagerCommand(jsi::Runtime &rt, std::optional<double> reactTag, double commandID, std::optional<jsi::Array> commandArgs) = 0;
  virtual void measure(jsi::Runtime &rt, double reactTag, jsi::Function callback) = 0;
  virtual void measureInWindow(jsi::Runtime &rt, double reactTag, jsi::Function callback) = 0;
  virtual void viewIsDescendantOf(jsi::Runtime &rt, std::optional<double> reactTag, std::optional<double> ancestorReactTag, jsi::Function callback) = 0;
  virtual void measureLayout(jsi::Runtime &rt, double reactTag, double ancestorReactTag, jsi::Function errorCallback, jsi::Function callback) = 0;
  virtual void measureLayoutRelativeToParent(jsi::Runtime &rt, double reactTag, jsi::Function errorCallback, jsi::Function callback) = 0;
  virtual void setJSResponder(jsi::Runtime &rt, std::optional<double> reactTag, bool blockNativeResponder) = 0;
  virtual void clearJSResponder(jsi::Runtime &rt) = 0;
  virtual void configureNextLayoutAnimation(jsi::Runtime &rt, jsi::Object config, jsi::Function callback, jsi::Function errorCallback) = 0;
  virtual void removeSubviewsFromContainerWithID(jsi::Runtime &rt, double containerID) = 0;
  virtual void replaceExistingNonRootView(jsi::Runtime &rt, std::optional<double> reactTag, std::optional<double> newReactTag) = 0;
  virtual void setChildren(jsi::Runtime &rt, std::optional<double> containerTag, jsi::Array reactTags) = 0;
  virtual void manageChildren(jsi::Runtime &rt, std::optional<double> containerTag, jsi::Array moveFromIndices, jsi::Array moveToIndices, jsi::Array addChildReactTags, jsi::Array addAtIndices, jsi::Array removeAtIndices) = 0;
  virtual void setLayoutAnimationEnabledExperimental(jsi::Runtime &rt, bool enabled) = 0;
  virtual void sendAccessibilityEvent(jsi::Runtime &rt, std::optional<double> reactTag, double eventType) = 0;
  virtual void showPopupMenu(jsi::Runtime &rt, std::optional<double> reactTag, jsi::Array items, jsi::Function error, jsi::Function success) = 0;
  virtual void dismissPopupMenu(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeUIManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeUIManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("UIManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeUIManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeUIManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Object getConstantsForViewManager(jsi::Runtime &rt, jsi::String viewManagerName) override {
      static_assert(
          bridging::getParameterCount(&T::getConstantsForViewManager) == 2,
          "Expected getConstantsForViewManager(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstantsForViewManager, jsInvoker_, instance_, std::move(viewManagerName));
    }
    jsi::Array getDefaultEventTypes(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getDefaultEventTypes) == 1,
          "Expected getDefaultEventTypes(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getDefaultEventTypes, jsInvoker_, instance_);
    }
    jsi::Object lazilyLoadView(jsi::Runtime &rt, jsi::String name) override {
      static_assert(
          bridging::getParameterCount(&T::lazilyLoadView) == 2,
          "Expected lazilyLoadView(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::lazilyLoadView, jsInvoker_, instance_, std::move(name));
    }
    void createView(jsi::Runtime &rt, std::optional<double> reactTag, jsi::String viewName, double rootTag, jsi::Object props) override {
      static_assert(
          bridging::getParameterCount(&T::createView) == 5,
          "Expected createView(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createView, jsInvoker_, instance_, std::move(reactTag), std::move(viewName), std::move(rootTag), std::move(props));
    }
    void updateView(jsi::Runtime &rt, double reactTag, jsi::String viewName, jsi::Object props) override {
      static_assert(
          bridging::getParameterCount(&T::updateView) == 4,
          "Expected updateView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::updateView, jsInvoker_, instance_, std::move(reactTag), std::move(viewName), std::move(props));
    }
    void focus(jsi::Runtime &rt, std::optional<double> reactTag) override {
      static_assert(
          bridging::getParameterCount(&T::focus) == 2,
          "Expected focus(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::focus, jsInvoker_, instance_, std::move(reactTag));
    }
    void blur(jsi::Runtime &rt, std::optional<double> reactTag) override {
      static_assert(
          bridging::getParameterCount(&T::blur) == 2,
          "Expected blur(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::blur, jsInvoker_, instance_, std::move(reactTag));
    }
    void findSubviewIn(jsi::Runtime &rt, std::optional<double> reactTag, jsi::Array point, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::findSubviewIn) == 4,
          "Expected findSubviewIn(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::findSubviewIn, jsInvoker_, instance_, std::move(reactTag), std::move(point), std::move(callback));
    }
    void dispatchViewManagerCommand(jsi::Runtime &rt, std::optional<double> reactTag, double commandID, std::optional<jsi::Array> commandArgs) override {
      static_assert(
          bridging::getParameterCount(&T::dispatchViewManagerCommand) == 4,
          "Expected dispatchViewManagerCommand(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dispatchViewManagerCommand, jsInvoker_, instance_, std::move(reactTag), std::move(commandID), std::move(commandArgs));
    }
    void measure(jsi::Runtime &rt, double reactTag, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::measure) == 3,
          "Expected measure(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measure, jsInvoker_, instance_, std::move(reactTag), std::move(callback));
    }
    void measureInWindow(jsi::Runtime &rt, double reactTag, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::measureInWindow) == 3,
          "Expected measureInWindow(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measureInWindow, jsInvoker_, instance_, std::move(reactTag), std::move(callback));
    }
    void viewIsDescendantOf(jsi::Runtime &rt, std::optional<double> reactTag, std::optional<double> ancestorReactTag, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::viewIsDescendantOf) == 4,
          "Expected viewIsDescendantOf(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::viewIsDescendantOf, jsInvoker_, instance_, std::move(reactTag), std::move(ancestorReactTag), std::move(callback));
    }
    void measureLayout(jsi::Runtime &rt, double reactTag, double ancestorReactTag, jsi::Function errorCallback, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::measureLayout) == 5,
          "Expected measureLayout(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measureLayout, jsInvoker_, instance_, std::move(reactTag), std::move(ancestorReactTag), std::move(errorCallback), std::move(callback));
    }
    void measureLayoutRelativeToParent(jsi::Runtime &rt, double reactTag, jsi::Function errorCallback, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::measureLayoutRelativeToParent) == 4,
          "Expected measureLayoutRelativeToParent(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measureLayoutRelativeToParent, jsInvoker_, instance_, std::move(reactTag), std::move(errorCallback), std::move(callback));
    }
    void setJSResponder(jsi::Runtime &rt, std::optional<double> reactTag, bool blockNativeResponder) override {
      static_assert(
          bridging::getParameterCount(&T::setJSResponder) == 3,
          "Expected setJSResponder(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setJSResponder, jsInvoker_, instance_, std::move(reactTag), std::move(blockNativeResponder));
    }
    void clearJSResponder(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clearJSResponder) == 1,
          "Expected clearJSResponder(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::clearJSResponder, jsInvoker_, instance_);
    }
    void configureNextLayoutAnimation(jsi::Runtime &rt, jsi::Object config, jsi::Function callback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::configureNextLayoutAnimation) == 4,
          "Expected configureNextLayoutAnimation(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::configureNextLayoutAnimation, jsInvoker_, instance_, std::move(config), std::move(callback), std::move(errorCallback));
    }
    void removeSubviewsFromContainerWithID(jsi::Runtime &rt, double containerID) override {
      static_assert(
          bridging::getParameterCount(&T::removeSubviewsFromContainerWithID) == 2,
          "Expected removeSubviewsFromContainerWithID(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeSubviewsFromContainerWithID, jsInvoker_, instance_, std::move(containerID));
    }
    void replaceExistingNonRootView(jsi::Runtime &rt, std::optional<double> reactTag, std::optional<double> newReactTag) override {
      static_assert(
          bridging::getParameterCount(&T::replaceExistingNonRootView) == 3,
          "Expected replaceExistingNonRootView(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::replaceExistingNonRootView, jsInvoker_, instance_, std::move(reactTag), std::move(newReactTag));
    }
    void setChildren(jsi::Runtime &rt, std::optional<double> containerTag, jsi::Array reactTags) override {
      static_assert(
          bridging::getParameterCount(&T::setChildren) == 3,
          "Expected setChildren(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setChildren, jsInvoker_, instance_, std::move(containerTag), std::move(reactTags));
    }
    void manageChildren(jsi::Runtime &rt, std::optional<double> containerTag, jsi::Array moveFromIndices, jsi::Array moveToIndices, jsi::Array addChildReactTags, jsi::Array addAtIndices, jsi::Array removeAtIndices) override {
      static_assert(
          bridging::getParameterCount(&T::manageChildren) == 7,
          "Expected manageChildren(...) to have 7 parameters");

      return bridging::callFromJs<void>(
          rt, &T::manageChildren, jsInvoker_, instance_, std::move(containerTag), std::move(moveFromIndices), std::move(moveToIndices), std::move(addChildReactTags), std::move(addAtIndices), std::move(removeAtIndices));
    }
    void setLayoutAnimationEnabledExperimental(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setLayoutAnimationEnabledExperimental) == 2,
          "Expected setLayoutAnimationEnabledExperimental(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setLayoutAnimationEnabledExperimental, jsInvoker_, instance_, std::move(enabled));
    }
    void sendAccessibilityEvent(jsi::Runtime &rt, std::optional<double> reactTag, double eventType) override {
      static_assert(
          bridging::getParameterCount(&T::sendAccessibilityEvent) == 3,
          "Expected sendAccessibilityEvent(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendAccessibilityEvent, jsInvoker_, instance_, std::move(reactTag), std::move(eventType));
    }
    void showPopupMenu(jsi::Runtime &rt, std::optional<double> reactTag, jsi::Array items, jsi::Function error, jsi::Function success) override {
      static_assert(
          bridging::getParameterCount(&T::showPopupMenu) == 5,
          "Expected showPopupMenu(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showPopupMenu, jsInvoker_, instance_, std::move(reactTag), std::move(items), std::move(error), std::move(success));
    }
    void dismissPopupMenu(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::dismissPopupMenu) == 1,
          "Expected dismissPopupMenu(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dismissPopupMenu, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeSettingsManagerCxxSpecJSI : public TurboModule {
protected:
  NativeSettingsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void setValues(jsi::Runtime &rt, jsi::Object values) = 0;
  virtual void deleteValues(jsi::Runtime &rt, jsi::Array values) = 0;

};

template <typename T>
class JSI_EXPORT NativeSettingsManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSettingsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("SettingsManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSettingsManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSettingsManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void setValues(jsi::Runtime &rt, jsi::Object values) override {
      static_assert(
          bridging::getParameterCount(&T::setValues) == 2,
          "Expected setValues(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setValues, jsInvoker_, instance_, std::move(values));
    }
    void deleteValues(jsi::Runtime &rt, jsi::Array values) override {
      static_assert(
          bridging::getParameterCount(&T::deleteValues) == 2,
          "Expected deleteValues(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::deleteValues, jsInvoker_, instance_, std::move(values));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeShareModuleCxxSpecJSI : public TurboModule {
protected:
  NativeShareModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value share(jsi::Runtime &rt, jsi::Object content, std::optional<jsi::String> dialogTitle) = 0;

};

template <typename T>
class JSI_EXPORT NativeShareModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeShareModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ShareModule", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeShareModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeShareModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value share(jsi::Runtime &rt, jsi::Object content, std::optional<jsi::String> dialogTitle) override {
      static_assert(
          bridging::getParameterCount(&T::share) == 3,
          "Expected share(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::share, jsInvoker_, instance_, std::move(content), std::move(dialogTitle));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeAppearanceCxxSpecJSI : public TurboModule {
protected:
  NativeAppearanceCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual std::optional<jsi::String> getColorScheme(jsi::Runtime &rt) = 0;
  virtual void setColorScheme(jsi::Runtime &rt, jsi::String colorScheme) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeAppearanceCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeAppearanceCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("Appearance", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAppearanceCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAppearanceCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    std::optional<jsi::String> getColorScheme(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getColorScheme) == 1,
          "Expected getColorScheme(...) to have 1 parameters");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getColorScheme, jsInvoker_, instance_);
    }
    void setColorScheme(jsi::Runtime &rt, jsi::String colorScheme) override {
      static_assert(
          bridging::getParameterCount(&T::setColorScheme) == 2,
          "Expected setColorScheme(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setColorScheme, jsInvoker_, instance_, std::move(colorScheme));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - DeviceInfoBaseDisplayMetrics

template <typename P0, typename P1, typename P2, typename P3>
struct DeviceInfoBaseDisplayMetrics {
  P0 width;
  P1 height;
  P2 scale;
  P3 fontScale;
  bool operator==(const DeviceInfoBaseDisplayMetrics &other) const {
    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale;
  }
};

template <typename P0, typename P1, typename P2, typename P3>
struct DeviceInfoBaseDisplayMetricsBridging {
  static DeviceInfoBaseDisplayMetrics<P0, P1, P2, P3> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    DeviceInfoBaseDisplayMetrics<P0, P1, P2, P3> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "scale"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "fontScale"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static double heightToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static double scaleToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static double fontScaleToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const DeviceInfoBaseDisplayMetrics<P0, P1, P2, P3> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
          return result;
        }
      };


#pragma mark - DeviceInfoBaseDisplayMetricsAndroid

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct DeviceInfoBaseDisplayMetricsAndroid {
  P0 width;
  P1 height;
  P2 scale;
  P3 fontScale;
  P4 densityDpi;
  bool operator==(const DeviceInfoBaseDisplayMetricsAndroid &other) const {
    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale && densityDpi == other.densityDpi;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct DeviceInfoBaseDisplayMetricsAndroidBridging {
  static DeviceInfoBaseDisplayMetricsAndroid<P0, P1, P2, P3, P4> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    DeviceInfoBaseDisplayMetricsAndroid<P0, P1, P2, P3, P4> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "scale"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "fontScale"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "densityDpi"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static double heightToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static double scaleToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static double fontScaleToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static double densityDpiToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const DeviceInfoBaseDisplayMetricsAndroid<P0, P1, P2, P3, P4> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
    result.setProperty(rt, "densityDpi", bridging::toJs(rt, value.densityDpi, jsInvoker));
          return result;
        }
      };


#pragma mark - DeviceInfoBaseDimensionsPayload

template <typename P0, typename P1, typename P2, typename P3>
struct DeviceInfoBaseDimensionsPayload {
  P0 window;
  P1 screen;
  P2 windowPhysicalPixels;
  P3 screenPhysicalPixels;
  bool operator==(const DeviceInfoBaseDimensionsPayload &other) const {
    return window == other.window && screen == other.screen && windowPhysicalPixels == other.windowPhysicalPixels && screenPhysicalPixels == other.screenPhysicalPixels;
  }
};

template <typename P0, typename P1, typename P2, typename P3>
struct DeviceInfoBaseDimensionsPayloadBridging {
  static DeviceInfoBaseDimensionsPayload<P0, P1, P2, P3> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    DeviceInfoBaseDimensionsPayload<P0, P1, P2, P3> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "window"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "screen"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "windowPhysicalPixels"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "screenPhysicalPixels"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object windowToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object screenToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object windowPhysicalPixelsToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object screenPhysicalPixelsToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const DeviceInfoBaseDimensionsPayload<P0, P1, P2, P3> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          if (value.window) {
            result.setProperty(rt, "window", bridging::toJs(rt, value.window.value(), jsInvoker));
          }
    if (value.screen) {
            result.setProperty(rt, "screen", bridging::toJs(rt, value.screen.value(), jsInvoker));
          }
    if (value.windowPhysicalPixels) {
            result.setProperty(rt, "windowPhysicalPixels", bridging::toJs(rt, value.windowPhysicalPixels.value(), jsInvoker));
          }
    if (value.screenPhysicalPixels) {
            result.setProperty(rt, "screenPhysicalPixels", bridging::toJs(rt, value.screenPhysicalPixels.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeDeviceInfoCxxSpecJSI : public TurboModule {
protected:
  NativeDeviceInfoCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeDeviceInfoCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDeviceInfoCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("DeviceInfo", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDeviceInfoCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDeviceInfoCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDevLoadingViewCxxSpecJSI : public TurboModule {
protected:
  NativeDevLoadingViewCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void showMessage(jsi::Runtime &rt, jsi::String message, std::optional<double> withColor, std::optional<double> withBackgroundColor) = 0;
  virtual void hide(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeDevLoadingViewCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDevLoadingViewCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("DevLoadingView", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDevLoadingViewCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDevLoadingViewCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void showMessage(jsi::Runtime &rt, jsi::String message, std::optional<double> withColor, std::optional<double> withBackgroundColor) override {
      static_assert(
          bridging::getParameterCount(&T::showMessage) == 4,
          "Expected showMessage(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showMessage, jsInvoker_, instance_, std::move(message), std::move(withColor), std::move(withBackgroundColor));
    }
    void hide(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::hide) == 1,
          "Expected hide(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::hide, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDevSplitBundleLoaderCxxSpecJSI : public TurboModule {
protected:
  NativeDevSplitBundleLoaderCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value loadBundle(jsi::Runtime &rt, jsi::String bundlePath) = 0;

};

template <typename T>
class JSI_EXPORT NativeDevSplitBundleLoaderCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDevSplitBundleLoaderCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("DevSplitBundleLoader", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDevSplitBundleLoaderCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDevSplitBundleLoaderCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value loadBundle(jsi::Runtime &rt, jsi::String bundlePath) override {
      static_assert(
          bridging::getParameterCount(&T::loadBundle) == 2,
          "Expected loadBundle(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::loadBundle, jsInvoker_, instance_, std::move(bundlePath));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePlatformConstantsAndroidCxxSpecJSI : public TurboModule {
protected:
  NativePlatformConstantsAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::String getAndroidID(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativePlatformConstantsAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePlatformConstantsAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("PlatformConstants", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePlatformConstantsAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePlatformConstantsAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::String getAndroidID(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getAndroidID) == 1,
          "Expected getAndroidID(...) to have 1 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getAndroidID, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePlatformConstantsIOSCxxSpecJSI : public TurboModule {
protected:
  NativePlatformConstantsIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativePlatformConstantsIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePlatformConstantsIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("PlatformConstants", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePlatformConstantsIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePlatformConstantsIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePlatformConstantsWinCxxSpecJSI : public TurboModule {
protected:
  NativePlatformConstantsWinCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativePlatformConstantsWinCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePlatformConstantsWinCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("PlatformConstants", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePlatformConstantsWinCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePlatformConstantsWinCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeVibrationCxxSpecJSI : public TurboModule {
protected:
  NativeVibrationCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void vibrate(jsi::Runtime &rt, double pattern) = 0;
  virtual void vibrateByPattern(jsi::Runtime &rt, jsi::Array pattern, double repeat) = 0;
  virtual void cancel(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeVibrationCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeVibrationCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("Vibration", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeVibrationCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeVibrationCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void vibrate(jsi::Runtime &rt, double pattern) override {
      static_assert(
          bridging::getParameterCount(&T::vibrate) == 2,
          "Expected vibrate(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::vibrate, jsInvoker_, instance_, std::move(pattern));
    }
    void vibrateByPattern(jsi::Runtime &rt, jsi::Array pattern, double repeat) override {
      static_assert(
          bridging::getParameterCount(&T::vibrateByPattern) == 3,
          "Expected vibrateByPattern(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::vibrateByPattern, jsInvoker_, instance_, std::move(pattern), std::move(repeat));
    }
    void cancel(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::cancel) == 1,
          "Expected cancel(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::cancel, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - NativePerformanceCxxBaseReactNativeStartupTiming

template <typename P0, typename P1, typename P2, typename P3>
struct NativePerformanceCxxBaseReactNativeStartupTiming {
  P0 startTime;
  P1 endTime;
  P2 executeJavaScriptBundleEntryPointStart;
  P3 executeJavaScriptBundleEntryPointEnd;
  bool operator==(const NativePerformanceCxxBaseReactNativeStartupTiming &other) const {
    return startTime == other.startTime && endTime == other.endTime && executeJavaScriptBundleEntryPointStart == other.executeJavaScriptBundleEntryPointStart && executeJavaScriptBundleEntryPointEnd == other.executeJavaScriptBundleEntryPointEnd;
  }
};

template <typename P0, typename P1, typename P2, typename P3>
struct NativePerformanceCxxBaseReactNativeStartupTimingBridging {
  static NativePerformanceCxxBaseReactNativeStartupTiming<P0, P1, P2, P3> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativePerformanceCxxBaseReactNativeStartupTiming<P0, P1, P2, P3> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "startTime"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "endTime"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "executeJavaScriptBundleEntryPointStart"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "executeJavaScriptBundleEntryPointEnd"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double startTimeToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static double endTimeToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static double executeJavaScriptBundleEntryPointStartToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static double executeJavaScriptBundleEntryPointEndToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativePerformanceCxxBaseReactNativeStartupTiming<P0, P1, P2, P3> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "startTime", bridging::toJs(rt, value.startTime, jsInvoker));
    result.setProperty(rt, "endTime", bridging::toJs(rt, value.endTime, jsInvoker));
    result.setProperty(rt, "executeJavaScriptBundleEntryPointStart", bridging::toJs(rt, value.executeJavaScriptBundleEntryPointStart, jsInvoker));
    result.setProperty(rt, "executeJavaScriptBundleEntryPointEnd", bridging::toJs(rt, value.executeJavaScriptBundleEntryPointEnd, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativePerformanceCxxSpecJSI : public TurboModule {
protected:
  NativePerformanceCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void mark(jsi::Runtime &rt, jsi::String name, double startTime, double duration) = 0;
  virtual void measure(jsi::Runtime &rt, jsi::String name, double startTime, double endTime, std::optional<double> duration, std::optional<jsi::String> startMark, std::optional<jsi::String> endMark) = 0;
  virtual jsi::Object getSimpleMemoryInfo(jsi::Runtime &rt) = 0;
  virtual jsi::Object getReactNativeStartupTiming(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativePerformanceCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePerformanceCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("NativePerformanceCxx", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePerformanceCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePerformanceCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void mark(jsi::Runtime &rt, jsi::String name, double startTime, double duration) override {
      static_assert(
          bridging::getParameterCount(&T::mark) == 4,
          "Expected mark(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::mark, jsInvoker_, instance_, std::move(name), std::move(startTime), std::move(duration));
    }
    void measure(jsi::Runtime &rt, jsi::String name, double startTime, double endTime, std::optional<double> duration, std::optional<jsi::String> startMark, std::optional<jsi::String> endMark) override {
      static_assert(
          bridging::getParameterCount(&T::measure) == 7,
          "Expected measure(...) to have 7 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measure, jsInvoker_, instance_, std::move(name), std::move(startTime), std::move(endTime), std::move(duration), std::move(startMark), std::move(endMark));
    }
    jsi::Object getSimpleMemoryInfo(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSimpleMemoryInfo) == 1,
          "Expected getSimpleMemoryInfo(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSimpleMemoryInfo, jsInvoker_, instance_);
    }
    jsi::Object getReactNativeStartupTiming(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getReactNativeStartupTiming) == 1,
          "Expected getReactNativeStartupTiming(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getReactNativeStartupTiming, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - NativePerformanceObserverCxxBaseRawPerformanceEntry

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct NativePerformanceObserverCxxBaseRawPerformanceEntry {
  P0 name;
  P1 entryType;
  P2 startTime;
  P3 duration;
  P4 processingStart;
  P5 processingEnd;
  P6 interactionId;
  bool operator==(const NativePerformanceObserverCxxBaseRawPerformanceEntry &other) const {
    return name == other.name && entryType == other.entryType && startTime == other.startTime && duration == other.duration && processingStart == other.processingStart && processingEnd == other.processingEnd && interactionId == other.interactionId;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct NativePerformanceObserverCxxBaseRawPerformanceEntryBridging {
  static NativePerformanceObserverCxxBaseRawPerformanceEntry<P0, P1, P2, P3, P4, P5, P6> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativePerformanceObserverCxxBaseRawPerformanceEntry<P0, P1, P2, P3, P4, P5, P6> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "entryType"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "startTime"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "duration"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "processingStart"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "processingEnd"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "interactionId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static double entryTypeToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static double startTimeToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static double durationToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static double processingStartToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
  static double processingEndToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }
  static double interactionIdToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativePerformanceObserverCxxBaseRawPerformanceEntry<P0, P1, P2, P3, P4, P5, P6> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "entryType", bridging::toJs(rt, value.entryType, jsInvoker));
    result.setProperty(rt, "startTime", bridging::toJs(rt, value.startTime, jsInvoker));
    result.setProperty(rt, "duration", bridging::toJs(rt, value.duration, jsInvoker));
    if (value.processingStart) {
            result.setProperty(rt, "processingStart", bridging::toJs(rt, value.processingStart.value(), jsInvoker));
          }
    if (value.processingEnd) {
            result.setProperty(rt, "processingEnd", bridging::toJs(rt, value.processingEnd.value(), jsInvoker));
          }
    if (value.interactionId) {
            result.setProperty(rt, "interactionId", bridging::toJs(rt, value.interactionId.value(), jsInvoker));
          }
          return result;
        }
      };


#pragma mark - NativePerformanceObserverCxxBaseGetPendingEntriesResult

template <typename P0, typename P1>
struct NativePerformanceObserverCxxBaseGetPendingEntriesResult {
  P0 entries;
  P1 droppedEntriesCount;
  bool operator==(const NativePerformanceObserverCxxBaseGetPendingEntriesResult &other) const {
    return entries == other.entries && droppedEntriesCount == other.droppedEntriesCount;
  }
};

template <typename P0, typename P1>
struct NativePerformanceObserverCxxBaseGetPendingEntriesResultBridging {
  static NativePerformanceObserverCxxBaseGetPendingEntriesResult<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativePerformanceObserverCxxBaseGetPendingEntriesResult<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "entries"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "droppedEntriesCount"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array entriesToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static double droppedEntriesCountToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const NativePerformanceObserverCxxBaseGetPendingEntriesResult<P0, P1> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          result.setProperty(rt, "entries", bridging::toJs(rt, value.entries, jsInvoker));
    result.setProperty(rt, "droppedEntriesCount", bridging::toJs(rt, value.droppedEntriesCount, jsInvoker));
          return result;
        }
      };

class JSI_EXPORT NativePerformanceObserverCxxSpecJSI : public TurboModule {
protected:
  NativePerformanceObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startReporting(jsi::Runtime &rt, double entryType) = 0;
  virtual void stopReporting(jsi::Runtime &rt, double entryType) = 0;
  virtual jsi::Object popPendingEntries(jsi::Runtime &rt) = 0;
  virtual void setOnPerformanceEntryCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual void logRawEntry(jsi::Runtime &rt, jsi::Object entry) = 0;
  virtual jsi::Array getEventCounts(jsi::Runtime &rt) = 0;
  virtual void setDurationThreshold(jsi::Runtime &rt, double entryType, double durationThreshold) = 0;
  virtual void clearEntries(jsi::Runtime &rt, double entryType, std::optional<jsi::String> entryName) = 0;
  virtual jsi::Array getEntries(jsi::Runtime &rt, std::optional<double> entryType, std::optional<jsi::String> entryName) = 0;

};

template <typename T>
class JSI_EXPORT NativePerformanceObserverCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativePerformanceObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("NativePerformanceObserverCxx", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePerformanceObserverCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePerformanceObserverCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startReporting(jsi::Runtime &rt, double entryType) override {
      static_assert(
          bridging::getParameterCount(&T::startReporting) == 2,
          "Expected startReporting(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startReporting, jsInvoker_, instance_, std::move(entryType));
    }
    void stopReporting(jsi::Runtime &rt, double entryType) override {
      static_assert(
          bridging::getParameterCount(&T::stopReporting) == 2,
          "Expected stopReporting(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopReporting, jsInvoker_, instance_, std::move(entryType));
    }
    jsi::Object popPendingEntries(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::popPendingEntries) == 1,
          "Expected popPendingEntries(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::popPendingEntries, jsInvoker_, instance_);
    }
    void setOnPerformanceEntryCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::setOnPerformanceEntryCallback) == 2,
          "Expected setOnPerformanceEntryCallback(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setOnPerformanceEntryCallback, jsInvoker_, instance_, std::move(callback));
    }
    void logRawEntry(jsi::Runtime &rt, jsi::Object entry) override {
      static_assert(
          bridging::getParameterCount(&T::logRawEntry) == 2,
          "Expected logRawEntry(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::logRawEntry, jsInvoker_, instance_, std::move(entry));
    }
    jsi::Array getEventCounts(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getEventCounts) == 1,
          "Expected getEventCounts(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getEventCounts, jsInvoker_, instance_);
    }
    void setDurationThreshold(jsi::Runtime &rt, double entryType, double durationThreshold) override {
      static_assert(
          bridging::getParameterCount(&T::setDurationThreshold) == 3,
          "Expected setDurationThreshold(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setDurationThreshold, jsInvoker_, instance_, std::move(entryType), std::move(durationThreshold));
    }
    void clearEntries(jsi::Runtime &rt, double entryType, std::optional<jsi::String> entryName) override {
      static_assert(
          bridging::getParameterCount(&T::clearEntries) == 3,
          "Expected clearEntries(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::clearEntries, jsInvoker_, instance_, std::move(entryType), std::move(entryName));
    }
    jsi::Array getEntries(jsi::Runtime &rt, std::optional<double> entryType, std::optional<jsi::String> entryName) override {
      static_assert(
          bridging::getParameterCount(&T::getEntries) == 3,
          "Expected getEntries(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getEntries, jsInvoker_, instance_, std::move(entryType), std::move(entryName));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeWebSocketModuleCxxSpecJSI : public TurboModule {
protected:
  NativeWebSocketModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void connect(jsi::Runtime &rt, jsi::String url, std::optional<jsi::Array> protocols, jsi::Object options, double socketID) = 0;
  virtual void send(jsi::Runtime &rt, jsi::String message, double forSocketID) = 0;
  virtual void sendBinary(jsi::Runtime &rt, jsi::String base64String, double forSocketID) = 0;
  virtual void ping(jsi::Runtime &rt, double socketID) = 0;
  virtual void close(jsi::Runtime &rt, double code, jsi::String reason, double socketID) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeWebSocketModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeWebSocketModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("WebSocketModule", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeWebSocketModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeWebSocketModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void connect(jsi::Runtime &rt, jsi::String url, std::optional<jsi::Array> protocols, jsi::Object options, double socketID) override {
      static_assert(
          bridging::getParameterCount(&T::connect) == 5,
          "Expected connect(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connect, jsInvoker_, instance_, std::move(url), std::move(protocols), std::move(options), std::move(socketID));
    }
    void send(jsi::Runtime &rt, jsi::String message, double forSocketID) override {
      static_assert(
          bridging::getParameterCount(&T::send) == 3,
          "Expected send(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::send, jsInvoker_, instance_, std::move(message), std::move(forSocketID));
    }
    void sendBinary(jsi::Runtime &rt, jsi::String base64String, double forSocketID) override {
      static_assert(
          bridging::getParameterCount(&T::sendBinary) == 3,
          "Expected sendBinary(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendBinary, jsInvoker_, instance_, std::move(base64String), std::move(forSocketID));
    }
    void ping(jsi::Runtime &rt, double socketID) override {
      static_assert(
          bridging::getParameterCount(&T::ping) == 2,
          "Expected ping(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::ping, jsInvoker_, instance_, std::move(socketID));
    }
    void close(jsi::Runtime &rt, double code, jsi::String reason, double socketID) override {
      static_assert(
          bridging::getParameterCount(&T::close) == 4,
          "Expected close(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::close, jsInvoker_, instance_, std::move(code), std::move(reason), std::move(socketID));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeAccessibilityInfoCxxSpecJSI : public TurboModule {
protected:
  NativeAccessibilityInfoCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void isReduceMotionEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
  virtual void isTouchExplorationEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
  virtual void isAccessibilityServiceEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
  virtual void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) = 0;
  virtual void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) = 0;
  virtual void getRecommendedTimeoutMillis(jsi::Runtime &rt, double mSec, jsi::Function onSuccess) = 0;

};

template <typename T>
class JSI_EXPORT NativeAccessibilityInfoCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeAccessibilityInfoCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("AccessibilityInfo", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAccessibilityInfoCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAccessibilityInfoCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void isReduceMotionEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
      static_assert(
          bridging::getParameterCount(&T::isReduceMotionEnabled) == 2,
          "Expected isReduceMotionEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::isReduceMotionEnabled, jsInvoker_, instance_, std::move(onSuccess));
    }
    void isTouchExplorationEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
      static_assert(
          bridging::getParameterCount(&T::isTouchExplorationEnabled) == 2,
          "Expected isTouchExplorationEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::isTouchExplorationEnabled, jsInvoker_, instance_, std::move(onSuccess));
    }
    void isAccessibilityServiceEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
      static_assert(
          bridging::getParameterCount(&T::isAccessibilityServiceEnabled) == 2,
          "Expected isAccessibilityServiceEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::isAccessibilityServiceEnabled, jsInvoker_, instance_, std::move(onSuccess));
    }
    void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) override {
      static_assert(
          bridging::getParameterCount(&T::setAccessibilityFocus) == 2,
          "Expected setAccessibilityFocus(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAccessibilityFocus, jsInvoker_, instance_, std::move(reactTag));
    }
    void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) override {
      static_assert(
          bridging::getParameterCount(&T::announceForAccessibility) == 2,
          "Expected announceForAccessibility(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::announceForAccessibility, jsInvoker_, instance_, std::move(announcement));
    }
    void getRecommendedTimeoutMillis(jsi::Runtime &rt, double mSec, jsi::Function onSuccess) override {
      static_assert(
          bridging::getParameterCount(&T::getRecommendedTimeoutMillis) == 3,
          "Expected getRecommendedTimeoutMillis(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getRecommendedTimeoutMillis, jsInvoker_, instance_, std::move(mSec), std::move(onSuccess));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeAccessibilityManagerCxxSpecJSI : public TurboModule {
protected:
  NativeAccessibilityManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void getCurrentBoldTextState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentGrayscaleState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentInvertColorsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentReduceMotionState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentPrefersCrossFadeTransitionsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentReduceTransparencyState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentVoiceOverState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void setAccessibilityContentSizeMultipliers(jsi::Runtime &rt, jsi::Object JSMultipliers) = 0;
  virtual void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) = 0;
  virtual void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) = 0;
  virtual void announceForAccessibilityWithOptions(jsi::Runtime &rt, jsi::String announcement, jsi::Object options) = 0;

};

template <typename T>
class JSI_EXPORT NativeAccessibilityManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeAccessibilityManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("AccessibilityManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAccessibilityManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAccessibilityManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void getCurrentBoldTextState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentBoldTextState) == 3,
          "Expected getCurrentBoldTextState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentBoldTextState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentGrayscaleState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentGrayscaleState) == 3,
          "Expected getCurrentGrayscaleState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentGrayscaleState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentInvertColorsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentInvertColorsState) == 3,
          "Expected getCurrentInvertColorsState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentInvertColorsState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentReduceMotionState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentReduceMotionState) == 3,
          "Expected getCurrentReduceMotionState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentReduceMotionState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentPrefersCrossFadeTransitionsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentPrefersCrossFadeTransitionsState) == 3,
          "Expected getCurrentPrefersCrossFadeTransitionsState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentPrefersCrossFadeTransitionsState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentReduceTransparencyState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentReduceTransparencyState) == 3,
          "Expected getCurrentReduceTransparencyState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentReduceTransparencyState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentVoiceOverState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentVoiceOverState) == 3,
          "Expected getCurrentVoiceOverState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentVoiceOverState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void setAccessibilityContentSizeMultipliers(jsi::Runtime &rt, jsi::Object JSMultipliers) override {
      static_assert(
          bridging::getParameterCount(&T::setAccessibilityContentSizeMultipliers) == 2,
          "Expected setAccessibilityContentSizeMultipliers(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAccessibilityContentSizeMultipliers, jsInvoker_, instance_, std::move(JSMultipliers));
    }
    void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) override {
      static_assert(
          bridging::getParameterCount(&T::setAccessibilityFocus) == 2,
          "Expected setAccessibilityFocus(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAccessibilityFocus, jsInvoker_, instance_, std::move(reactTag));
    }
    void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) override {
      static_assert(
          bridging::getParameterCount(&T::announceForAccessibility) == 2,
          "Expected announceForAccessibility(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::announceForAccessibility, jsInvoker_, instance_, std::move(announcement));
    }
    void announceForAccessibilityWithOptions(jsi::Runtime &rt, jsi::String announcement, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::announceForAccessibilityWithOptions) == 3,
          "Expected announceForAccessibilityWithOptions(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::announceForAccessibilityWithOptions, jsInvoker_, instance_, std::move(announcement), std::move(options));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeClipboardCxxSpecJSI : public TurboModule {
protected:
  NativeClipboardCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value getString(jsi::Runtime &rt) = 0;
  virtual void setString(jsi::Runtime &rt, jsi::String content) = 0;

};

template <typename T>
class JSI_EXPORT NativeClipboardCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeClipboardCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("Clipboard", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeClipboardCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeClipboardCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value getString(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 1,
          "Expected getString(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getString, jsInvoker_, instance_);
    }
    void setString(jsi::Runtime &rt, jsi::String content) override {
      static_assert(
          bridging::getParameterCount(&T::setString) == 2,
          "Expected setString(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setString, jsInvoker_, instance_, std::move(content));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeKeyboardObserverCxxSpecJSI : public TurboModule {
protected:
  NativeKeyboardObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeKeyboardObserverCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeKeyboardObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("KeyboardObserver", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeKeyboardObserverCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeKeyboardObserverCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeSoundManagerCxxSpecJSI : public TurboModule {
protected:
  NativeSoundManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void playTouchSound(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeSoundManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSoundManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("SoundManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSoundManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSoundManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void playTouchSound(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::playTouchSound) == 1,
          "Expected playTouchSound(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::playTouchSound, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeStatusBarManagerAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeStatusBarManagerAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void setColor(jsi::Runtime &rt, double color, bool animated) = 0;
  virtual void setTranslucent(jsi::Runtime &rt, bool translucent) = 0;
  virtual void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle) = 0;
  virtual void setHidden(jsi::Runtime &rt, bool hidden) = 0;

};

template <typename T>
class JSI_EXPORT NativeStatusBarManagerAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeStatusBarManagerAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("StatusBarManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeStatusBarManagerAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeStatusBarManagerAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void setColor(jsi::Runtime &rt, double color, bool animated) override {
      static_assert(
          bridging::getParameterCount(&T::setColor) == 3,
          "Expected setColor(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setColor, jsInvoker_, instance_, std::move(color), std::move(animated));
    }
    void setTranslucent(jsi::Runtime &rt, bool translucent) override {
      static_assert(
          bridging::getParameterCount(&T::setTranslucent) == 2,
          "Expected setTranslucent(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setTranslucent, jsInvoker_, instance_, std::move(translucent));
    }
    void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle) override {
      static_assert(
          bridging::getParameterCount(&T::setStyle) == 2,
          "Expected setStyle(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setStyle, jsInvoker_, instance_, std::move(statusBarStyle));
    }
    void setHidden(jsi::Runtime &rt, bool hidden) override {
      static_assert(
          bridging::getParameterCount(&T::setHidden) == 2,
          "Expected setHidden(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setHidden, jsInvoker_, instance_, std::move(hidden));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeStatusBarManagerIOSCxxSpecJSI : public TurboModule {
protected:
  NativeStatusBarManagerIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void getHeight(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void setNetworkActivityIndicatorVisible(jsi::Runtime &rt, bool visible) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventType) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle, bool animated) = 0;
  virtual void setHidden(jsi::Runtime &rt, bool hidden, jsi::String withAnimation) = 0;

};

template <typename T>
class JSI_EXPORT NativeStatusBarManagerIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeStatusBarManagerIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("StatusBarManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeStatusBarManagerIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeStatusBarManagerIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void getHeight(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getHeight) == 2,
          "Expected getHeight(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getHeight, jsInvoker_, instance_, std::move(callback));
    }
    void setNetworkActivityIndicatorVisible(jsi::Runtime &rt, bool visible) override {
      static_assert(
          bridging::getParameterCount(&T::setNetworkActivityIndicatorVisible) == 2,
          "Expected setNetworkActivityIndicatorVisible(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setNetworkActivityIndicatorVisible, jsInvoker_, instance_, std::move(visible));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventType) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventType));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle, bool animated) override {
      static_assert(
          bridging::getParameterCount(&T::setStyle) == 3,
          "Expected setStyle(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setStyle, jsInvoker_, instance_, std::move(statusBarStyle), std::move(animated));
    }
    void setHidden(jsi::Runtime &rt, bool hidden, jsi::String withAnimation) override {
      static_assert(
          bridging::getParameterCount(&T::setHidden) == 3,
          "Expected setHidden(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setHidden, jsInvoker_, instance_, std::move(hidden), std::move(withAnimation));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeToastAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeToastAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void show(jsi::Runtime &rt, jsi::String message, double duration) = 0;
  virtual void showWithGravity(jsi::Runtime &rt, jsi::String message, double duration, double gravity) = 0;
  virtual void showWithGravityAndOffset(jsi::Runtime &rt, jsi::String message, double duration, double gravity, double xOffset, double yOffset) = 0;

};

template <typename T>
class JSI_EXPORT NativeToastAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeToastAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("ToastAndroid", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeToastAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeToastAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void show(jsi::Runtime &rt, jsi::String message, double duration) override {
      static_assert(
          bridging::getParameterCount(&T::show) == 3,
          "Expected show(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::show, jsInvoker_, instance_, std::move(message), std::move(duration));
    }
    void showWithGravity(jsi::Runtime &rt, jsi::String message, double duration, double gravity) override {
      static_assert(
          bridging::getParameterCount(&T::showWithGravity) == 4,
          "Expected showWithGravity(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showWithGravity, jsInvoker_, instance_, std::move(message), std::move(duration), std::move(gravity));
    }
    void showWithGravityAndOffset(jsi::Runtime &rt, jsi::String message, double duration, double gravity, double xOffset, double yOffset) override {
      static_assert(
          bridging::getParameterCount(&T::showWithGravityAndOffset) == 6,
          "Expected showWithGravityAndOffset(...) to have 6 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showWithGravityAndOffset, jsInvoker_, instance_, std::move(message), std::move(duration), std::move(gravity), std::move(xOffset), std::move(yOffset));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeSegmentFetcherCxxSpecJSI : public TurboModule {
protected:
  NativeSegmentFetcherCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void fetchSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) = 0;
  virtual void getSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) = 0;

};

template <typename T>
class JSI_EXPORT NativeSegmentFetcherCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSegmentFetcherCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("SegmentFetcher", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSegmentFetcherCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSegmentFetcherCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void fetchSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::fetchSegment) == 4,
          "Expected fetchSegment(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::fetchSegment, jsInvoker_, instance_, std::move(segmentId), std::move(options), std::move(callback));
    }
    void getSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getSegment) == 4,
          "Expected getSegment(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getSegment, jsInvoker_, instance_, std::move(segmentId), std::move(options), std::move(callback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeTimingCxxSpecJSI : public TurboModule {
protected:
  NativeTimingCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void createTimer(jsi::Runtime &rt, double callbackID, double duration, double jsSchedulingTime, bool repeats) = 0;
  virtual void deleteTimer(jsi::Runtime &rt, double timerID) = 0;
  virtual void setSendIdleEvents(jsi::Runtime &rt, bool sendIdleEvents) = 0;

};

template <typename T>
class JSI_EXPORT NativeTimingCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeTimingCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("Timing", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeTimingCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeTimingCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void createTimer(jsi::Runtime &rt, double callbackID, double duration, double jsSchedulingTime, bool repeats) override {
      static_assert(
          bridging::getParameterCount(&T::createTimer) == 5,
          "Expected createTimer(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createTimer, jsInvoker_, instance_, std::move(callbackID), std::move(duration), std::move(jsSchedulingTime), std::move(repeats));
    }
    void deleteTimer(jsi::Runtime &rt, double timerID) override {
      static_assert(
          bridging::getParameterCount(&T::deleteTimer) == 2,
          "Expected deleteTimer(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::deleteTimer, jsInvoker_, instance_, std::move(timerID));
    }
    void setSendIdleEvents(jsi::Runtime &rt, bool sendIdleEvents) override {
      static_assert(
          bridging::getParameterCount(&T::setSendIdleEvents) == 2,
          "Expected setSendIdleEvents(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setSendIdleEvents, jsInvoker_, instance_, std::move(sendIdleEvents));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeAnimationsDebugModuleCxxSpecJSI : public TurboModule {
protected:
  NativeAnimationsDebugModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startRecordingFps(jsi::Runtime &rt) = 0;
  virtual void stopRecordingFps(jsi::Runtime &rt, double animationStopTimeMs) = 0;

};

template <typename T>
class JSI_EXPORT NativeAnimationsDebugModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeAnimationsDebugModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("AnimationsDebugModule", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAnimationsDebugModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAnimationsDebugModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startRecordingFps(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startRecordingFps) == 1,
          "Expected startRecordingFps(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startRecordingFps, jsInvoker_, instance_);
    }
    void stopRecordingFps(jsi::Runtime &rt, double animationStopTimeMs) override {
      static_assert(
          bridging::getParameterCount(&T::stopRecordingFps) == 2,
          "Expected stopRecordingFps(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopRecordingFps, jsInvoker_, instance_, std::move(animationStopTimeMs));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDeviceEventManagerCxxSpecJSI : public TurboModule {
protected:
  NativeDeviceEventManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void invokeDefaultBackPressHandler(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeDeviceEventManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDeviceEventManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("DeviceEventManager", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDeviceEventManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDeviceEventManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void invokeDefaultBackPressHandler(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::invokeDefaultBackPressHandler) == 1,
          "Expected invokeDefaultBackPressHandler(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::invokeDefaultBackPressHandler, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDevMenuCxxSpecJSI : public TurboModule {
protected:
  NativeDevMenuCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void show(jsi::Runtime &rt) = 0;
  virtual void reload(jsi::Runtime &rt) = 0;
  virtual void debugRemotely(jsi::Runtime &rt, bool enableDebug) = 0;
  virtual void setProfilingEnabled(jsi::Runtime &rt, bool enabled) = 0;
  virtual void setHotLoadingEnabled(jsi::Runtime &rt, bool enabled) = 0;

};

template <typename T>
class JSI_EXPORT NativeDevMenuCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDevMenuCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("DevMenu", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDevMenuCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDevMenuCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void show(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::show) == 1,
          "Expected show(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::show, jsInvoker_, instance_);
    }
    void reload(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::reload) == 1,
          "Expected reload(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reload, jsInvoker_, instance_);
    }
    void debugRemotely(jsi::Runtime &rt, bool enableDebug) override {
      static_assert(
          bridging::getParameterCount(&T::debugRemotely) == 2,
          "Expected debugRemotely(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::debugRemotely, jsInvoker_, instance_, std::move(enableDebug));
    }
    void setProfilingEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setProfilingEnabled) == 2,
          "Expected setProfilingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setProfilingEnabled, jsInvoker_, instance_, std::move(enabled));
    }
    void setHotLoadingEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setHotLoadingEnabled) == 2,
          "Expected setHotLoadingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setHotLoadingEnabled, jsInvoker_, instance_, std::move(enabled));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDevSettingsCxxSpecJSI : public TurboModule {
protected:
  NativeDevSettingsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void reload(jsi::Runtime &rt) = 0;
  virtual void reloadWithReason(jsi::Runtime &rt, jsi::String reason) = 0;
  virtual void onFastRefresh(jsi::Runtime &rt) = 0;
  virtual void setHotLoadingEnabled(jsi::Runtime &rt, bool isHotLoadingEnabled) = 0;
  virtual void setIsDebuggingRemotely(jsi::Runtime &rt, bool isDebuggingRemotelyEnabled) = 0;
  virtual void setProfilingEnabled(jsi::Runtime &rt, bool isProfilingEnabled) = 0;
  virtual void toggleElementInspector(jsi::Runtime &rt) = 0;
  virtual void addMenuItem(jsi::Runtime &rt, jsi::String title) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual void setIsShakeToShowDevMenuEnabled(jsi::Runtime &rt, bool enabled) = 0;

};

template <typename T>
class JSI_EXPORT NativeDevSettingsCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDevSettingsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("DevSettings", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDevSettingsCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDevSettingsCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void reload(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::reload) == 1,
          "Expected reload(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reload, jsInvoker_, instance_);
    }
    void reloadWithReason(jsi::Runtime &rt, jsi::String reason) override {
      static_assert(
          bridging::getParameterCount(&T::reloadWithReason) == 2,
          "Expected reloadWithReason(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reloadWithReason, jsInvoker_, instance_, std::move(reason));
    }
    void onFastRefresh(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::onFastRefresh) == 1,
          "Expected onFastRefresh(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onFastRefresh, jsInvoker_, instance_);
    }
    void setHotLoadingEnabled(jsi::Runtime &rt, bool isHotLoadingEnabled) override {
      static_assert(
          bridging::getParameterCount(&T::setHotLoadingEnabled) == 2,
          "Expected setHotLoadingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setHotLoadingEnabled, jsInvoker_, instance_, std::move(isHotLoadingEnabled));
    }
    void setIsDebuggingRemotely(jsi::Runtime &rt, bool isDebuggingRemotelyEnabled) override {
      static_assert(
          bridging::getParameterCount(&T::setIsDebuggingRemotely) == 2,
          "Expected setIsDebuggingRemotely(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setIsDebuggingRemotely, jsInvoker_, instance_, std::move(isDebuggingRemotelyEnabled));
    }
    void setProfilingEnabled(jsi::Runtime &rt, bool isProfilingEnabled) override {
      static_assert(
          bridging::getParameterCount(&T::setProfilingEnabled) == 2,
          "Expected setProfilingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setProfilingEnabled, jsInvoker_, instance_, std::move(isProfilingEnabled));
    }
    void toggleElementInspector(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::toggleElementInspector) == 1,
          "Expected toggleElementInspector(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::toggleElementInspector, jsInvoker_, instance_);
    }
    void addMenuItem(jsi::Runtime &rt, jsi::String title) override {
      static_assert(
          bridging::getParameterCount(&T::addMenuItem) == 2,
          "Expected addMenuItem(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addMenuItem, jsInvoker_, instance_, std::move(title));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    void setIsShakeToShowDevMenuEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setIsShakeToShowDevMenuEnabled) == 2,
          "Expected setIsShakeToShowDevMenuEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setIsShakeToShowDevMenuEnabled, jsInvoker_, instance_, std::move(enabled));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  #pragma mark - DialogManagerAndroidBaseDialogOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct DialogManagerAndroidBaseDialogOptions {
  P0 title;
  P1 message;
  P2 buttonPositive;
  P3 buttonNegative;
  P4 buttonNeutral;
  P5 items;
  P6 cancelable;
  bool operator==(const DialogManagerAndroidBaseDialogOptions &other) const {
    return title == other.title && message == other.message && buttonPositive == other.buttonPositive && buttonNegative == other.buttonNegative && buttonNeutral == other.buttonNeutral && items == other.items && cancelable == other.cancelable;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct DialogManagerAndroidBaseDialogOptionsBridging {
  static DialogManagerAndroidBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    DialogManagerAndroidBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "buttonPositive"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "buttonNegative"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "buttonNeutral"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "items"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "cancelable"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String messageToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String buttonPositiveToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String buttonNegativeToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String buttonNeutralToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Array itemsToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }
  static bool cancelableToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
    jsi::Runtime &rt,
    const DialogManagerAndroidBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6> &value,
    const std::shared_ptr<CallInvoker> &jsInvoker) {
      auto result = facebook::jsi::Object(rt);
          if (value.title) {
            result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
          }
    if (value.message) {
            result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
          }
    if (value.buttonPositive) {
            result.setProperty(rt, "buttonPositive", bridging::toJs(rt, value.buttonPositive.value(), jsInvoker));
          }
    if (value.buttonNegative) {
            result.setProperty(rt, "buttonNegative", bridging::toJs(rt, value.buttonNegative.value(), jsInvoker));
          }
    if (value.buttonNeutral) {
            result.setProperty(rt, "buttonNeutral", bridging::toJs(rt, value.buttonNeutral.value(), jsInvoker));
          }
    if (value.items) {
            result.setProperty(rt, "items", bridging::toJs(rt, value.items.value(), jsInvoker));
          }
    if (value.cancelable) {
            result.setProperty(rt, "cancelable", bridging::toJs(rt, value.cancelable.value(), jsInvoker));
          }
          return result;
        }
      };

class JSI_EXPORT NativeDialogManagerAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeDialogManagerAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) = 0;

};

template <typename T>
class JSI_EXPORT NativeDialogManagerAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDialogManagerAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("DialogManagerAndroid", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDialogManagerAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDialogManagerAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) override {
      static_assert(
          bridging::getParameterCount(&T::showAlert) == 4,
          "Expected showAlert(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showAlert, jsInvoker_, instance_, std::move(config), std::move(onError), std::move(onAction));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeLogBoxCxxSpecJSI : public TurboModule {
protected:
  NativeLogBoxCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void show(jsi::Runtime &rt) = 0;
  virtual void hide(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeLogBoxCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeLogBoxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("LogBox", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeLogBoxCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeLogBoxCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void show(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::show) == 1,
          "Expected show(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::show, jsInvoker_, instance_);
    }
    void hide(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::hide) == 1,
          "Expected hide(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::hide, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRedBoxCxxSpecJSI : public TurboModule {
protected:
  NativeRedBoxCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::String forIdentifier) = 0;
  virtual void dismiss(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeRedBoxCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeRedBoxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("RedBox", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeRedBoxCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRedBoxCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::String forIdentifier) override {
      static_assert(
          bridging::getParameterCount(&T::setExtraData) == 3,
          "Expected setExtraData(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setExtraData, jsInvoker_, instance_, std::move(extraData), std::move(forIdentifier));
    }
    void dismiss(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::dismiss) == 1,
          "Expected dismiss(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dismiss, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeSourceCodeCxxSpecJSI : public TurboModule {
protected:
  NativeSourceCodeCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeSourceCodeCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSourceCodeCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("SourceCode", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSourceCodeCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSourceCodeCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


#pragma mark - SampleTurboModuleEnumInt

enum SampleTurboModuleEnumInt { A, B };

template <>
struct Bridging<SampleTurboModuleEnumInt> {
  static SampleTurboModuleEnumInt fromJs(jsi::Runtime &rt, const jsi::Value &rawValue) {
    double value = (double)rawValue.asNumber();
    if (value == 23) {
      return SampleTurboModuleEnumInt::A;
    } else if (value == 42) {
      return SampleTurboModuleEnumInt::B;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, SampleTurboModuleEnumInt value) {
    if (value == SampleTurboModuleEnumInt::A) {
      return bridging::toJs(rt, 23);
    } else if (value == SampleTurboModuleEnumInt::B) {
      return bridging::toJs(rt, 42);
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value");
    }
  }
};
  class JSI_EXPORT NativeSampleTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, bool arg) = 0;
  virtual int getEnum(jsi::Runtime &rt, int arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getUnsafeObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String y, jsi::Object z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeSampleTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("SampleTurboModule", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          "Expected voidFunc(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          "Expected getBool(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    int getEnum(jsi::Runtime &rt, int arg) override {
      static_assert(
          bridging::getParameterCount(&T::getEnum) == 2,
          "Expected getEnum(...) to have 2 parameters");

      return bridging::callFromJs<int>(
          rt, &T::getEnum, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          "Expected getNumber(...) to have 2 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          "Expected getString(...) to have 2 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          "Expected getArray(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          "Expected getObject(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getUnsafeObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getUnsafeObject) == 2,
          "Expected getUnsafeObject(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getUnsafeObject, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          "Expected getRootTag(...) to have 2 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String y, jsi::Object z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          "Expected getValue(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          "Expected getValueWithCallback(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          "Expected getValueWithPromise(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace react
} // namespace facebook
