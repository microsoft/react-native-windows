/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  class JSI_EXPORT NativeReactNativeFeatureFlagsCxxSpecJSI : public TurboModule {
protected:
  NativeReactNativeFeatureFlagsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual bool commonTestFlag(jsi::Runtime &rt) = 0;
  virtual bool enableBackgroundExecutor(jsi::Runtime &rt) = 0;
  virtual bool useModernRuntimeScheduler(jsi::Runtime &rt) = 0;
  virtual bool enableMicrotasks(jsi::Runtime &rt) = 0;
  virtual bool batchRenderingUpdatesInEventLoop(jsi::Runtime &rt) = 0;
  virtual bool enableSpannableBuildingUnification(jsi::Runtime &rt) = 0;
  virtual bool enableCustomDrawOrderFabric(jsi::Runtime &rt) = 0;
  virtual bool enableFixForClippedSubviewsCrash(jsi::Runtime &rt) = 0;
  virtual bool inspectorEnableCxxInspectorPackagerConnection(jsi::Runtime &rt) = 0;
  virtual bool inspectorEnableModernCDPRegistry(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeReactNativeFeatureFlagsCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "NativeReactNativeFeatureFlagsCxx";

protected:
  NativeReactNativeFeatureFlagsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeReactNativeFeatureFlagsCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeReactNativeFeatureFlagsCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeReactNativeFeatureFlagsCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    bool commonTestFlag(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::commonTestFlag) == 1,
          "Expected commonTestFlag(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::commonTestFlag, jsInvoker_, instance_);
    }
    bool enableBackgroundExecutor(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::enableBackgroundExecutor) == 1,
          "Expected enableBackgroundExecutor(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::enableBackgroundExecutor, jsInvoker_, instance_);
    }
    bool useModernRuntimeScheduler(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::useModernRuntimeScheduler) == 1,
          "Expected useModernRuntimeScheduler(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::useModernRuntimeScheduler, jsInvoker_, instance_);
    }
    bool enableMicrotasks(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::enableMicrotasks) == 1,
          "Expected enableMicrotasks(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::enableMicrotasks, jsInvoker_, instance_);
    }
    bool batchRenderingUpdatesInEventLoop(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::batchRenderingUpdatesInEventLoop) == 1,
          "Expected batchRenderingUpdatesInEventLoop(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::batchRenderingUpdatesInEventLoop, jsInvoker_, instance_);
    }
    bool enableSpannableBuildingUnification(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::enableSpannableBuildingUnification) == 1,
          "Expected enableSpannableBuildingUnification(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::enableSpannableBuildingUnification, jsInvoker_, instance_);
    }
    bool enableCustomDrawOrderFabric(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::enableCustomDrawOrderFabric) == 1,
          "Expected enableCustomDrawOrderFabric(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::enableCustomDrawOrderFabric, jsInvoker_, instance_);
    }
    bool enableFixForClippedSubviewsCrash(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::enableFixForClippedSubviewsCrash) == 1,
          "Expected enableFixForClippedSubviewsCrash(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::enableFixForClippedSubviewsCrash, jsInvoker_, instance_);
    }
    bool inspectorEnableCxxInspectorPackagerConnection(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::inspectorEnableCxxInspectorPackagerConnection) == 1,
          "Expected inspectorEnableCxxInspectorPackagerConnection(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::inspectorEnableCxxInspectorPackagerConnection, jsInvoker_, instance_);
    }
    bool inspectorEnableModernCDPRegistry(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::inspectorEnableModernCDPRegistry) == 1,
          "Expected inspectorEnableModernCDPRegistry(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::inspectorEnableModernCDPRegistry, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeAccessibilityInfoCxxSpecJSI : public TurboModule {
protected:
  NativeAccessibilityInfoCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void isReduceMotionEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
  virtual void isTouchExplorationEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
  virtual void isAccessibilityServiceEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
  virtual void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) = 0;
  virtual void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) = 0;
  virtual void getRecommendedTimeoutMillis(jsi::Runtime &rt, double mSec, jsi::Function onSuccess) = 0;

};

template <typename T>
class JSI_EXPORT NativeAccessibilityInfoCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "AccessibilityInfo";

protected:
  NativeAccessibilityInfoCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAccessibilityInfoCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAccessibilityInfoCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAccessibilityInfoCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void isReduceMotionEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
      static_assert(
          bridging::getParameterCount(&T::isReduceMotionEnabled) == 2,
          "Expected isReduceMotionEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::isReduceMotionEnabled, jsInvoker_, instance_, std::move(onSuccess));
    }
    void isTouchExplorationEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
      static_assert(
          bridging::getParameterCount(&T::isTouchExplorationEnabled) == 2,
          "Expected isTouchExplorationEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::isTouchExplorationEnabled, jsInvoker_, instance_, std::move(onSuccess));
    }
    void isAccessibilityServiceEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
      static_assert(
          bridging::getParameterCount(&T::isAccessibilityServiceEnabled) == 2,
          "Expected isAccessibilityServiceEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::isAccessibilityServiceEnabled, jsInvoker_, instance_, std::move(onSuccess));
    }
    void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) override {
      static_assert(
          bridging::getParameterCount(&T::setAccessibilityFocus) == 2,
          "Expected setAccessibilityFocus(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAccessibilityFocus, jsInvoker_, instance_, std::move(reactTag));
    }
    void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) override {
      static_assert(
          bridging::getParameterCount(&T::announceForAccessibility) == 2,
          "Expected announceForAccessibility(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::announceForAccessibility, jsInvoker_, instance_, std::move(announcement));
    }
    void getRecommendedTimeoutMillis(jsi::Runtime &rt, double mSec, jsi::Function onSuccess) override {
      static_assert(
          bridging::getParameterCount(&T::getRecommendedTimeoutMillis) == 3,
          "Expected getRecommendedTimeoutMillis(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getRecommendedTimeoutMillis, jsInvoker_, instance_, std::move(mSec), std::move(onSuccess));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeAccessibilityManagerCxxSpecJSI : public TurboModule {
protected:
  NativeAccessibilityManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void getCurrentBoldTextState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentGrayscaleState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentInvertColorsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentReduceMotionState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentPrefersCrossFadeTransitionsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentReduceTransparencyState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void getCurrentVoiceOverState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
  virtual void setAccessibilityContentSizeMultipliers(jsi::Runtime &rt, jsi::Object JSMultipliers) = 0;
  virtual void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) = 0;
  virtual void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) = 0;
  virtual void announceForAccessibilityWithOptions(jsi::Runtime &rt, jsi::String announcement, jsi::Object options) = 0;

};

template <typename T>
class JSI_EXPORT NativeAccessibilityManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "AccessibilityManager";

protected:
  NativeAccessibilityManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAccessibilityManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAccessibilityManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAccessibilityManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void getCurrentBoldTextState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentBoldTextState) == 3,
          "Expected getCurrentBoldTextState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentBoldTextState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentGrayscaleState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentGrayscaleState) == 3,
          "Expected getCurrentGrayscaleState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentGrayscaleState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentInvertColorsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentInvertColorsState) == 3,
          "Expected getCurrentInvertColorsState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentInvertColorsState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentReduceMotionState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentReduceMotionState) == 3,
          "Expected getCurrentReduceMotionState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentReduceMotionState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentPrefersCrossFadeTransitionsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentPrefersCrossFadeTransitionsState) == 3,
          "Expected getCurrentPrefersCrossFadeTransitionsState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentPrefersCrossFadeTransitionsState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentReduceTransparencyState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentReduceTransparencyState) == 3,
          "Expected getCurrentReduceTransparencyState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentReduceTransparencyState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void getCurrentVoiceOverState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentVoiceOverState) == 3,
          "Expected getCurrentVoiceOverState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentVoiceOverState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
    }
    void setAccessibilityContentSizeMultipliers(jsi::Runtime &rt, jsi::Object JSMultipliers) override {
      static_assert(
          bridging::getParameterCount(&T::setAccessibilityContentSizeMultipliers) == 2,
          "Expected setAccessibilityContentSizeMultipliers(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAccessibilityContentSizeMultipliers, jsInvoker_, instance_, std::move(JSMultipliers));
    }
    void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) override {
      static_assert(
          bridging::getParameterCount(&T::setAccessibilityFocus) == 2,
          "Expected setAccessibilityFocus(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAccessibilityFocus, jsInvoker_, instance_, std::move(reactTag));
    }
    void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) override {
      static_assert(
          bridging::getParameterCount(&T::announceForAccessibility) == 2,
          "Expected announceForAccessibility(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::announceForAccessibility, jsInvoker_, instance_, std::move(announcement));
    }
    void announceForAccessibilityWithOptions(jsi::Runtime &rt, jsi::String announcement, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::announceForAccessibilityWithOptions) == 3,
          "Expected announceForAccessibilityWithOptions(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::announceForAccessibilityWithOptions, jsInvoker_, instance_, std::move(announcement), std::move(options));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeActionSheetManagerCxxSpecJSI : public TurboModule {
protected:
  NativeActionSheetManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void showActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function callback) = 0;
  virtual void showShareActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function failureCallback, jsi::Function successCallback) = 0;
  virtual void dismissActionSheet(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeActionSheetManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ActionSheetManager";

protected:
  NativeActionSheetManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeActionSheetManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeActionSheetManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeActionSheetManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void showActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::showActionSheetWithOptions) == 3,
          "Expected showActionSheetWithOptions(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showActionSheetWithOptions, jsInvoker_, instance_, std::move(options), std::move(callback));
    }
    void showShareActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function failureCallback, jsi::Function successCallback) override {
      static_assert(
          bridging::getParameterCount(&T::showShareActionSheetWithOptions) == 4,
          "Expected showShareActionSheetWithOptions(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showShareActionSheetWithOptions, jsInvoker_, instance_, std::move(options), std::move(failureCallback), std::move(successCallback));
    }
    void dismissActionSheet(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::dismissActionSheet) == 1,
          "Expected dismissActionSheet(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dismissActionSheet, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - AlertManagerBaseArgs

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct [[deprecated("Use AlertManagerArgs instead.")]] AlertManagerBaseArgs {
  P0 title;
  P1 message;
  P2 buttons;
  P3 type;
  P4 defaultValue;
  P5 cancelButtonKey;
  P6 destructiveButtonKey;
  P7 preferredButtonKey;
  P8 keyboardType;
  P9 userInterfaceStyle;
  bool operator==(const AlertManagerBaseArgs &other) const {
    return title == other.title && message == other.message && buttons == other.buttons && type == other.type && defaultValue == other.defaultValue && cancelButtonKey == other.cancelButtonKey && destructiveButtonKey == other.destructiveButtonKey && preferredButtonKey == other.preferredButtonKey && keyboardType == other.keyboardType && userInterfaceStyle == other.userInterfaceStyle;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct [[deprecated("Use AlertManagerArgsBridging instead.")]] AlertManagerBaseArgsBridging {
  static AlertManagerBaseArgs<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AlertManagerBaseArgs<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "buttons"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "defaultValue"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "cancelButtonKey"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "destructiveButtonKey"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "preferredButtonKey"), jsInvoker),
      bridging::fromJs<P8>(rt, value.getProperty(rt, "keyboardType"), jsInvoker),
      bridging::fromJs<P9>(rt, value.getProperty(rt, "userInterfaceStyle"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String messageToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array buttonsToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String typeToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String defaultValueToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cancelButtonKeyToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String destructiveButtonKeyToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String preferredButtonKeyToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String keyboardTypeToJs(jsi::Runtime &rt, P8 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String userInterfaceStyleToJs(jsi::Runtime &rt, P9 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const AlertManagerBaseArgs<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.message) {
      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
    }
    if (value.buttons) {
      result.setProperty(rt, "buttons", bridging::toJs(rt, value.buttons.value(), jsInvoker));
    }
    if (value.type) {
      result.setProperty(rt, "type", bridging::toJs(rt, value.type.value(), jsInvoker));
    }
    if (value.defaultValue) {
      result.setProperty(rt, "defaultValue", bridging::toJs(rt, value.defaultValue.value(), jsInvoker));
    }
    if (value.cancelButtonKey) {
      result.setProperty(rt, "cancelButtonKey", bridging::toJs(rt, value.cancelButtonKey.value(), jsInvoker));
    }
    if (value.destructiveButtonKey) {
      result.setProperty(rt, "destructiveButtonKey", bridging::toJs(rt, value.destructiveButtonKey.value(), jsInvoker));
    }
    if (value.preferredButtonKey) {
      result.setProperty(rt, "preferredButtonKey", bridging::toJs(rt, value.preferredButtonKey.value(), jsInvoker));
    }
    if (value.keyboardType) {
      result.setProperty(rt, "keyboardType", bridging::toJs(rt, value.keyboardType.value(), jsInvoker));
    }
    if (value.userInterfaceStyle) {
      result.setProperty(rt, "userInterfaceStyle", bridging::toJs(rt, value.userInterfaceStyle.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - AlertManagerArgs

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct AlertManagerArgs {
  P0 title;
  P1 message;
  P2 buttons;
  P3 type;
  P4 defaultValue;
  P5 cancelButtonKey;
  P6 destructiveButtonKey;
  P7 preferredButtonKey;
  P8 keyboardType;
  P9 userInterfaceStyle;
  bool operator==(const AlertManagerArgs &other) const {
    return title == other.title && message == other.message && buttons == other.buttons && type == other.type && defaultValue == other.defaultValue && cancelButtonKey == other.cancelButtonKey && destructiveButtonKey == other.destructiveButtonKey && preferredButtonKey == other.preferredButtonKey && keyboardType == other.keyboardType && userInterfaceStyle == other.userInterfaceStyle;
  }
};

template <typename T>
struct AlertManagerArgsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<decltype(types.buttons)>(rt, value.getProperty(rt, "buttons"), jsInvoker),
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<decltype(types.defaultValue)>(rt, value.getProperty(rt, "defaultValue"), jsInvoker),
      bridging::fromJs<decltype(types.cancelButtonKey)>(rt, value.getProperty(rt, "cancelButtonKey"), jsInvoker),
      bridging::fromJs<decltype(types.destructiveButtonKey)>(rt, value.getProperty(rt, "destructiveButtonKey"), jsInvoker),
      bridging::fromJs<decltype(types.preferredButtonKey)>(rt, value.getProperty(rt, "preferredButtonKey"), jsInvoker),
      bridging::fromJs<decltype(types.keyboardType)>(rt, value.getProperty(rt, "keyboardType"), jsInvoker),
      bridging::fromJs<decltype(types.userInterfaceStyle)>(rt, value.getProperty(rt, "userInterfaceStyle"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array buttonsToJs(jsi::Runtime &rt, decltype(types.buttons) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String defaultValueToJs(jsi::Runtime &rt, decltype(types.defaultValue) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cancelButtonKeyToJs(jsi::Runtime &rt, decltype(types.cancelButtonKey) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String destructiveButtonKeyToJs(jsi::Runtime &rt, decltype(types.destructiveButtonKey) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String preferredButtonKeyToJs(jsi::Runtime &rt, decltype(types.preferredButtonKey) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String keyboardTypeToJs(jsi::Runtime &rt, decltype(types.keyboardType) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String userInterfaceStyleToJs(jsi::Runtime &rt, decltype(types.userInterfaceStyle) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.message) {
      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
    }
    if (value.buttons) {
      result.setProperty(rt, "buttons", bridging::toJs(rt, value.buttons.value(), jsInvoker));
    }
    if (value.type) {
      result.setProperty(rt, "type", bridging::toJs(rt, value.type.value(), jsInvoker));
    }
    if (value.defaultValue) {
      result.setProperty(rt, "defaultValue", bridging::toJs(rt, value.defaultValue.value(), jsInvoker));
    }
    if (value.cancelButtonKey) {
      result.setProperty(rt, "cancelButtonKey", bridging::toJs(rt, value.cancelButtonKey.value(), jsInvoker));
    }
    if (value.destructiveButtonKey) {
      result.setProperty(rt, "destructiveButtonKey", bridging::toJs(rt, value.destructiveButtonKey.value(), jsInvoker));
    }
    if (value.preferredButtonKey) {
      result.setProperty(rt, "preferredButtonKey", bridging::toJs(rt, value.preferredButtonKey.value(), jsInvoker));
    }
    if (value.keyboardType) {
      result.setProperty(rt, "keyboardType", bridging::toJs(rt, value.keyboardType.value(), jsInvoker));
    }
    if (value.userInterfaceStyle) {
      result.setProperty(rt, "userInterfaceStyle", bridging::toJs(rt, value.userInterfaceStyle.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeAlertManagerCxxSpecJSI : public TurboModule {
protected:
  NativeAlertManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void alertWithArgs(jsi::Runtime &rt, jsi::Object args, jsi::Function callback) = 0;

};

template <typename T>
class JSI_EXPORT NativeAlertManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "AlertManager";

protected:
  NativeAlertManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAlertManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAlertManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAlertManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void alertWithArgs(jsi::Runtime &rt, jsi::Object args, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::alertWithArgs) == 3,
          "Expected alertWithArgs(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::alertWithArgs, jsInvoker_, instance_, std::move(args), std::move(callback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeAnimatedModuleBaseEndResult

template <typename P0, typename P1>
struct [[deprecated("Use NativeAnimatedModuleEndResult instead.")]] NativeAnimatedModuleBaseEndResult {
  P0 finished;
  P1 value;
  bool operator==(const NativeAnimatedModuleBaseEndResult &other) const {
    return finished == other.finished && value == other.value;
  }
};

template <typename P0, typename P1>
struct [[deprecated("Use NativeAnimatedModuleEndResultBridging instead.")]] NativeAnimatedModuleBaseEndResultBridging {
  static NativeAnimatedModuleBaseEndResult<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeAnimatedModuleBaseEndResult<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "finished"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "value"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool finishedToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static double valueToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativeAnimatedModuleBaseEndResult<P0, P1> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
    if (value.value) {
      result.setProperty(rt, "value", bridging::toJs(rt, value.value.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeAnimatedModuleBaseEventMapping

template <typename P0, typename P1>
struct [[deprecated("Use NativeAnimatedModuleEventMapping instead.")]] NativeAnimatedModuleBaseEventMapping {
  P0 nativeEventPath;
  P1 animatedValueTag;
  bool operator==(const NativeAnimatedModuleBaseEventMapping &other) const {
    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
  }
};

template <typename P0, typename P1>
struct [[deprecated("Use NativeAnimatedModuleEventMappingBridging instead.")]] NativeAnimatedModuleBaseEventMappingBridging {
  static NativeAnimatedModuleBaseEventMapping<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeAnimatedModuleBaseEventMapping<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativeAnimatedModuleBaseEventMapping<P0, P1> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
    return result;
  }
};


#pragma mark - NativeAnimatedModuleEndResult

template <typename P0, typename P1>
struct NativeAnimatedModuleEndResult {
  P0 finished;
  P1 value;
  bool operator==(const NativeAnimatedModuleEndResult &other) const {
    return finished == other.finished && value == other.value;
  }
};

template <typename T>
struct NativeAnimatedModuleEndResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.finished)>(rt, value.getProperty(rt, "finished"), jsInvoker),
      bridging::fromJs<decltype(types.value)>(rt, value.getProperty(rt, "value"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool finishedToJs(jsi::Runtime &rt, decltype(types.finished) value) {
    return bridging::toJs(rt, value);
  }

  static double valueToJs(jsi::Runtime &rt, decltype(types.value) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
    if (value.value) {
      result.setProperty(rt, "value", bridging::toJs(rt, value.value.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeAnimatedModuleEventMapping

template <typename P0, typename P1>
struct NativeAnimatedModuleEventMapping {
  P0 nativeEventPath;
  P1 animatedValueTag;
  bool operator==(const NativeAnimatedModuleEventMapping &other) const {
    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
  }
};

template <typename T>
struct NativeAnimatedModuleEventMappingBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.nativeEventPath)>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
      bridging::fromJs<decltype(types.animatedValueTag)>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, decltype(types.nativeEventPath) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, decltype(types.animatedValueTag) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeAnimatedModuleCxxSpecJSI : public TurboModule {
protected:
  NativeAnimatedModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startOperationBatch(jsi::Runtime &rt) = 0;
  virtual void finishOperationBatch(jsi::Runtime &rt) = 0;
  virtual void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) = 0;
  virtual void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
  virtual void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
  virtual void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
  virtual void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
  virtual void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) = 0;
  virtual void stopAnimation(jsi::Runtime &rt, double animationId) = 0;
  virtual void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) = 0;
  virtual void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) = 0;
  virtual void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
  virtual void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
  virtual void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void dropAnimatedNode(jsi::Runtime &rt, double tag) = 0;
  virtual void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) = 0;
  virtual void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) = 0;

};

template <typename T>
class JSI_EXPORT NativeAnimatedModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "NativeAnimatedModule";

protected:
  NativeAnimatedModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAnimatedModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAnimatedModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAnimatedModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startOperationBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startOperationBatch) == 1,
          "Expected startOperationBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startOperationBatch, jsInvoker_, instance_);
    }
    void finishOperationBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::finishOperationBatch) == 1,
          "Expected finishOperationBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::finishOperationBatch, jsInvoker_, instance_);
    }
    void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::createAnimatedNode) == 3,
          "Expected createAnimatedNode(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createAnimatedNode, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::updateAnimatedNodeConfig) == 3,
          "Expected updateAnimatedNodeConfig(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::updateAnimatedNodeConfig, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 3,
          "Expected getValue(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(tag), std::move(saveValueCallback));
    }
    void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::startListeningToAnimatedNodeValue) == 2,
          "Expected startListeningToAnimatedNodeValue(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
    }
    void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::stopListeningToAnimatedNodeValue) == 2,
          "Expected stopListeningToAnimatedNodeValue(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
    }
    void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
      static_assert(
          bridging::getParameterCount(&T::connectAnimatedNodes) == 3,
          "Expected connectAnimatedNodes(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
    }
    void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
      static_assert(
          bridging::getParameterCount(&T::disconnectAnimatedNodes) == 3,
          "Expected disconnectAnimatedNodes(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
    }
    void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) override {
      static_assert(
          bridging::getParameterCount(&T::startAnimatingNode) == 5,
          "Expected startAnimatingNode(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startAnimatingNode, jsInvoker_, instance_, std::move(animationId), std::move(nodeTag), std::move(config), std::move(endCallback));
    }
    void stopAnimation(jsi::Runtime &rt, double animationId) override {
      static_assert(
          bridging::getParameterCount(&T::stopAnimation) == 2,
          "Expected stopAnimation(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopAnimation, jsInvoker_, instance_, std::move(animationId));
    }
    void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) override {
      static_assert(
          bridging::getParameterCount(&T::setAnimatedNodeValue) == 3,
          "Expected setAnimatedNodeValue(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAnimatedNodeValue, jsInvoker_, instance_, std::move(nodeTag), std::move(value));
    }
    void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) override {
      static_assert(
          bridging::getParameterCount(&T::setAnimatedNodeOffset) == 3,
          "Expected setAnimatedNodeOffset(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag), std::move(offset));
    }
    void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::flattenAnimatedNodeOffset) == 2,
          "Expected flattenAnimatedNodeOffset(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::flattenAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
    }
    void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::extractAnimatedNodeOffset) == 2,
          "Expected extractAnimatedNodeOffset(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::extractAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
    }
    void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
      static_assert(
          bridging::getParameterCount(&T::connectAnimatedNodeToView) == 3,
          "Expected connectAnimatedNodeToView(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connectAnimatedNodeToView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
    }
    void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
      static_assert(
          bridging::getParameterCount(&T::disconnectAnimatedNodeFromView) == 3,
          "Expected disconnectAnimatedNodeFromView(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnectAnimatedNodeFromView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
    }
    void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::restoreDefaultValues) == 2,
          "Expected restoreDefaultValues(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::restoreDefaultValues, jsInvoker_, instance_, std::move(nodeTag));
    }
    void dropAnimatedNode(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::dropAnimatedNode) == 2,
          "Expected dropAnimatedNode(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dropAnimatedNode, jsInvoker_, instance_, std::move(tag));
    }
    void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) override {
      static_assert(
          bridging::getParameterCount(&T::addAnimatedEventToView) == 4,
          "Expected addAnimatedEventToView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addAnimatedEventToView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(eventMapping));
    }
    void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::removeAnimatedEventFromView) == 4,
          "Expected removeAnimatedEventFromView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeAnimatedEventFromView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(animatedNodeTag));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) override {
      static_assert(
          bridging::getParameterCount(&T::queueAndExecuteBatchedOperations) == 2,
          "Expected queueAndExecuteBatchedOperations(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::queueAndExecuteBatchedOperations, jsInvoker_, instance_, std::move(operationsAndArgs));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeAnimatedTurboModuleBaseEndResult

template <typename P0, typename P1>
struct [[deprecated("Use NativeAnimatedTurboModuleEndResult instead.")]] NativeAnimatedTurboModuleBaseEndResult {
  P0 finished;
  P1 value;
  bool operator==(const NativeAnimatedTurboModuleBaseEndResult &other) const {
    return finished == other.finished && value == other.value;
  }
};

template <typename P0, typename P1>
struct [[deprecated("Use NativeAnimatedTurboModuleEndResultBridging instead.")]] NativeAnimatedTurboModuleBaseEndResultBridging {
  static NativeAnimatedTurboModuleBaseEndResult<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeAnimatedTurboModuleBaseEndResult<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "finished"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "value"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool finishedToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static double valueToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativeAnimatedTurboModuleBaseEndResult<P0, P1> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
    if (value.value) {
      result.setProperty(rt, "value", bridging::toJs(rt, value.value.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeAnimatedTurboModuleBaseEventMapping

template <typename P0, typename P1>
struct [[deprecated("Use NativeAnimatedTurboModuleEventMapping instead.")]] NativeAnimatedTurboModuleBaseEventMapping {
  P0 nativeEventPath;
  P1 animatedValueTag;
  bool operator==(const NativeAnimatedTurboModuleBaseEventMapping &other) const {
    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
  }
};

template <typename P0, typename P1>
struct [[deprecated("Use NativeAnimatedTurboModuleEventMappingBridging instead.")]] NativeAnimatedTurboModuleBaseEventMappingBridging {
  static NativeAnimatedTurboModuleBaseEventMapping<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeAnimatedTurboModuleBaseEventMapping<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativeAnimatedTurboModuleBaseEventMapping<P0, P1> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
    return result;
  }
};


#pragma mark - NativeAnimatedTurboModuleEndResult

template <typename P0, typename P1>
struct NativeAnimatedTurboModuleEndResult {
  P0 finished;
  P1 value;
  bool operator==(const NativeAnimatedTurboModuleEndResult &other) const {
    return finished == other.finished && value == other.value;
  }
};

template <typename T>
struct NativeAnimatedTurboModuleEndResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.finished)>(rt, value.getProperty(rt, "finished"), jsInvoker),
      bridging::fromJs<decltype(types.value)>(rt, value.getProperty(rt, "value"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool finishedToJs(jsi::Runtime &rt, decltype(types.finished) value) {
    return bridging::toJs(rt, value);
  }

  static double valueToJs(jsi::Runtime &rt, decltype(types.value) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
    if (value.value) {
      result.setProperty(rt, "value", bridging::toJs(rt, value.value.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeAnimatedTurboModuleEventMapping

template <typename P0, typename P1>
struct NativeAnimatedTurboModuleEventMapping {
  P0 nativeEventPath;
  P1 animatedValueTag;
  bool operator==(const NativeAnimatedTurboModuleEventMapping &other) const {
    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
  }
};

template <typename T>
struct NativeAnimatedTurboModuleEventMappingBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.nativeEventPath)>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
      bridging::fromJs<decltype(types.animatedValueTag)>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, decltype(types.nativeEventPath) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, decltype(types.animatedValueTag) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeAnimatedTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeAnimatedTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startOperationBatch(jsi::Runtime &rt) = 0;
  virtual void finishOperationBatch(jsi::Runtime &rt) = 0;
  virtual void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) = 0;
  virtual void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
  virtual void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
  virtual void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
  virtual void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
  virtual void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) = 0;
  virtual void stopAnimation(jsi::Runtime &rt, double animationId) = 0;
  virtual void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) = 0;
  virtual void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) = 0;
  virtual void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
  virtual void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
  virtual void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) = 0;
  virtual void dropAnimatedNode(jsi::Runtime &rt, double tag) = 0;
  virtual void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) = 0;
  virtual void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) = 0;

};

template <typename T>
class JSI_EXPORT NativeAnimatedTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "NativeAnimatedTurboModule";

protected:
  NativeAnimatedTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAnimatedTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAnimatedTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAnimatedTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startOperationBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startOperationBatch) == 1,
          "Expected startOperationBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startOperationBatch, jsInvoker_, instance_);
    }
    void finishOperationBatch(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::finishOperationBatch) == 1,
          "Expected finishOperationBatch(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::finishOperationBatch, jsInvoker_, instance_);
    }
    void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::createAnimatedNode) == 3,
          "Expected createAnimatedNode(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createAnimatedNode, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::updateAnimatedNodeConfig) == 3,
          "Expected updateAnimatedNodeConfig(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::updateAnimatedNodeConfig, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 3,
          "Expected getValue(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(tag), std::move(saveValueCallback));
    }
    void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::startListeningToAnimatedNodeValue) == 2,
          "Expected startListeningToAnimatedNodeValue(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
    }
    void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::stopListeningToAnimatedNodeValue) == 2,
          "Expected stopListeningToAnimatedNodeValue(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
    }
    void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
      static_assert(
          bridging::getParameterCount(&T::connectAnimatedNodes) == 3,
          "Expected connectAnimatedNodes(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
    }
    void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
      static_assert(
          bridging::getParameterCount(&T::disconnectAnimatedNodes) == 3,
          "Expected disconnectAnimatedNodes(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
    }
    void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) override {
      static_assert(
          bridging::getParameterCount(&T::startAnimatingNode) == 5,
          "Expected startAnimatingNode(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startAnimatingNode, jsInvoker_, instance_, std::move(animationId), std::move(nodeTag), std::move(config), std::move(endCallback));
    }
    void stopAnimation(jsi::Runtime &rt, double animationId) override {
      static_assert(
          bridging::getParameterCount(&T::stopAnimation) == 2,
          "Expected stopAnimation(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopAnimation, jsInvoker_, instance_, std::move(animationId));
    }
    void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) override {
      static_assert(
          bridging::getParameterCount(&T::setAnimatedNodeValue) == 3,
          "Expected setAnimatedNodeValue(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAnimatedNodeValue, jsInvoker_, instance_, std::move(nodeTag), std::move(value));
    }
    void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) override {
      static_assert(
          bridging::getParameterCount(&T::setAnimatedNodeOffset) == 3,
          "Expected setAnimatedNodeOffset(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag), std::move(offset));
    }
    void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::flattenAnimatedNodeOffset) == 2,
          "Expected flattenAnimatedNodeOffset(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::flattenAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
    }
    void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::extractAnimatedNodeOffset) == 2,
          "Expected extractAnimatedNodeOffset(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::extractAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
    }
    void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
      static_assert(
          bridging::getParameterCount(&T::connectAnimatedNodeToView) == 3,
          "Expected connectAnimatedNodeToView(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connectAnimatedNodeToView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
    }
    void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
      static_assert(
          bridging::getParameterCount(&T::disconnectAnimatedNodeFromView) == 3,
          "Expected disconnectAnimatedNodeFromView(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnectAnimatedNodeFromView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
    }
    void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::restoreDefaultValues) == 2,
          "Expected restoreDefaultValues(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::restoreDefaultValues, jsInvoker_, instance_, std::move(nodeTag));
    }
    void dropAnimatedNode(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::dropAnimatedNode) == 2,
          "Expected dropAnimatedNode(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dropAnimatedNode, jsInvoker_, instance_, std::move(tag));
    }
    void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) override {
      static_assert(
          bridging::getParameterCount(&T::addAnimatedEventToView) == 4,
          "Expected addAnimatedEventToView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addAnimatedEventToView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(eventMapping));
    }
    void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) override {
      static_assert(
          bridging::getParameterCount(&T::removeAnimatedEventFromView) == 4,
          "Expected removeAnimatedEventFromView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeAnimatedEventFromView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(animatedNodeTag));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) override {
      static_assert(
          bridging::getParameterCount(&T::queueAndExecuteBatchedOperations) == 2,
          "Expected queueAndExecuteBatchedOperations(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::queueAndExecuteBatchedOperations, jsInvoker_, instance_, std::move(operationsAndArgs));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeAnimationsDebugModuleCxxSpecJSI : public TurboModule {
protected:
  NativeAnimationsDebugModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startRecordingFps(jsi::Runtime &rt) = 0;
  virtual void stopRecordingFps(jsi::Runtime &rt, double animationStopTimeMs) = 0;

};

template <typename T>
class JSI_EXPORT NativeAnimationsDebugModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "AnimationsDebugModule";

protected:
  NativeAnimationsDebugModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAnimationsDebugModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAnimationsDebugModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAnimationsDebugModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startRecordingFps(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startRecordingFps) == 1,
          "Expected startRecordingFps(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startRecordingFps, jsInvoker_, instance_);
    }
    void stopRecordingFps(jsi::Runtime &rt, double animationStopTimeMs) override {
      static_assert(
          bridging::getParameterCount(&T::stopRecordingFps) == 2,
          "Expected stopRecordingFps(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopRecordingFps, jsInvoker_, instance_, std::move(animationStopTimeMs));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeAppearanceCxxSpecJSI : public TurboModule {
protected:
  NativeAppearanceCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual std::optional<jsi::String> getColorScheme(jsi::Runtime &rt) = 0;
  virtual void setColorScheme(jsi::Runtime &rt, jsi::String colorScheme) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeAppearanceCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "Appearance";

protected:
  NativeAppearanceCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAppearanceCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAppearanceCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAppearanceCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    std::optional<jsi::String> getColorScheme(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getColorScheme) == 1,
          "Expected getColorScheme(...) to have 1 parameters");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getColorScheme, jsInvoker_, instance_);
    }
    void setColorScheme(jsi::Runtime &rt, jsi::String colorScheme) override {
      static_assert(
          bridging::getParameterCount(&T::setColorScheme) == 2,
          "Expected setColorScheme(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setColorScheme, jsInvoker_, instance_, std::move(colorScheme));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - AppStateBaseAppStateConstants

template <typename P0>
struct [[deprecated("Use AppStateAppStateConstants instead.")]] AppStateBaseAppStateConstants {
  P0 initialAppState;
  bool operator==(const AppStateBaseAppStateConstants &other) const {
    return initialAppState == other.initialAppState;
  }
};

template <typename P0>
struct [[deprecated("Use AppStateAppStateConstantsBridging instead.")]] AppStateBaseAppStateConstantsBridging {
  static AppStateBaseAppStateConstants<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AppStateBaseAppStateConstants<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "initialAppState"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String initialAppStateToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const AppStateBaseAppStateConstants<P0> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "initialAppState", bridging::toJs(rt, value.initialAppState, jsInvoker));
    return result;
  }
};



#pragma mark - AppStateBaseAppState

template <typename P0>
struct [[deprecated("Use AppStateAppState instead.")]] AppStateBaseAppState {
  P0 app_state;
  bool operator==(const AppStateBaseAppState &other) const {
    return app_state == other.app_state;
  }
};

template <typename P0>
struct [[deprecated("Use AppStateAppStateBridging instead.")]] AppStateBaseAppStateBridging {
  static AppStateBaseAppState<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AppStateBaseAppState<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "app_state"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String app_stateToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const AppStateBaseAppState<P0> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "app_state", bridging::toJs(rt, value.app_state, jsInvoker));
    return result;
  }
};


#pragma mark - AppStateAppStateConstants

template <typename P0>
struct AppStateAppStateConstants {
  P0 initialAppState;
  bool operator==(const AppStateAppStateConstants &other) const {
    return initialAppState == other.initialAppState;
  }
};

template <typename T>
struct AppStateAppStateConstantsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.initialAppState)>(rt, value.getProperty(rt, "initialAppState"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String initialAppStateToJs(jsi::Runtime &rt, decltype(types.initialAppState) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "initialAppState", bridging::toJs(rt, value.initialAppState, jsInvoker));
    return result;
  }
};



#pragma mark - AppStateAppState

template <typename P0>
struct AppStateAppState {
  P0 app_state;
  bool operator==(const AppStateAppState &other) const {
    return app_state == other.app_state;
  }
};

template <typename T>
struct AppStateAppStateBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.app_state)>(rt, value.getProperty(rt, "app_state"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String app_stateToJs(jsi::Runtime &rt, decltype(types.app_state) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "app_state", bridging::toJs(rt, value.app_state, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeAppStateCxxSpecJSI : public TurboModule {
protected:
  NativeAppStateCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void getCurrentAppState(jsi::Runtime &rt, jsi::Function success, jsi::Function error) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeAppStateCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "AppState";

protected:
  NativeAppStateCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAppStateCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAppStateCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAppStateCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void getCurrentAppState(jsi::Runtime &rt, jsi::Function success, jsi::Function error) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentAppState) == 3,
          "Expected getCurrentAppState(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getCurrentAppState, jsInvoker_, instance_, std::move(success), std::move(error));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - AppThemeBaseHighContrastColors

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct [[deprecated("Use AppThemeHighContrastColors instead.")]] AppThemeBaseHighContrastColors {
  P0 ButtonFaceColor;
  P1 ButtonTextColor;
  P2 GrayTextColor;
  P3 HighlightColor;
  P4 HighlightTextColor;
  P5 HotlightColor;
  P6 WindowColor;
  P7 WindowTextColor;
  bool operator==(const AppThemeBaseHighContrastColors &other) const {
    return ButtonFaceColor == other.ButtonFaceColor && ButtonTextColor == other.ButtonTextColor && GrayTextColor == other.GrayTextColor && HighlightColor == other.HighlightColor && HighlightTextColor == other.HighlightTextColor && HotlightColor == other.HotlightColor && WindowColor == other.WindowColor && WindowTextColor == other.WindowTextColor;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct [[deprecated("Use AppThemeHighContrastColorsBridging instead.")]] AppThemeBaseHighContrastColorsBridging {
  static AppThemeBaseHighContrastColors<P0, P1, P2, P3, P4, P5, P6, P7> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AppThemeBaseHighContrastColors<P0, P1, P2, P3, P4, P5, P6, P7> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "ButtonFaceColor"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "ButtonTextColor"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "GrayTextColor"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "HighlightColor"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "HighlightTextColor"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "HotlightColor"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "WindowColor"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "WindowTextColor"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String ButtonFaceColorToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ButtonTextColorToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String GrayTextColorToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String HighlightColorToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String HighlightTextColorToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String HotlightColorToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String WindowColorToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String WindowTextColorToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const AppThemeBaseHighContrastColors<P0, P1, P2, P3, P4, P5, P6, P7> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "ButtonFaceColor", bridging::toJs(rt, value.ButtonFaceColor, jsInvoker));
    result.setProperty(rt, "ButtonTextColor", bridging::toJs(rt, value.ButtonTextColor, jsInvoker));
    result.setProperty(rt, "GrayTextColor", bridging::toJs(rt, value.GrayTextColor, jsInvoker));
    result.setProperty(rt, "HighlightColor", bridging::toJs(rt, value.HighlightColor, jsInvoker));
    result.setProperty(rt, "HighlightTextColor", bridging::toJs(rt, value.HighlightTextColor, jsInvoker));
    result.setProperty(rt, "HotlightColor", bridging::toJs(rt, value.HotlightColor, jsInvoker));
    result.setProperty(rt, "WindowColor", bridging::toJs(rt, value.WindowColor, jsInvoker));
    result.setProperty(rt, "WindowTextColor", bridging::toJs(rt, value.WindowTextColor, jsInvoker));
    return result;
  }
};



#pragma mark - AppThemeBaseAppThemeData

template <typename P0, typename P1>
struct [[deprecated("Use AppThemeAppThemeData instead.")]] AppThemeBaseAppThemeData {
  P0 isHighContrast;
  P1 highContrastColors;
  bool operator==(const AppThemeBaseAppThemeData &other) const {
    return isHighContrast == other.isHighContrast && highContrastColors == other.highContrastColors;
  }
};

template <typename P0, typename P1>
struct [[deprecated("Use AppThemeAppThemeDataBridging instead.")]] AppThemeBaseAppThemeDataBridging {
  static AppThemeBaseAppThemeData<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AppThemeBaseAppThemeData<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "isHighContrast"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "highContrastColors"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isHighContrastToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object highContrastColorsToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const AppThemeBaseAppThemeData<P0, P1> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isHighContrast", bridging::toJs(rt, value.isHighContrast, jsInvoker));
    result.setProperty(rt, "highContrastColors", bridging::toJs(rt, value.highContrastColors, jsInvoker));
    return result;
  }
};


#pragma mark - AppThemeHighContrastColors

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct AppThemeHighContrastColors {
  P0 ButtonFaceColor;
  P1 ButtonTextColor;
  P2 GrayTextColor;
  P3 HighlightColor;
  P4 HighlightTextColor;
  P5 HotlightColor;
  P6 WindowColor;
  P7 WindowTextColor;
  bool operator==(const AppThemeHighContrastColors &other) const {
    return ButtonFaceColor == other.ButtonFaceColor && ButtonTextColor == other.ButtonTextColor && GrayTextColor == other.GrayTextColor && HighlightColor == other.HighlightColor && HighlightTextColor == other.HighlightTextColor && HotlightColor == other.HotlightColor && WindowColor == other.WindowColor && WindowTextColor == other.WindowTextColor;
  }
};

template <typename T>
struct AppThemeHighContrastColorsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.ButtonFaceColor)>(rt, value.getProperty(rt, "ButtonFaceColor"), jsInvoker),
      bridging::fromJs<decltype(types.ButtonTextColor)>(rt, value.getProperty(rt, "ButtonTextColor"), jsInvoker),
      bridging::fromJs<decltype(types.GrayTextColor)>(rt, value.getProperty(rt, "GrayTextColor"), jsInvoker),
      bridging::fromJs<decltype(types.HighlightColor)>(rt, value.getProperty(rt, "HighlightColor"), jsInvoker),
      bridging::fromJs<decltype(types.HighlightTextColor)>(rt, value.getProperty(rt, "HighlightTextColor"), jsInvoker),
      bridging::fromJs<decltype(types.HotlightColor)>(rt, value.getProperty(rt, "HotlightColor"), jsInvoker),
      bridging::fromJs<decltype(types.WindowColor)>(rt, value.getProperty(rt, "WindowColor"), jsInvoker),
      bridging::fromJs<decltype(types.WindowTextColor)>(rt, value.getProperty(rt, "WindowTextColor"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String ButtonFaceColorToJs(jsi::Runtime &rt, decltype(types.ButtonFaceColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ButtonTextColorToJs(jsi::Runtime &rt, decltype(types.ButtonTextColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String GrayTextColorToJs(jsi::Runtime &rt, decltype(types.GrayTextColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String HighlightColorToJs(jsi::Runtime &rt, decltype(types.HighlightColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String HighlightTextColorToJs(jsi::Runtime &rt, decltype(types.HighlightTextColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String HotlightColorToJs(jsi::Runtime &rt, decltype(types.HotlightColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String WindowColorToJs(jsi::Runtime &rt, decltype(types.WindowColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String WindowTextColorToJs(jsi::Runtime &rt, decltype(types.WindowTextColor) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "ButtonFaceColor", bridging::toJs(rt, value.ButtonFaceColor, jsInvoker));
    result.setProperty(rt, "ButtonTextColor", bridging::toJs(rt, value.ButtonTextColor, jsInvoker));
    result.setProperty(rt, "GrayTextColor", bridging::toJs(rt, value.GrayTextColor, jsInvoker));
    result.setProperty(rt, "HighlightColor", bridging::toJs(rt, value.HighlightColor, jsInvoker));
    result.setProperty(rt, "HighlightTextColor", bridging::toJs(rt, value.HighlightTextColor, jsInvoker));
    result.setProperty(rt, "HotlightColor", bridging::toJs(rt, value.HotlightColor, jsInvoker));
    result.setProperty(rt, "WindowColor", bridging::toJs(rt, value.WindowColor, jsInvoker));
    result.setProperty(rt, "WindowTextColor", bridging::toJs(rt, value.WindowTextColor, jsInvoker));
    return result;
  }
};



#pragma mark - AppThemeAppThemeData

template <typename P0, typename P1>
struct AppThemeAppThemeData {
  P0 isHighContrast;
  P1 highContrastColors;
  bool operator==(const AppThemeAppThemeData &other) const {
    return isHighContrast == other.isHighContrast && highContrastColors == other.highContrastColors;
  }
};

template <typename T>
struct AppThemeAppThemeDataBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.isHighContrast)>(rt, value.getProperty(rt, "isHighContrast"), jsInvoker),
      bridging::fromJs<decltype(types.highContrastColors)>(rt, value.getProperty(rt, "highContrastColors"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isHighContrastToJs(jsi::Runtime &rt, decltype(types.isHighContrast) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object highContrastColorsToJs(jsi::Runtime &rt, decltype(types.highContrastColors) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isHighContrast", bridging::toJs(rt, value.isHighContrast, jsInvoker));
    result.setProperty(rt, "highContrastColors", bridging::toJs(rt, value.highContrastColors, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeAppThemeCxxSpecJSI : public TurboModule {
protected:
  NativeAppThemeCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeAppThemeCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "AppTheme";

protected:
  NativeAppThemeCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAppThemeCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeAppThemeCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAppThemeCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeBlobModuleCxxSpecJSI : public TurboModule {
protected:
  NativeBlobModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void addNetworkingHandler(jsi::Runtime &rt) = 0;
  virtual void addWebSocketHandler(jsi::Runtime &rt, double id) = 0;
  virtual void removeWebSocketHandler(jsi::Runtime &rt, double id) = 0;
  virtual void sendOverSocket(jsi::Runtime &rt, jsi::Object blob, double socketID) = 0;
  virtual void createFromParts(jsi::Runtime &rt, jsi::Array parts, jsi::String withId) = 0;
  virtual void release(jsi::Runtime &rt, jsi::String blobId) = 0;

};

template <typename T>
class JSI_EXPORT NativeBlobModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "BlobModule";

protected:
  NativeBlobModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeBlobModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeBlobModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeBlobModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void addNetworkingHandler(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::addNetworkingHandler) == 1,
          "Expected addNetworkingHandler(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addNetworkingHandler, jsInvoker_, instance_);
    }
    void addWebSocketHandler(jsi::Runtime &rt, double id) override {
      static_assert(
          bridging::getParameterCount(&T::addWebSocketHandler) == 2,
          "Expected addWebSocketHandler(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addWebSocketHandler, jsInvoker_, instance_, std::move(id));
    }
    void removeWebSocketHandler(jsi::Runtime &rt, double id) override {
      static_assert(
          bridging::getParameterCount(&T::removeWebSocketHandler) == 2,
          "Expected removeWebSocketHandler(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeWebSocketHandler, jsInvoker_, instance_, std::move(id));
    }
    void sendOverSocket(jsi::Runtime &rt, jsi::Object blob, double socketID) override {
      static_assert(
          bridging::getParameterCount(&T::sendOverSocket) == 3,
          "Expected sendOverSocket(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendOverSocket, jsInvoker_, instance_, std::move(blob), std::move(socketID));
    }
    void createFromParts(jsi::Runtime &rt, jsi::Array parts, jsi::String withId) override {
      static_assert(
          bridging::getParameterCount(&T::createFromParts) == 3,
          "Expected createFromParts(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createFromParts, jsInvoker_, instance_, std::move(parts), std::move(withId));
    }
    void release(jsi::Runtime &rt, jsi::String blobId) override {
      static_assert(
          bridging::getParameterCount(&T::release) == 2,
          "Expected release(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::release, jsInvoker_, instance_, std::move(blobId));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeBugReportingCxxSpecJSI : public TurboModule {
protected:
  NativeBugReportingCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startReportAProblemFlow(jsi::Runtime &rt) = 0;
  virtual void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::Object extraFiles) = 0;

};

template <typename T>
class JSI_EXPORT NativeBugReportingCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "BugReporting";

protected:
  NativeBugReportingCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeBugReportingCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeBugReportingCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeBugReportingCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startReportAProblemFlow(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::startReportAProblemFlow) == 1,
          "Expected startReportAProblemFlow(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startReportAProblemFlow, jsInvoker_, instance_);
    }
    void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::Object extraFiles) override {
      static_assert(
          bridging::getParameterCount(&T::setExtraData) == 3,
          "Expected setExtraData(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setExtraData, jsInvoker_, instance_, std::move(extraData), std::move(extraFiles));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeClipboardCxxSpecJSI : public TurboModule {
protected:
  NativeClipboardCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value getString(jsi::Runtime &rt) = 0;
  virtual void setString(jsi::Runtime &rt, jsi::String content) = 0;

};

template <typename T>
class JSI_EXPORT NativeClipboardCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "Clipboard";

protected:
  NativeClipboardCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeClipboardCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeClipboardCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeClipboardCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value getString(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 1,
          "Expected getString(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getString, jsInvoker_, instance_);
    }
    void setString(jsi::Runtime &rt, jsi::String content) override {
      static_assert(
          bridging::getParameterCount(&T::setString) == 2,
          "Expected setString(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setString, jsInvoker_, instance_, std::move(content));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDeviceEventManagerCxxSpecJSI : public TurboModule {
protected:
  NativeDeviceEventManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void invokeDefaultBackPressHandler(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeDeviceEventManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "DeviceEventManager";

protected:
  NativeDeviceEventManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeDeviceEventManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDeviceEventManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDeviceEventManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void invokeDefaultBackPressHandler(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::invokeDefaultBackPressHandler) == 1,
          "Expected invokeDefaultBackPressHandler(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::invokeDefaultBackPressHandler, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - DeviceInfoBaseDisplayMetrics

template <typename P0, typename P1, typename P2, typename P3>
struct [[deprecated("Use DeviceInfoDisplayMetrics instead.")]] DeviceInfoBaseDisplayMetrics {
  P0 width;
  P1 height;
  P2 scale;
  P3 fontScale;
  bool operator==(const DeviceInfoBaseDisplayMetrics &other) const {
    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale;
  }
};

template <typename P0, typename P1, typename P2, typename P3>
struct [[deprecated("Use DeviceInfoDisplayMetricsBridging instead.")]] DeviceInfoBaseDisplayMetricsBridging {
  static DeviceInfoBaseDisplayMetrics<P0, P1, P2, P3> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    DeviceInfoBaseDisplayMetrics<P0, P1, P2, P3> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "scale"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "fontScale"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static double scaleToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static double fontScaleToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const DeviceInfoBaseDisplayMetrics<P0, P1, P2, P3> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
    return result;
  }
};



#pragma mark - DeviceInfoBaseDisplayMetricsAndroid

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct [[deprecated("Use DeviceInfoDisplayMetricsAndroid instead.")]] DeviceInfoBaseDisplayMetricsAndroid {
  P0 width;
  P1 height;
  P2 scale;
  P3 fontScale;
  P4 densityDpi;
  bool operator==(const DeviceInfoBaseDisplayMetricsAndroid &other) const {
    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale && densityDpi == other.densityDpi;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct [[deprecated("Use DeviceInfoDisplayMetricsAndroidBridging instead.")]] DeviceInfoBaseDisplayMetricsAndroidBridging {
  static DeviceInfoBaseDisplayMetricsAndroid<P0, P1, P2, P3, P4> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    DeviceInfoBaseDisplayMetricsAndroid<P0, P1, P2, P3, P4> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "scale"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "fontScale"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "densityDpi"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static double scaleToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static double fontScaleToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static double densityDpiToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const DeviceInfoBaseDisplayMetricsAndroid<P0, P1, P2, P3, P4> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
    result.setProperty(rt, "densityDpi", bridging::toJs(rt, value.densityDpi, jsInvoker));
    return result;
  }
};



#pragma mark - DeviceInfoBaseDimensionsPayload

template <typename P0, typename P1, typename P2, typename P3>
struct [[deprecated("Use DeviceInfoDimensionsPayload instead.")]] DeviceInfoBaseDimensionsPayload {
  P0 window;
  P1 screen;
  P2 windowPhysicalPixels;
  P3 screenPhysicalPixels;
  bool operator==(const DeviceInfoBaseDimensionsPayload &other) const {
    return window == other.window && screen == other.screen && windowPhysicalPixels == other.windowPhysicalPixels && screenPhysicalPixels == other.screenPhysicalPixels;
  }
};

template <typename P0, typename P1, typename P2, typename P3>
struct [[deprecated("Use DeviceInfoDimensionsPayloadBridging instead.")]] DeviceInfoBaseDimensionsPayloadBridging {
  static DeviceInfoBaseDimensionsPayload<P0, P1, P2, P3> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    DeviceInfoBaseDimensionsPayload<P0, P1, P2, P3> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "window"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "screen"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "windowPhysicalPixels"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "screenPhysicalPixels"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object windowToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object screenToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object windowPhysicalPixelsToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object screenPhysicalPixelsToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const DeviceInfoBaseDimensionsPayload<P0, P1, P2, P3> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.window) {
      result.setProperty(rt, "window", bridging::toJs(rt, value.window.value(), jsInvoker));
    }
    if (value.screen) {
      result.setProperty(rt, "screen", bridging::toJs(rt, value.screen.value(), jsInvoker));
    }
    if (value.windowPhysicalPixels) {
      result.setProperty(rt, "windowPhysicalPixels", bridging::toJs(rt, value.windowPhysicalPixels.value(), jsInvoker));
    }
    if (value.screenPhysicalPixels) {
      result.setProperty(rt, "screenPhysicalPixels", bridging::toJs(rt, value.screenPhysicalPixels.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - DeviceInfoBaseDeviceInfoConstants

template <typename P0, typename P1>
struct [[deprecated("Use DeviceInfoDeviceInfoConstants instead.")]] DeviceInfoBaseDeviceInfoConstants {
  P0 Dimensions;
  P1 isIPhoneX_deprecated;
  bool operator==(const DeviceInfoBaseDeviceInfoConstants &other) const {
    return Dimensions == other.Dimensions && isIPhoneX_deprecated == other.isIPhoneX_deprecated;
  }
};

template <typename P0, typename P1>
struct [[deprecated("Use DeviceInfoDeviceInfoConstantsBridging instead.")]] DeviceInfoBaseDeviceInfoConstantsBridging {
  static DeviceInfoBaseDeviceInfoConstants<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    DeviceInfoBaseDeviceInfoConstants<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "Dimensions"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "isIPhoneX_deprecated"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object DimensionsToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static bool isIPhoneX_deprecatedToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const DeviceInfoBaseDeviceInfoConstants<P0, P1> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "Dimensions", bridging::toJs(rt, value.Dimensions, jsInvoker));
    if (value.isIPhoneX_deprecated) {
      result.setProperty(rt, "isIPhoneX_deprecated", bridging::toJs(rt, value.isIPhoneX_deprecated.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - DeviceInfoDisplayMetrics

template <typename P0, typename P1, typename P2, typename P3>
struct DeviceInfoDisplayMetrics {
  P0 width;
  P1 height;
  P2 scale;
  P3 fontScale;
  bool operator==(const DeviceInfoDisplayMetrics &other) const {
    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale;
  }
};

template <typename T>
struct DeviceInfoDisplayMetricsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.scale)>(rt, value.getProperty(rt, "scale"), jsInvoker),
      bridging::fromJs<decltype(types.fontScale)>(rt, value.getProperty(rt, "fontScale"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static double scaleToJs(jsi::Runtime &rt, decltype(types.scale) value) {
    return bridging::toJs(rt, value);
  }

  static double fontScaleToJs(jsi::Runtime &rt, decltype(types.fontScale) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
    return result;
  }
};



#pragma mark - DeviceInfoDisplayMetricsAndroid

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct DeviceInfoDisplayMetricsAndroid {
  P0 width;
  P1 height;
  P2 scale;
  P3 fontScale;
  P4 densityDpi;
  bool operator==(const DeviceInfoDisplayMetricsAndroid &other) const {
    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale && densityDpi == other.densityDpi;
  }
};

template <typename T>
struct DeviceInfoDisplayMetricsAndroidBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.scale)>(rt, value.getProperty(rt, "scale"), jsInvoker),
      bridging::fromJs<decltype(types.fontScale)>(rt, value.getProperty(rt, "fontScale"), jsInvoker),
      bridging::fromJs<decltype(types.densityDpi)>(rt, value.getProperty(rt, "densityDpi"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static double scaleToJs(jsi::Runtime &rt, decltype(types.scale) value) {
    return bridging::toJs(rt, value);
  }

  static double fontScaleToJs(jsi::Runtime &rt, decltype(types.fontScale) value) {
    return bridging::toJs(rt, value);
  }

  static double densityDpiToJs(jsi::Runtime &rt, decltype(types.densityDpi) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
    result.setProperty(rt, "densityDpi", bridging::toJs(rt, value.densityDpi, jsInvoker));
    return result;
  }
};



#pragma mark - DeviceInfoDimensionsPayload

template <typename P0, typename P1, typename P2, typename P3>
struct DeviceInfoDimensionsPayload {
  P0 window;
  P1 screen;
  P2 windowPhysicalPixels;
  P3 screenPhysicalPixels;
  bool operator==(const DeviceInfoDimensionsPayload &other) const {
    return window == other.window && screen == other.screen && windowPhysicalPixels == other.windowPhysicalPixels && screenPhysicalPixels == other.screenPhysicalPixels;
  }
};

template <typename T>
struct DeviceInfoDimensionsPayloadBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.window)>(rt, value.getProperty(rt, "window"), jsInvoker),
      bridging::fromJs<decltype(types.screen)>(rt, value.getProperty(rt, "screen"), jsInvoker),
      bridging::fromJs<decltype(types.windowPhysicalPixels)>(rt, value.getProperty(rt, "windowPhysicalPixels"), jsInvoker),
      bridging::fromJs<decltype(types.screenPhysicalPixels)>(rt, value.getProperty(rt, "screenPhysicalPixels"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object windowToJs(jsi::Runtime &rt, decltype(types.window) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object screenToJs(jsi::Runtime &rt, decltype(types.screen) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object windowPhysicalPixelsToJs(jsi::Runtime &rt, decltype(types.windowPhysicalPixels) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object screenPhysicalPixelsToJs(jsi::Runtime &rt, decltype(types.screenPhysicalPixels) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.window) {
      result.setProperty(rt, "window", bridging::toJs(rt, value.window.value(), jsInvoker));
    }
    if (value.screen) {
      result.setProperty(rt, "screen", bridging::toJs(rt, value.screen.value(), jsInvoker));
    }
    if (value.windowPhysicalPixels) {
      result.setProperty(rt, "windowPhysicalPixels", bridging::toJs(rt, value.windowPhysicalPixels.value(), jsInvoker));
    }
    if (value.screenPhysicalPixels) {
      result.setProperty(rt, "screenPhysicalPixels", bridging::toJs(rt, value.screenPhysicalPixels.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - DeviceInfoDeviceInfoConstants

template <typename P0, typename P1>
struct DeviceInfoDeviceInfoConstants {
  P0 Dimensions;
  P1 isIPhoneX_deprecated;
  bool operator==(const DeviceInfoDeviceInfoConstants &other) const {
    return Dimensions == other.Dimensions && isIPhoneX_deprecated == other.isIPhoneX_deprecated;
  }
};

template <typename T>
struct DeviceInfoDeviceInfoConstantsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.Dimensions)>(rt, value.getProperty(rt, "Dimensions"), jsInvoker),
      bridging::fromJs<decltype(types.isIPhoneX_deprecated)>(rt, value.getProperty(rt, "isIPhoneX_deprecated"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object DimensionsToJs(jsi::Runtime &rt, decltype(types.Dimensions) value) {
    return bridging::toJs(rt, value);
  }

  static bool isIPhoneX_deprecatedToJs(jsi::Runtime &rt, decltype(types.isIPhoneX_deprecated) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "Dimensions", bridging::toJs(rt, value.Dimensions, jsInvoker));
    if (value.isIPhoneX_deprecated) {
      result.setProperty(rt, "isIPhoneX_deprecated", bridging::toJs(rt, value.isIPhoneX_deprecated.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeDeviceInfoCxxSpecJSI : public TurboModule {
protected:
  NativeDeviceInfoCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeDeviceInfoCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "DeviceInfo";

protected:
  NativeDeviceInfoCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeDeviceInfoCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDeviceInfoCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDeviceInfoCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDevLoadingViewCxxSpecJSI : public TurboModule {
protected:
  NativeDevLoadingViewCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void showMessage(jsi::Runtime &rt, jsi::String message, std::optional<double> withColor, std::optional<double> withBackgroundColor) = 0;
  virtual void hide(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeDevLoadingViewCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "DevLoadingView";

protected:
  NativeDevLoadingViewCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeDevLoadingViewCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDevLoadingViewCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDevLoadingViewCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void showMessage(jsi::Runtime &rt, jsi::String message, std::optional<double> withColor, std::optional<double> withBackgroundColor) override {
      static_assert(
          bridging::getParameterCount(&T::showMessage) == 4,
          "Expected showMessage(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showMessage, jsInvoker_, instance_, std::move(message), std::move(withColor), std::move(withBackgroundColor));
    }
    void hide(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::hide) == 1,
          "Expected hide(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::hide, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDevMenuCxxSpecJSI : public TurboModule {
protected:
  NativeDevMenuCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void show(jsi::Runtime &rt) = 0;
  virtual void reload(jsi::Runtime &rt) = 0;
  virtual void debugRemotely(jsi::Runtime &rt, bool enableDebug) = 0;
  virtual void setProfilingEnabled(jsi::Runtime &rt, bool enabled) = 0;
  virtual void setHotLoadingEnabled(jsi::Runtime &rt, bool enabled) = 0;

};

template <typename T>
class JSI_EXPORT NativeDevMenuCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "DevMenu";

protected:
  NativeDevMenuCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeDevMenuCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDevMenuCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDevMenuCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void show(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::show) == 1,
          "Expected show(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::show, jsInvoker_, instance_);
    }
    void reload(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::reload) == 1,
          "Expected reload(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reload, jsInvoker_, instance_);
    }
    void debugRemotely(jsi::Runtime &rt, bool enableDebug) override {
      static_assert(
          bridging::getParameterCount(&T::debugRemotely) == 2,
          "Expected debugRemotely(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::debugRemotely, jsInvoker_, instance_, std::move(enableDebug));
    }
    void setProfilingEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setProfilingEnabled) == 2,
          "Expected setProfilingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setProfilingEnabled, jsInvoker_, instance_, std::move(enabled));
    }
    void setHotLoadingEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setHotLoadingEnabled) == 2,
          "Expected setHotLoadingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setHotLoadingEnabled, jsInvoker_, instance_, std::move(enabled));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDevSettingsCxxSpecJSI : public TurboModule {
protected:
  NativeDevSettingsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void reload(jsi::Runtime &rt) = 0;
  virtual void reloadWithReason(jsi::Runtime &rt, jsi::String reason) = 0;
  virtual void onFastRefresh(jsi::Runtime &rt) = 0;
  virtual void setHotLoadingEnabled(jsi::Runtime &rt, bool isHotLoadingEnabled) = 0;
  virtual void setIsDebuggingRemotely(jsi::Runtime &rt, bool isDebuggingRemotelyEnabled) = 0;
  virtual void setProfilingEnabled(jsi::Runtime &rt, bool isProfilingEnabled) = 0;
  virtual void toggleElementInspector(jsi::Runtime &rt) = 0;
  virtual void addMenuItem(jsi::Runtime &rt, jsi::String title) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual void setIsShakeToShowDevMenuEnabled(jsi::Runtime &rt, bool enabled) = 0;

};

template <typename T>
class JSI_EXPORT NativeDevSettingsCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "DevSettings";

protected:
  NativeDevSettingsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeDevSettingsCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDevSettingsCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDevSettingsCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void reload(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::reload) == 1,
          "Expected reload(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reload, jsInvoker_, instance_);
    }
    void reloadWithReason(jsi::Runtime &rt, jsi::String reason) override {
      static_assert(
          bridging::getParameterCount(&T::reloadWithReason) == 2,
          "Expected reloadWithReason(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reloadWithReason, jsInvoker_, instance_, std::move(reason));
    }
    void onFastRefresh(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::onFastRefresh) == 1,
          "Expected onFastRefresh(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onFastRefresh, jsInvoker_, instance_);
    }
    void setHotLoadingEnabled(jsi::Runtime &rt, bool isHotLoadingEnabled) override {
      static_assert(
          bridging::getParameterCount(&T::setHotLoadingEnabled) == 2,
          "Expected setHotLoadingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setHotLoadingEnabled, jsInvoker_, instance_, std::move(isHotLoadingEnabled));
    }
    void setIsDebuggingRemotely(jsi::Runtime &rt, bool isDebuggingRemotelyEnabled) override {
      static_assert(
          bridging::getParameterCount(&T::setIsDebuggingRemotely) == 2,
          "Expected setIsDebuggingRemotely(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setIsDebuggingRemotely, jsInvoker_, instance_, std::move(isDebuggingRemotelyEnabled));
    }
    void setProfilingEnabled(jsi::Runtime &rt, bool isProfilingEnabled) override {
      static_assert(
          bridging::getParameterCount(&T::setProfilingEnabled) == 2,
          "Expected setProfilingEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setProfilingEnabled, jsInvoker_, instance_, std::move(isProfilingEnabled));
    }
    void toggleElementInspector(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::toggleElementInspector) == 1,
          "Expected toggleElementInspector(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::toggleElementInspector, jsInvoker_, instance_);
    }
    void addMenuItem(jsi::Runtime &rt, jsi::String title) override {
      static_assert(
          bridging::getParameterCount(&T::addMenuItem) == 2,
          "Expected addMenuItem(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addMenuItem, jsInvoker_, instance_, std::move(title));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    void setIsShakeToShowDevMenuEnabled(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setIsShakeToShowDevMenuEnabled) == 2,
          "Expected setIsShakeToShowDevMenuEnabled(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setIsShakeToShowDevMenuEnabled, jsInvoker_, instance_, std::move(enabled));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeDevToolsSettingsManagerCxxSpecJSI : public TurboModule {
protected:
  NativeDevToolsSettingsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void setConsolePatchSettings(jsi::Runtime &rt, jsi::String newConsolePatchSettings) = 0;
  virtual std::optional<jsi::String> getConsolePatchSettings(jsi::Runtime &rt) = 0;
  virtual void setProfilingSettings(jsi::Runtime &rt, jsi::String newProfilingSettings) = 0;
  virtual std::optional<jsi::String> getProfilingSettings(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeDevToolsSettingsManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "DevToolsSettingsManager";

protected:
  NativeDevToolsSettingsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeDevToolsSettingsManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDevToolsSettingsManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDevToolsSettingsManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void setConsolePatchSettings(jsi::Runtime &rt, jsi::String newConsolePatchSettings) override {
      static_assert(
          bridging::getParameterCount(&T::setConsolePatchSettings) == 2,
          "Expected setConsolePatchSettings(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setConsolePatchSettings, jsInvoker_, instance_, std::move(newConsolePatchSettings));
    }
    std::optional<jsi::String> getConsolePatchSettings(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConsolePatchSettings) == 1,
          "Expected getConsolePatchSettings(...) to have 1 parameters");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getConsolePatchSettings, jsInvoker_, instance_);
    }
    void setProfilingSettings(jsi::Runtime &rt, jsi::String newProfilingSettings) override {
      static_assert(
          bridging::getParameterCount(&T::setProfilingSettings) == 2,
          "Expected setProfilingSettings(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setProfilingSettings, jsInvoker_, instance_, std::move(newProfilingSettings));
    }
    std::optional<jsi::String> getProfilingSettings(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getProfilingSettings) == 1,
          "Expected getProfilingSettings(...) to have 1 parameters");

      return bridging::callFromJs<std::optional<jsi::String>>(
          rt, &T::getProfilingSettings, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - DialogManagerAndroidBaseDialogOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct [[deprecated("Use DialogManagerAndroidDialogOptions instead.")]] DialogManagerAndroidBaseDialogOptions {
  P0 title;
  P1 message;
  P2 buttonPositive;
  P3 buttonNegative;
  P4 buttonNeutral;
  P5 items;
  P6 cancelable;
  bool operator==(const DialogManagerAndroidBaseDialogOptions &other) const {
    return title == other.title && message == other.message && buttonPositive == other.buttonPositive && buttonNegative == other.buttonNegative && buttonNeutral == other.buttonNeutral && items == other.items && cancelable == other.cancelable;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct [[deprecated("Use DialogManagerAndroidDialogOptionsBridging instead.")]] DialogManagerAndroidBaseDialogOptionsBridging {
  static DialogManagerAndroidBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    DialogManagerAndroidBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "buttonPositive"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "buttonNegative"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "buttonNeutral"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "items"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "cancelable"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String messageToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonPositiveToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonNegativeToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonNeutralToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array itemsToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static bool cancelableToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const DialogManagerAndroidBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.message) {
      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
    }
    if (value.buttonPositive) {
      result.setProperty(rt, "buttonPositive", bridging::toJs(rt, value.buttonPositive.value(), jsInvoker));
    }
    if (value.buttonNegative) {
      result.setProperty(rt, "buttonNegative", bridging::toJs(rt, value.buttonNegative.value(), jsInvoker));
    }
    if (value.buttonNeutral) {
      result.setProperty(rt, "buttonNeutral", bridging::toJs(rt, value.buttonNeutral.value(), jsInvoker));
    }
    if (value.items) {
      result.setProperty(rt, "items", bridging::toJs(rt, value.items.value(), jsInvoker));
    }
    if (value.cancelable) {
      result.setProperty(rt, "cancelable", bridging::toJs(rt, value.cancelable.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - DialogManagerAndroidDialogOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct DialogManagerAndroidDialogOptions {
  P0 title;
  P1 message;
  P2 buttonPositive;
  P3 buttonNegative;
  P4 buttonNeutral;
  P5 items;
  P6 cancelable;
  bool operator==(const DialogManagerAndroidDialogOptions &other) const {
    return title == other.title && message == other.message && buttonPositive == other.buttonPositive && buttonNegative == other.buttonNegative && buttonNeutral == other.buttonNeutral && items == other.items && cancelable == other.cancelable;
  }
};

template <typename T>
struct DialogManagerAndroidDialogOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<decltype(types.buttonPositive)>(rt, value.getProperty(rt, "buttonPositive"), jsInvoker),
      bridging::fromJs<decltype(types.buttonNegative)>(rt, value.getProperty(rt, "buttonNegative"), jsInvoker),
      bridging::fromJs<decltype(types.buttonNeutral)>(rt, value.getProperty(rt, "buttonNeutral"), jsInvoker),
      bridging::fromJs<decltype(types.items)>(rt, value.getProperty(rt, "items"), jsInvoker),
      bridging::fromJs<decltype(types.cancelable)>(rt, value.getProperty(rt, "cancelable"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonPositiveToJs(jsi::Runtime &rt, decltype(types.buttonPositive) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonNegativeToJs(jsi::Runtime &rt, decltype(types.buttonNegative) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonNeutralToJs(jsi::Runtime &rt, decltype(types.buttonNeutral) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array itemsToJs(jsi::Runtime &rt, decltype(types.items) value) {
    return bridging::toJs(rt, value);
  }

  static bool cancelableToJs(jsi::Runtime &rt, decltype(types.cancelable) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.message) {
      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
    }
    if (value.buttonPositive) {
      result.setProperty(rt, "buttonPositive", bridging::toJs(rt, value.buttonPositive.value(), jsInvoker));
    }
    if (value.buttonNegative) {
      result.setProperty(rt, "buttonNegative", bridging::toJs(rt, value.buttonNegative.value(), jsInvoker));
    }
    if (value.buttonNeutral) {
      result.setProperty(rt, "buttonNeutral", bridging::toJs(rt, value.buttonNeutral.value(), jsInvoker));
    }
    if (value.items) {
      result.setProperty(rt, "items", bridging::toJs(rt, value.items.value(), jsInvoker));
    }
    if (value.cancelable) {
      result.setProperty(rt, "cancelable", bridging::toJs(rt, value.cancelable.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeDialogManagerAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeDialogManagerAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) = 0;

};

template <typename T>
class JSI_EXPORT NativeDialogManagerAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "DialogManagerAndroid";

protected:
  NativeDialogManagerAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeDialogManagerAndroidCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDialogManagerAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDialogManagerAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) override {
      static_assert(
          bridging::getParameterCount(&T::showAlert) == 4,
          "Expected showAlert(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showAlert, jsInvoker_, instance_, std::move(config), std::move(onError), std::move(onAction));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - AlertBaseDialogOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct [[deprecated("Use AlertDialogOptions instead.")]] AlertBaseDialogOptions {
  P0 title;
  P1 message;
  P2 buttonPositive;
  P3 buttonNegative;
  P4 buttonNeutral;
  P5 items;
  P6 cancelable;
  P7 defaultButton;
  P8 rootTag;
  bool operator==(const AlertBaseDialogOptions &other) const {
    return title == other.title && message == other.message && buttonPositive == other.buttonPositive && buttonNegative == other.buttonNegative && buttonNeutral == other.buttonNeutral && items == other.items && cancelable == other.cancelable && defaultButton == other.defaultButton && rootTag == other.rootTag;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct [[deprecated("Use AlertDialogOptionsBridging instead.")]] AlertBaseDialogOptionsBridging {
  static AlertBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6, P7, P8> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    AlertBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6, P7, P8> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "buttonPositive"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "buttonNegative"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "buttonNeutral"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "items"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "cancelable"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "defaultButton"), jsInvoker),
      bridging::fromJs<P8>(rt, value.getProperty(rt, "rootTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String messageToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonPositiveToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonNegativeToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonNeutralToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array itemsToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static bool cancelableToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }

  static int defaultButtonToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }

  static int rootTagToJs(jsi::Runtime &rt, P8 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const AlertBaseDialogOptions<P0, P1, P2, P3, P4, P5, P6, P7, P8> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.message) {
      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
    }
    if (value.buttonPositive) {
      result.setProperty(rt, "buttonPositive", bridging::toJs(rt, value.buttonPositive.value(), jsInvoker));
    }
    if (value.buttonNegative) {
      result.setProperty(rt, "buttonNegative", bridging::toJs(rt, value.buttonNegative.value(), jsInvoker));
    }
    if (value.buttonNeutral) {
      result.setProperty(rt, "buttonNeutral", bridging::toJs(rt, value.buttonNeutral.value(), jsInvoker));
    }
    if (value.items) {
      result.setProperty(rt, "items", bridging::toJs(rt, value.items.value(), jsInvoker));
    }
    if (value.cancelable) {
      result.setProperty(rt, "cancelable", bridging::toJs(rt, value.cancelable.value(), jsInvoker));
    }
    if (value.defaultButton) {
      result.setProperty(rt, "defaultButton", bridging::toJs(rt, value.defaultButton.value(), jsInvoker));
    }
    if (value.rootTag) {
      result.setProperty(rt, "rootTag", bridging::toJs(rt, value.rootTag.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - AlertDialogOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct AlertDialogOptions {
  P0 title;
  P1 message;
  P2 buttonPositive;
  P3 buttonNegative;
  P4 buttonNeutral;
  P5 items;
  P6 cancelable;
  P7 defaultButton;
  P8 rootTag;
  bool operator==(const AlertDialogOptions &other) const {
    return title == other.title && message == other.message && buttonPositive == other.buttonPositive && buttonNegative == other.buttonNegative && buttonNeutral == other.buttonNeutral && items == other.items && cancelable == other.cancelable && defaultButton == other.defaultButton && rootTag == other.rootTag;
  }
};

template <typename T>
struct AlertDialogOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<decltype(types.buttonPositive)>(rt, value.getProperty(rt, "buttonPositive"), jsInvoker),
      bridging::fromJs<decltype(types.buttonNegative)>(rt, value.getProperty(rt, "buttonNegative"), jsInvoker),
      bridging::fromJs<decltype(types.buttonNeutral)>(rt, value.getProperty(rt, "buttonNeutral"), jsInvoker),
      bridging::fromJs<decltype(types.items)>(rt, value.getProperty(rt, "items"), jsInvoker),
      bridging::fromJs<decltype(types.cancelable)>(rt, value.getProperty(rt, "cancelable"), jsInvoker),
      bridging::fromJs<decltype(types.defaultButton)>(rt, value.getProperty(rt, "defaultButton"), jsInvoker),
      bridging::fromJs<decltype(types.rootTag)>(rt, value.getProperty(rt, "rootTag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonPositiveToJs(jsi::Runtime &rt, decltype(types.buttonPositive) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonNegativeToJs(jsi::Runtime &rt, decltype(types.buttonNegative) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String buttonNeutralToJs(jsi::Runtime &rt, decltype(types.buttonNeutral) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array itemsToJs(jsi::Runtime &rt, decltype(types.items) value) {
    return bridging::toJs(rt, value);
  }

  static bool cancelableToJs(jsi::Runtime &rt, decltype(types.cancelable) value) {
    return bridging::toJs(rt, value);
  }

  static int defaultButtonToJs(jsi::Runtime &rt, decltype(types.defaultButton) value) {
    return bridging::toJs(rt, value);
  }

  static int rootTagToJs(jsi::Runtime &rt, decltype(types.rootTag) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.title) {
      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
    }
    if (value.message) {
      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
    }
    if (value.buttonPositive) {
      result.setProperty(rt, "buttonPositive", bridging::toJs(rt, value.buttonPositive.value(), jsInvoker));
    }
    if (value.buttonNegative) {
      result.setProperty(rt, "buttonNegative", bridging::toJs(rt, value.buttonNegative.value(), jsInvoker));
    }
    if (value.buttonNeutral) {
      result.setProperty(rt, "buttonNeutral", bridging::toJs(rt, value.buttonNeutral.value(), jsInvoker));
    }
    if (value.items) {
      result.setProperty(rt, "items", bridging::toJs(rt, value.items.value(), jsInvoker));
    }
    if (value.cancelable) {
      result.setProperty(rt, "cancelable", bridging::toJs(rt, value.cancelable.value(), jsInvoker));
    }
    if (value.defaultButton) {
      result.setProperty(rt, "defaultButton", bridging::toJs(rt, value.defaultButton.value(), jsInvoker));
    }
    if (value.rootTag) {
      result.setProperty(rt, "rootTag", bridging::toJs(rt, value.rootTag.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeDialogManagerWindowsCxxSpecJSI : public TurboModule {
protected:
  NativeDialogManagerWindowsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) = 0;

};

template <typename T>
class JSI_EXPORT NativeDialogManagerWindowsCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "Alert";

protected:
  NativeDialogManagerWindowsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeDialogManagerWindowsCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeDialogManagerWindowsCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeDialogManagerWindowsCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) override {
      static_assert(
          bridging::getParameterCount(&T::showAlert) == 4,
          "Expected showAlert(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showAlert, jsInvoker_, instance_, std::move(config), std::move(onError), std::move(onAction));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - ExceptionsManagerBaseStackFrame

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct [[deprecated("Use ExceptionsManagerStackFrame instead.")]] ExceptionsManagerBaseStackFrame {
  P0 column;
  P1 file;
  P2 lineNumber;
  P3 methodName;
  P4 collapse;
  bool operator==(const ExceptionsManagerBaseStackFrame &other) const {
    return column == other.column && file == other.file && lineNumber == other.lineNumber && methodName == other.methodName && collapse == other.collapse;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct [[deprecated("Use ExceptionsManagerStackFrameBridging instead.")]] ExceptionsManagerBaseStackFrameBridging {
  static ExceptionsManagerBaseStackFrame<P0, P1, P2, P3, P4> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    ExceptionsManagerBaseStackFrame<P0, P1, P2, P3, P4> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "column"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "file"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "lineNumber"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "methodName"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "collapse"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<double> columnToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> fileToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> lineNumberToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String methodNameToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static bool collapseToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const ExceptionsManagerBaseStackFrame<P0, P1, P2, P3, P4> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "column", bridging::toJs(rt, value.column, jsInvoker));
    result.setProperty(rt, "file", bridging::toJs(rt, value.file, jsInvoker));
    result.setProperty(rt, "lineNumber", bridging::toJs(rt, value.lineNumber, jsInvoker));
    result.setProperty(rt, "methodName", bridging::toJs(rt, value.methodName, jsInvoker));
    if (value.collapse) {
      result.setProperty(rt, "collapse", bridging::toJs(rt, value.collapse.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - ExceptionsManagerBaseExceptionData

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct [[deprecated("Use ExceptionsManagerExceptionData instead.")]] ExceptionsManagerBaseExceptionData {
  P0 message;
  P1 originalMessage;
  P2 name;
  P3 componentStack;
  P4 stack;
  P5 id;
  P6 isFatal;
  P7 extraData;
  bool operator==(const ExceptionsManagerBaseExceptionData &other) const {
    return message == other.message && originalMessage == other.originalMessage && name == other.name && componentStack == other.componentStack && stack == other.stack && id == other.id && isFatal == other.isFatal && extraData == other.extraData;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct [[deprecated("Use ExceptionsManagerExceptionDataBridging instead.")]] ExceptionsManagerBaseExceptionDataBridging {
  static ExceptionsManagerBaseExceptionData<P0, P1, P2, P3, P4, P5, P6, P7> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    ExceptionsManagerBaseExceptionData<P0, P1, P2, P3, P4, P5, P6, P7> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "originalMessage"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "componentStack"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "stack"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "isFatal"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "extraData"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String messageToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> originalMessageToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> componentStackToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array stackToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static double idToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static bool isFatalToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object extraDataToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const ExceptionsManagerBaseExceptionData<P0, P1, P2, P3, P4, P5, P6, P7> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "message", bridging::toJs(rt, value.message, jsInvoker));
    result.setProperty(rt, "originalMessage", bridging::toJs(rt, value.originalMessage, jsInvoker));
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "componentStack", bridging::toJs(rt, value.componentStack, jsInvoker));
    result.setProperty(rt, "stack", bridging::toJs(rt, value.stack, jsInvoker));
    result.setProperty(rt, "id", bridging::toJs(rt, value.id, jsInvoker));
    result.setProperty(rt, "isFatal", bridging::toJs(rt, value.isFatal, jsInvoker));
    if (value.extraData) {
      result.setProperty(rt, "extraData", bridging::toJs(rt, value.extraData.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - ExceptionsManagerStackFrame

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct ExceptionsManagerStackFrame {
  P0 column;
  P1 file;
  P2 lineNumber;
  P3 methodName;
  P4 collapse;
  bool operator==(const ExceptionsManagerStackFrame &other) const {
    return column == other.column && file == other.file && lineNumber == other.lineNumber && methodName == other.methodName && collapse == other.collapse;
  }
};

template <typename T>
struct ExceptionsManagerStackFrameBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.column)>(rt, value.getProperty(rt, "column"), jsInvoker),
      bridging::fromJs<decltype(types.file)>(rt, value.getProperty(rt, "file"), jsInvoker),
      bridging::fromJs<decltype(types.lineNumber)>(rt, value.getProperty(rt, "lineNumber"), jsInvoker),
      bridging::fromJs<decltype(types.methodName)>(rt, value.getProperty(rt, "methodName"), jsInvoker),
      bridging::fromJs<decltype(types.collapse)>(rt, value.getProperty(rt, "collapse"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<double> columnToJs(jsi::Runtime &rt, decltype(types.column) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> fileToJs(jsi::Runtime &rt, decltype(types.file) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> lineNumberToJs(jsi::Runtime &rt, decltype(types.lineNumber) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String methodNameToJs(jsi::Runtime &rt, decltype(types.methodName) value) {
    return bridging::toJs(rt, value);
  }

  static bool collapseToJs(jsi::Runtime &rt, decltype(types.collapse) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "column", bridging::toJs(rt, value.column, jsInvoker));
    result.setProperty(rt, "file", bridging::toJs(rt, value.file, jsInvoker));
    result.setProperty(rt, "lineNumber", bridging::toJs(rt, value.lineNumber, jsInvoker));
    result.setProperty(rt, "methodName", bridging::toJs(rt, value.methodName, jsInvoker));
    if (value.collapse) {
      result.setProperty(rt, "collapse", bridging::toJs(rt, value.collapse.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - ExceptionsManagerExceptionData

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct ExceptionsManagerExceptionData {
  P0 message;
  P1 originalMessage;
  P2 name;
  P3 componentStack;
  P4 stack;
  P5 id;
  P6 isFatal;
  P7 extraData;
  bool operator==(const ExceptionsManagerExceptionData &other) const {
    return message == other.message && originalMessage == other.originalMessage && name == other.name && componentStack == other.componentStack && stack == other.stack && id == other.id && isFatal == other.isFatal && extraData == other.extraData;
  }
};

template <typename T>
struct ExceptionsManagerExceptionDataBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
      bridging::fromJs<decltype(types.originalMessage)>(rt, value.getProperty(rt, "originalMessage"), jsInvoker),
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<decltype(types.componentStack)>(rt, value.getProperty(rt, "componentStack"), jsInvoker),
      bridging::fromJs<decltype(types.stack)>(rt, value.getProperty(rt, "stack"), jsInvoker),
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.isFatal)>(rt, value.getProperty(rt, "isFatal"), jsInvoker),
      bridging::fromJs<decltype(types.extraData)>(rt, value.getProperty(rt, "extraData"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> originalMessageToJs(jsi::Runtime &rt, decltype(types.originalMessage) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> componentStackToJs(jsi::Runtime &rt, decltype(types.componentStack) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array stackToJs(jsi::Runtime &rt, decltype(types.stack) value) {
    return bridging::toJs(rt, value);
  }

  static double idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static bool isFatalToJs(jsi::Runtime &rt, decltype(types.isFatal) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object extraDataToJs(jsi::Runtime &rt, decltype(types.extraData) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "message", bridging::toJs(rt, value.message, jsInvoker));
    result.setProperty(rt, "originalMessage", bridging::toJs(rt, value.originalMessage, jsInvoker));
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "componentStack", bridging::toJs(rt, value.componentStack, jsInvoker));
    result.setProperty(rt, "stack", bridging::toJs(rt, value.stack, jsInvoker));
    result.setProperty(rt, "id", bridging::toJs(rt, value.id, jsInvoker));
    result.setProperty(rt, "isFatal", bridging::toJs(rt, value.isFatal, jsInvoker));
    if (value.extraData) {
      result.setProperty(rt, "extraData", bridging::toJs(rt, value.extraData.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeExceptionsManagerCxxSpecJSI : public TurboModule {
protected:
  NativeExceptionsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void reportFatalException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) = 0;
  virtual void reportSoftException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) = 0;
  virtual void reportException(jsi::Runtime &rt, jsi::Object data) = 0;
  virtual void updateExceptionMessage(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) = 0;
  virtual void dismissRedbox(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeExceptionsManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ExceptionsManager";

protected:
  NativeExceptionsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeExceptionsManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeExceptionsManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeExceptionsManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void reportFatalException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) override {
      static_assert(
          bridging::getParameterCount(&T::reportFatalException) == 4,
          "Expected reportFatalException(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reportFatalException, jsInvoker_, instance_, std::move(message), std::move(stack), std::move(exceptionId));
    }
    void reportSoftException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) override {
      static_assert(
          bridging::getParameterCount(&T::reportSoftException) == 4,
          "Expected reportSoftException(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reportSoftException, jsInvoker_, instance_, std::move(message), std::move(stack), std::move(exceptionId));
    }
    void reportException(jsi::Runtime &rt, jsi::Object data) override {
      static_assert(
          bridging::getParameterCount(&T::reportException) == 2,
          "Expected reportException(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reportException, jsInvoker_, instance_, std::move(data));
    }
    void updateExceptionMessage(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) override {
      static_assert(
          bridging::getParameterCount(&T::updateExceptionMessage) == 4,
          "Expected updateExceptionMessage(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::updateExceptionMessage, jsInvoker_, instance_, std::move(message), std::move(stack), std::move(exceptionId));
    }
    void dismissRedbox(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::dismissRedbox) == 1,
          "Expected dismissRedbox(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dismissRedbox, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeFileReaderModuleCxxSpecJSI : public TurboModule {
protected:
  NativeFileReaderModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value readAsDataURL(jsi::Runtime &rt, jsi::Object data) = 0;
  virtual jsi::Value readAsText(jsi::Runtime &rt, jsi::Object data, jsi::String encoding) = 0;

};

template <typename T>
class JSI_EXPORT NativeFileReaderModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "FileReaderModule";

protected:
  NativeFileReaderModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeFileReaderModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeFileReaderModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeFileReaderModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value readAsDataURL(jsi::Runtime &rt, jsi::Object data) override {
      static_assert(
          bridging::getParameterCount(&T::readAsDataURL) == 2,
          "Expected readAsDataURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readAsDataURL, jsInvoker_, instance_, std::move(data));
    }
    jsi::Value readAsText(jsi::Runtime &rt, jsi::Object data, jsi::String encoding) override {
      static_assert(
          bridging::getParameterCount(&T::readAsText) == 3,
          "Expected readAsText(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::readAsText, jsInvoker_, instance_, std::move(data), std::move(encoding));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeFrameRateLoggerCxxSpecJSI : public TurboModule {
protected:
  NativeFrameRateLoggerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void setGlobalOptions(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual void setContext(jsi::Runtime &rt, jsi::String context) = 0;
  virtual void beginScroll(jsi::Runtime &rt) = 0;
  virtual void endScroll(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeFrameRateLoggerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "FrameRateLogger";

protected:
  NativeFrameRateLoggerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeFrameRateLoggerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeFrameRateLoggerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeFrameRateLoggerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void setGlobalOptions(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::setGlobalOptions) == 2,
          "Expected setGlobalOptions(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setGlobalOptions, jsInvoker_, instance_, std::move(options));
    }
    void setContext(jsi::Runtime &rt, jsi::String context) override {
      static_assert(
          bridging::getParameterCount(&T::setContext) == 2,
          "Expected setContext(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setContext, jsInvoker_, instance_, std::move(context));
    }
    void beginScroll(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::beginScroll) == 1,
          "Expected beginScroll(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::beginScroll, jsInvoker_, instance_);
    }
    void endScroll(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::endScroll) == 1,
          "Expected endScroll(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::endScroll, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeHeadlessJsTaskSupportCxxSpecJSI : public TurboModule {
protected:
  NativeHeadlessJsTaskSupportCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void notifyTaskFinished(jsi::Runtime &rt, double taskId) = 0;
  virtual jsi::Value notifyTaskRetry(jsi::Runtime &rt, double taskId) = 0;

};

template <typename T>
class JSI_EXPORT NativeHeadlessJsTaskSupportCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "HeadlessJsTaskSupport";

protected:
  NativeHeadlessJsTaskSupportCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeHeadlessJsTaskSupportCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeHeadlessJsTaskSupportCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeHeadlessJsTaskSupportCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void notifyTaskFinished(jsi::Runtime &rt, double taskId) override {
      static_assert(
          bridging::getParameterCount(&T::notifyTaskFinished) == 2,
          "Expected notifyTaskFinished(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::notifyTaskFinished, jsInvoker_, instance_, std::move(taskId));
    }
    jsi::Value notifyTaskRetry(jsi::Runtime &rt, double taskId) override {
      static_assert(
          bridging::getParameterCount(&T::notifyTaskRetry) == 2,
          "Expected notifyTaskRetry(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::notifyTaskRetry, jsInvoker_, instance_, std::move(taskId));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - I18nManagerBaseI18nManagerConstants

template <typename P0, typename P1, typename P2>
struct [[deprecated("Use I18nManagerI18nManagerConstants instead.")]] I18nManagerBaseI18nManagerConstants {
  P0 doLeftAndRightSwapInRTL;
  P1 isRTL;
  P2 localeIdentifier;
  bool operator==(const I18nManagerBaseI18nManagerConstants &other) const {
    return doLeftAndRightSwapInRTL == other.doLeftAndRightSwapInRTL && isRTL == other.isRTL && localeIdentifier == other.localeIdentifier;
  }
};

template <typename P0, typename P1, typename P2>
struct [[deprecated("Use I18nManagerI18nManagerConstantsBridging instead.")]] I18nManagerBaseI18nManagerConstantsBridging {
  static I18nManagerBaseI18nManagerConstants<P0, P1, P2> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    I18nManagerBaseI18nManagerConstants<P0, P1, P2> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "doLeftAndRightSwapInRTL"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "isRTL"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "localeIdentifier"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool doLeftAndRightSwapInRTLToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static bool isRTLToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> localeIdentifierToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const I18nManagerBaseI18nManagerConstants<P0, P1, P2> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "doLeftAndRightSwapInRTL", bridging::toJs(rt, value.doLeftAndRightSwapInRTL, jsInvoker));
    result.setProperty(rt, "isRTL", bridging::toJs(rt, value.isRTL, jsInvoker));
    if (value.localeIdentifier) {
      result.setProperty(rt, "localeIdentifier", bridging::toJs(rt, value.localeIdentifier.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - I18nManagerI18nManagerConstants

template <typename P0, typename P1, typename P2>
struct I18nManagerI18nManagerConstants {
  P0 doLeftAndRightSwapInRTL;
  P1 isRTL;
  P2 localeIdentifier;
  bool operator==(const I18nManagerI18nManagerConstants &other) const {
    return doLeftAndRightSwapInRTL == other.doLeftAndRightSwapInRTL && isRTL == other.isRTL && localeIdentifier == other.localeIdentifier;
  }
};

template <typename T>
struct I18nManagerI18nManagerConstantsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.doLeftAndRightSwapInRTL)>(rt, value.getProperty(rt, "doLeftAndRightSwapInRTL"), jsInvoker),
      bridging::fromJs<decltype(types.isRTL)>(rt, value.getProperty(rt, "isRTL"), jsInvoker),
      bridging::fromJs<decltype(types.localeIdentifier)>(rt, value.getProperty(rt, "localeIdentifier"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool doLeftAndRightSwapInRTLToJs(jsi::Runtime &rt, decltype(types.doLeftAndRightSwapInRTL) value) {
    return bridging::toJs(rt, value);
  }

  static bool isRTLToJs(jsi::Runtime &rt, decltype(types.isRTL) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> localeIdentifierToJs(jsi::Runtime &rt, decltype(types.localeIdentifier) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "doLeftAndRightSwapInRTL", bridging::toJs(rt, value.doLeftAndRightSwapInRTL, jsInvoker));
    result.setProperty(rt, "isRTL", bridging::toJs(rt, value.isRTL, jsInvoker));
    if (value.localeIdentifier) {
      result.setProperty(rt, "localeIdentifier", bridging::toJs(rt, value.localeIdentifier.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeI18nManagerCxxSpecJSI : public TurboModule {
protected:
  NativeI18nManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void allowRTL(jsi::Runtime &rt, bool allowRTL) = 0;
  virtual void forceRTL(jsi::Runtime &rt, bool forceRTL) = 0;
  virtual void swapLeftAndRightInRTL(jsi::Runtime &rt, bool flipStyles) = 0;

};

template <typename T>
class JSI_EXPORT NativeI18nManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "I18nManager";

protected:
  NativeI18nManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeI18nManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeI18nManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeI18nManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void allowRTL(jsi::Runtime &rt, bool allowRTL) override {
      static_assert(
          bridging::getParameterCount(&T::allowRTL) == 2,
          "Expected allowRTL(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::allowRTL, jsInvoker_, instance_, std::move(allowRTL));
    }
    void forceRTL(jsi::Runtime &rt, bool forceRTL) override {
      static_assert(
          bridging::getParameterCount(&T::forceRTL) == 2,
          "Expected forceRTL(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::forceRTL, jsInvoker_, instance_, std::move(forceRTL));
    }
    void swapLeftAndRightInRTL(jsi::Runtime &rt, bool flipStyles) override {
      static_assert(
          bridging::getParameterCount(&T::swapLeftAndRightInRTL) == 2,
          "Expected swapLeftAndRightInRTL(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::swapLeftAndRightInRTL, jsInvoker_, instance_, std::move(flipStyles));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - ImageEditingManagerBaseOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct [[deprecated("Use ImageEditingManagerOptions instead.")]] ImageEditingManagerBaseOptions {
  P0 offset;
  P1 size;
  P2 displaySize;
  P3 resizeMode;
  P4 allowExternalStorage;
  bool operator==(const ImageEditingManagerBaseOptions &other) const {
    return offset == other.offset && size == other.size && displaySize == other.displaySize && resizeMode == other.resizeMode && allowExternalStorage == other.allowExternalStorage;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct [[deprecated("Use ImageEditingManagerOptionsBridging instead.")]] ImageEditingManagerBaseOptionsBridging {
  static ImageEditingManagerBaseOptions<P0, P1, P2, P3, P4> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    ImageEditingManagerBaseOptions<P0, P1, P2, P3, P4> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "offset"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "displaySize"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "resizeMode"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "allowExternalStorage"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object offsetToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object sizeToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> displaySizeToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> resizeModeToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static bool allowExternalStorageToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const ImageEditingManagerBaseOptions<P0, P1, P2, P3, P4> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "offset", bridging::toJs(rt, value.offset, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    if (value.displaySize) {
      result.setProperty(rt, "displaySize", bridging::toJs(rt, value.displaySize.value(), jsInvoker));
    }
    if (value.resizeMode) {
      result.setProperty(rt, "resizeMode", bridging::toJs(rt, value.resizeMode.value(), jsInvoker));
    }
    if (value.allowExternalStorage) {
      result.setProperty(rt, "allowExternalStorage", bridging::toJs(rt, value.allowExternalStorage.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - ImageEditingManagerOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct ImageEditingManagerOptions {
  P0 offset;
  P1 size;
  P2 displaySize;
  P3 resizeMode;
  P4 allowExternalStorage;
  bool operator==(const ImageEditingManagerOptions &other) const {
    return offset == other.offset && size == other.size && displaySize == other.displaySize && resizeMode == other.resizeMode && allowExternalStorage == other.allowExternalStorage;
  }
};

template <typename T>
struct ImageEditingManagerOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.offset)>(rt, value.getProperty(rt, "offset"), jsInvoker),
      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<decltype(types.displaySize)>(rt, value.getProperty(rt, "displaySize"), jsInvoker),
      bridging::fromJs<decltype(types.resizeMode)>(rt, value.getProperty(rt, "resizeMode"), jsInvoker),
      bridging::fromJs<decltype(types.allowExternalStorage)>(rt, value.getProperty(rt, "allowExternalStorage"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object offsetToJs(jsi::Runtime &rt, decltype(types.offset) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> displaySizeToJs(jsi::Runtime &rt, decltype(types.displaySize) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> resizeModeToJs(jsi::Runtime &rt, decltype(types.resizeMode) value) {
    return bridging::toJs(rt, value);
  }

  static bool allowExternalStorageToJs(jsi::Runtime &rt, decltype(types.allowExternalStorage) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "offset", bridging::toJs(rt, value.offset, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    if (value.displaySize) {
      result.setProperty(rt, "displaySize", bridging::toJs(rt, value.displaySize.value(), jsInvoker));
    }
    if (value.resizeMode) {
      result.setProperty(rt, "resizeMode", bridging::toJs(rt, value.resizeMode.value(), jsInvoker));
    }
    if (value.allowExternalStorage) {
      result.setProperty(rt, "allowExternalStorage", bridging::toJs(rt, value.allowExternalStorage.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeImageEditorCxxSpecJSI : public TurboModule {
protected:
  NativeImageEditorCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void cropImage(jsi::Runtime &rt, jsi::String uri, jsi::Object cropData, jsi::Function successCallback, jsi::Function errorCallback) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageEditorCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ImageEditingManager";

protected:
  NativeImageEditorCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeImageEditorCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageEditorCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageEditorCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void cropImage(jsi::Runtime &rt, jsi::String uri, jsi::Object cropData, jsi::Function successCallback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::cropImage) == 5,
          "Expected cropImage(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::cropImage, jsInvoker_, instance_, std::move(uri), std::move(cropData), std::move(successCallback), std::move(errorCallback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - ImageLoaderBaseImageSize

template <typename P0, typename P1>
struct [[deprecated("Use ImageLoaderImageSize instead.")]] ImageLoaderBaseImageSize {
  P0 width;
  P1 height;
  bool operator==(const ImageLoaderBaseImageSize &other) const {
    return width == other.width && height == other.height;
  }
};

template <typename P0, typename P1>
struct [[deprecated("Use ImageLoaderImageSizeBridging instead.")]] ImageLoaderBaseImageSizeBridging {
  static ImageLoaderBaseImageSize<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    ImageLoaderBaseImageSize<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "height"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const ImageLoaderBaseImageSize<P0, P1> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    return result;
  }
};


#pragma mark - ImageLoaderImageSize

template <typename P0, typename P1>
struct ImageLoaderImageSize {
  P0 width;
  P1 height;
  bool operator==(const ImageLoaderImageSize &other) const {
    return width == other.width && height == other.height;
  }
};

template <typename T>
struct ImageLoaderImageSizeBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeImageLoaderAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeImageLoaderAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void abortRequest(jsi::Runtime &rt, double requestId) = 0;
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) = 0;
  virtual jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) = 0;
  virtual jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri, double requestId) = 0;
  virtual jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageLoaderAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ImageLoader";

protected:
  NativeImageLoaderAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeImageLoaderAndroidCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageLoaderAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageLoaderAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void abortRequest(jsi::Runtime &rt, double requestId) override {
      static_assert(
          bridging::getParameterCount(&T::abortRequest) == 2,
          "Expected abortRequest(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::abortRequest, jsInvoker_, instance_, std::move(requestId));
    }
    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) override {
      static_assert(
          bridging::getParameterCount(&T::getSize) == 2,
          "Expected getSize(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getSize, jsInvoker_, instance_, std::move(uri));
    }
    jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) override {
      static_assert(
          bridging::getParameterCount(&T::getSizeWithHeaders) == 3,
          "Expected getSizeWithHeaders(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getSizeWithHeaders, jsInvoker_, instance_, std::move(uri), std::move(headers));
    }
    jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri, double requestId) override {
      static_assert(
          bridging::getParameterCount(&T::prefetchImage) == 3,
          "Expected prefetchImage(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::prefetchImage, jsInvoker_, instance_, std::move(uri), std::move(requestId));
    }
    jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) override {
      static_assert(
          bridging::getParameterCount(&T::queryCache) == 2,
          "Expected queryCache(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::queryCache, jsInvoker_, instance_, std::move(uris));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeImageLoaderIOSCxxSpecJSI : public TurboModule {
protected:
  NativeImageLoaderIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) = 0;
  virtual jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) = 0;
  virtual jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri) = 0;
  virtual jsi::Value prefetchImageWithMetadata(jsi::Runtime &rt, jsi::String uri, jsi::String queryRootName, double rootTag) = 0;
  virtual jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageLoaderIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ImageLoader";

protected:
  NativeImageLoaderIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeImageLoaderIOSCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageLoaderIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageLoaderIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) override {
      static_assert(
          bridging::getParameterCount(&T::getSize) == 2,
          "Expected getSize(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getSize, jsInvoker_, instance_, std::move(uri));
    }
    jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) override {
      static_assert(
          bridging::getParameterCount(&T::getSizeWithHeaders) == 3,
          "Expected getSizeWithHeaders(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getSizeWithHeaders, jsInvoker_, instance_, std::move(uri), std::move(headers));
    }
    jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri) override {
      static_assert(
          bridging::getParameterCount(&T::prefetchImage) == 2,
          "Expected prefetchImage(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::prefetchImage, jsInvoker_, instance_, std::move(uri));
    }
    jsi::Value prefetchImageWithMetadata(jsi::Runtime &rt, jsi::String uri, jsi::String queryRootName, double rootTag) override {
      static_assert(
          bridging::getParameterCount(&T::prefetchImageWithMetadata) == 4,
          "Expected prefetchImageWithMetadata(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::prefetchImageWithMetadata, jsInvoker_, instance_, std::move(uri), std::move(queryRootName), std::move(rootTag));
    }
    jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) override {
      static_assert(
          bridging::getParameterCount(&T::queryCache) == 2,
          "Expected queryCache(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::queryCache, jsInvoker_, instance_, std::move(uris));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeImageStoreAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeImageStoreAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageStoreAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ImageStoreManager";

protected:
  NativeImageStoreAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeImageStoreAndroidCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageStoreAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageStoreAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::getBase64ForTag) == 4,
          "Expected getBase64ForTag(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getBase64ForTag, jsInvoker_, instance_, std::move(uri), std::move(successCallback), std::move(errorCallback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeImageStoreIOSCxxSpecJSI : public TurboModule {
protected:
  NativeImageStoreIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) = 0;
  virtual void hasImageForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function callback) = 0;
  virtual void removeImageForTag(jsi::Runtime &rt, jsi::String uri) = 0;
  virtual void addImageFromBase64(jsi::Runtime &rt, jsi::String base64ImageData, jsi::Function successCallback, jsi::Function errorCallback) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageStoreIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ImageStoreManager";

protected:
  NativeImageStoreIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeImageStoreIOSCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageStoreIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageStoreIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::getBase64ForTag) == 4,
          "Expected getBase64ForTag(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getBase64ForTag, jsInvoker_, instance_, std::move(uri), std::move(successCallback), std::move(errorCallback));
    }
    void hasImageForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::hasImageForTag) == 3,
          "Expected hasImageForTag(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::hasImageForTag, jsInvoker_, instance_, std::move(uri), std::move(callback));
    }
    void removeImageForTag(jsi::Runtime &rt, jsi::String uri) override {
      static_assert(
          bridging::getParameterCount(&T::removeImageForTag) == 2,
          "Expected removeImageForTag(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeImageForTag, jsInvoker_, instance_, std::move(uri));
    }
    void addImageFromBase64(jsi::Runtime &rt, jsi::String base64ImageData, jsi::Function successCallback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::addImageFromBase64) == 4,
          "Expected addImageFromBase64(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addImageFromBase64, jsInvoker_, instance_, std::move(base64ImageData), std::move(successCallback), std::move(errorCallback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeIntentAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeIntentAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getInitialURL(jsi::Runtime &rt) = 0;
  virtual jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) = 0;
  virtual jsi::Value openURL(jsi::Runtime &rt, jsi::String url) = 0;
  virtual jsi::Value openSettings(jsi::Runtime &rt) = 0;
  virtual jsi::Value sendIntent(jsi::Runtime &rt, jsi::String action, std::optional<jsi::Array> extras) = 0;

};

template <typename T>
class JSI_EXPORT NativeIntentAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "IntentAndroid";

protected:
  NativeIntentAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeIntentAndroidCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeIntentAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeIntentAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value getInitialURL(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getInitialURL) == 1,
          "Expected getInitialURL(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getInitialURL, jsInvoker_, instance_);
    }
    jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) override {
      static_assert(
          bridging::getParameterCount(&T::canOpenURL) == 2,
          "Expected canOpenURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::canOpenURL, jsInvoker_, instance_, std::move(url));
    }
    jsi::Value openURL(jsi::Runtime &rt, jsi::String url) override {
      static_assert(
          bridging::getParameterCount(&T::openURL) == 2,
          "Expected openURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openURL, jsInvoker_, instance_, std::move(url));
    }
    jsi::Value openSettings(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::openSettings) == 1,
          "Expected openSettings(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openSettings, jsInvoker_, instance_);
    }
    jsi::Value sendIntent(jsi::Runtime &rt, jsi::String action, std::optional<jsi::Array> extras) override {
      static_assert(
          bridging::getParameterCount(&T::sendIntent) == 3,
          "Expected sendIntent(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::sendIntent, jsInvoker_, instance_, std::move(action), std::move(extras));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeIntersectionObserverCxxBaseNativeIntersectionObserverObserveOptions

template <typename P0, typename P1, typename P2>
struct [[deprecated("Use NativeIntersectionObserverCxxNativeIntersectionObserverObserveOptions instead.")]] NativeIntersectionObserverCxxBaseNativeIntersectionObserverObserveOptions {
  P0 intersectionObserverId;
  P1 targetShadowNode;
  P2 thresholds;
  bool operator==(const NativeIntersectionObserverCxxBaseNativeIntersectionObserverObserveOptions &other) const {
    return intersectionObserverId == other.intersectionObserverId && targetShadowNode == other.targetShadowNode && thresholds == other.thresholds;
  }
};

template <typename P0, typename P1, typename P2>
struct [[deprecated("Use NativeIntersectionObserverCxxNativeIntersectionObserverObserveOptionsBridging instead.")]] NativeIntersectionObserverCxxBaseNativeIntersectionObserverObserveOptionsBridging {
  static NativeIntersectionObserverCxxBaseNativeIntersectionObserverObserveOptions<P0, P1, P2> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeIntersectionObserverCxxBaseNativeIntersectionObserverObserveOptions<P0, P1, P2> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "intersectionObserverId"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "targetShadowNode"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "thresholds"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double intersectionObserverIdToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value targetShadowNodeToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array thresholdsToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativeIntersectionObserverCxxBaseNativeIntersectionObserverObserveOptions<P0, P1, P2> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "intersectionObserverId", bridging::toJs(rt, value.intersectionObserverId, jsInvoker));
    result.setProperty(rt, "targetShadowNode", bridging::toJs(rt, value.targetShadowNode, jsInvoker));
    result.setProperty(rt, "thresholds", bridging::toJs(rt, value.thresholds, jsInvoker));
    return result;
  }
};



#pragma mark - NativeIntersectionObserverCxxBaseNativeIntersectionObserverEntry

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct [[deprecated("Use NativeIntersectionObserverCxxNativeIntersectionObserverEntry instead.")]] NativeIntersectionObserverCxxBaseNativeIntersectionObserverEntry {
  P0 intersectionObserverId;
  P1 targetInstanceHandle;
  P2 targetRect;
  P3 rootRect;
  P4 intersectionRect;
  P5 isIntersectingAboveThresholds;
  P6 time;
  bool operator==(const NativeIntersectionObserverCxxBaseNativeIntersectionObserverEntry &other) const {
    return intersectionObserverId == other.intersectionObserverId && targetInstanceHandle == other.targetInstanceHandle && targetRect == other.targetRect && rootRect == other.rootRect && intersectionRect == other.intersectionRect && isIntersectingAboveThresholds == other.isIntersectingAboveThresholds && time == other.time;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct [[deprecated("Use NativeIntersectionObserverCxxNativeIntersectionObserverEntryBridging instead.")]] NativeIntersectionObserverCxxBaseNativeIntersectionObserverEntryBridging {
  static NativeIntersectionObserverCxxBaseNativeIntersectionObserverEntry<P0, P1, P2, P3, P4, P5, P6> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeIntersectionObserverCxxBaseNativeIntersectionObserverEntry<P0, P1, P2, P3, P4, P5, P6> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "intersectionObserverId"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "targetInstanceHandle"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "targetRect"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "rootRect"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "intersectionRect"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "isIntersectingAboveThresholds"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "time"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double intersectionObserverIdToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value targetInstanceHandleToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array targetRectToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array rootRectToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Array> intersectionRectToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static bool isIntersectingAboveThresholdsToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static double timeToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativeIntersectionObserverCxxBaseNativeIntersectionObserverEntry<P0, P1, P2, P3, P4, P5, P6> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "intersectionObserverId", bridging::toJs(rt, value.intersectionObserverId, jsInvoker));
    result.setProperty(rt, "targetInstanceHandle", bridging::toJs(rt, value.targetInstanceHandle, jsInvoker));
    result.setProperty(rt, "targetRect", bridging::toJs(rt, value.targetRect, jsInvoker));
    result.setProperty(rt, "rootRect", bridging::toJs(rt, value.rootRect, jsInvoker));
    result.setProperty(rt, "intersectionRect", bridging::toJs(rt, value.intersectionRect, jsInvoker));
    result.setProperty(rt, "isIntersectingAboveThresholds", bridging::toJs(rt, value.isIntersectingAboveThresholds, jsInvoker));
    result.setProperty(rt, "time", bridging::toJs(rt, value.time, jsInvoker));
    return result;
  }
};


#pragma mark - NativeIntersectionObserverCxxNativeIntersectionObserverObserveOptions

template <typename P0, typename P1, typename P2>
struct NativeIntersectionObserverCxxNativeIntersectionObserverObserveOptions {
  P0 intersectionObserverId;
  P1 targetShadowNode;
  P2 thresholds;
  bool operator==(const NativeIntersectionObserverCxxNativeIntersectionObserverObserveOptions &other) const {
    return intersectionObserverId == other.intersectionObserverId && targetShadowNode == other.targetShadowNode && thresholds == other.thresholds;
  }
};

template <typename T>
struct NativeIntersectionObserverCxxNativeIntersectionObserverObserveOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.intersectionObserverId)>(rt, value.getProperty(rt, "intersectionObserverId"), jsInvoker),
      bridging::fromJs<decltype(types.targetShadowNode)>(rt, value.getProperty(rt, "targetShadowNode"), jsInvoker),
      bridging::fromJs<decltype(types.thresholds)>(rt, value.getProperty(rt, "thresholds"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double intersectionObserverIdToJs(jsi::Runtime &rt, decltype(types.intersectionObserverId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value targetShadowNodeToJs(jsi::Runtime &rt, decltype(types.targetShadowNode) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array thresholdsToJs(jsi::Runtime &rt, decltype(types.thresholds) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "intersectionObserverId", bridging::toJs(rt, value.intersectionObserverId, jsInvoker));
    result.setProperty(rt, "targetShadowNode", bridging::toJs(rt, value.targetShadowNode, jsInvoker));
    result.setProperty(rt, "thresholds", bridging::toJs(rt, value.thresholds, jsInvoker));
    return result;
  }
};



#pragma mark - NativeIntersectionObserverCxxNativeIntersectionObserverEntry

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct NativeIntersectionObserverCxxNativeIntersectionObserverEntry {
  P0 intersectionObserverId;
  P1 targetInstanceHandle;
  P2 targetRect;
  P3 rootRect;
  P4 intersectionRect;
  P5 isIntersectingAboveThresholds;
  P6 time;
  bool operator==(const NativeIntersectionObserverCxxNativeIntersectionObserverEntry &other) const {
    return intersectionObserverId == other.intersectionObserverId && targetInstanceHandle == other.targetInstanceHandle && targetRect == other.targetRect && rootRect == other.rootRect && intersectionRect == other.intersectionRect && isIntersectingAboveThresholds == other.isIntersectingAboveThresholds && time == other.time;
  }
};

template <typename T>
struct NativeIntersectionObserverCxxNativeIntersectionObserverEntryBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.intersectionObserverId)>(rt, value.getProperty(rt, "intersectionObserverId"), jsInvoker),
      bridging::fromJs<decltype(types.targetInstanceHandle)>(rt, value.getProperty(rt, "targetInstanceHandle"), jsInvoker),
      bridging::fromJs<decltype(types.targetRect)>(rt, value.getProperty(rt, "targetRect"), jsInvoker),
      bridging::fromJs<decltype(types.rootRect)>(rt, value.getProperty(rt, "rootRect"), jsInvoker),
      bridging::fromJs<decltype(types.intersectionRect)>(rt, value.getProperty(rt, "intersectionRect"), jsInvoker),
      bridging::fromJs<decltype(types.isIntersectingAboveThresholds)>(rt, value.getProperty(rt, "isIntersectingAboveThresholds"), jsInvoker),
      bridging::fromJs<decltype(types.time)>(rt, value.getProperty(rt, "time"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double intersectionObserverIdToJs(jsi::Runtime &rt, decltype(types.intersectionObserverId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value targetInstanceHandleToJs(jsi::Runtime &rt, decltype(types.targetInstanceHandle) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array targetRectToJs(jsi::Runtime &rt, decltype(types.targetRect) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array rootRectToJs(jsi::Runtime &rt, decltype(types.rootRect) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Array> intersectionRectToJs(jsi::Runtime &rt, decltype(types.intersectionRect) value) {
    return bridging::toJs(rt, value);
  }

  static bool isIntersectingAboveThresholdsToJs(jsi::Runtime &rt, decltype(types.isIntersectingAboveThresholds) value) {
    return bridging::toJs(rt, value);
  }

  static double timeToJs(jsi::Runtime &rt, decltype(types.time) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "intersectionObserverId", bridging::toJs(rt, value.intersectionObserverId, jsInvoker));
    result.setProperty(rt, "targetInstanceHandle", bridging::toJs(rt, value.targetInstanceHandle, jsInvoker));
    result.setProperty(rt, "targetRect", bridging::toJs(rt, value.targetRect, jsInvoker));
    result.setProperty(rt, "rootRect", bridging::toJs(rt, value.rootRect, jsInvoker));
    result.setProperty(rt, "intersectionRect", bridging::toJs(rt, value.intersectionRect, jsInvoker));
    result.setProperty(rt, "isIntersectingAboveThresholds", bridging::toJs(rt, value.isIntersectingAboveThresholds, jsInvoker));
    result.setProperty(rt, "time", bridging::toJs(rt, value.time, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeIntersectionObserverCxxSpecJSI : public TurboModule {
protected:
  NativeIntersectionObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void observe(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual void unobserve(jsi::Runtime &rt, double intersectionObserverId, jsi::Value targetShadowNode) = 0;
  virtual void connect(jsi::Runtime &rt, jsi::Function notifyIntersectionObserversCallback) = 0;
  virtual void disconnect(jsi::Runtime &rt) = 0;
  virtual jsi::Array takeRecords(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeIntersectionObserverCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "NativeIntersectionObserverCxx";

protected:
  NativeIntersectionObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeIntersectionObserverCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeIntersectionObserverCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeIntersectionObserverCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void observe(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::observe) == 2,
          "Expected observe(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::observe, jsInvoker_, instance_, std::move(options));
    }
    void unobserve(jsi::Runtime &rt, double intersectionObserverId, jsi::Value targetShadowNode) override {
      static_assert(
          bridging::getParameterCount(&T::unobserve) == 3,
          "Expected unobserve(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::unobserve, jsInvoker_, instance_, std::move(intersectionObserverId), std::move(targetShadowNode));
    }
    void connect(jsi::Runtime &rt, jsi::Function notifyIntersectionObserversCallback) override {
      static_assert(
          bridging::getParameterCount(&T::connect) == 2,
          "Expected connect(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connect, jsInvoker_, instance_, std::move(notifyIntersectionObserversCallback));
    }
    void disconnect(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::disconnect) == 1,
          "Expected disconnect(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnect, jsInvoker_, instance_);
    }
    jsi::Array takeRecords(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::takeRecords) == 1,
          "Expected takeRecords(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::takeRecords, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeJSCHeapCaptureCxxSpecJSI : public TurboModule {
protected:
  NativeJSCHeapCaptureCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void captureComplete(jsi::Runtime &rt, jsi::String path, std::optional<jsi::String> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeJSCHeapCaptureCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "JSCHeapCapture";

protected:
  NativeJSCHeapCaptureCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeJSCHeapCaptureCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeJSCHeapCaptureCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeJSCHeapCaptureCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void captureComplete(jsi::Runtime &rt, jsi::String path, std::optional<jsi::String> error) override {
      static_assert(
          bridging::getParameterCount(&T::captureComplete) == 3,
          "Expected captureComplete(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::captureComplete, jsInvoker_, instance_, std::move(path), std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeJSCSamplingProfilerCxxSpecJSI : public TurboModule {
protected:
  NativeJSCSamplingProfilerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void operationComplete(jsi::Runtime &rt, double token, std::optional<jsi::String> result, std::optional<jsi::String> error) = 0;

};

template <typename T>
class JSI_EXPORT NativeJSCSamplingProfilerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "JSCSamplingProfiler";

protected:
  NativeJSCSamplingProfilerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeJSCSamplingProfilerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeJSCSamplingProfilerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeJSCSamplingProfilerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void operationComplete(jsi::Runtime &rt, double token, std::optional<jsi::String> result, std::optional<jsi::String> error) override {
      static_assert(
          bridging::getParameterCount(&T::operationComplete) == 4,
          "Expected operationComplete(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::operationComplete, jsInvoker_, instance_, std::move(token), std::move(result), std::move(error));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeKeyboardObserverCxxSpecJSI : public TurboModule {
protected:
  NativeKeyboardObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeKeyboardObserverCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "KeyboardObserver";

protected:
  NativeKeyboardObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeKeyboardObserverCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeKeyboardObserverCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeKeyboardObserverCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeLinkingManagerCxxSpecJSI : public TurboModule {
protected:
  NativeLinkingManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getInitialURL(jsi::Runtime &rt) = 0;
  virtual jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) = 0;
  virtual jsi::Value openURL(jsi::Runtime &rt, jsi::String url) = 0;
  virtual jsi::Value openSettings(jsi::Runtime &rt) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeLinkingManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "LinkingManager";

protected:
  NativeLinkingManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeLinkingManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeLinkingManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeLinkingManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value getInitialURL(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getInitialURL) == 1,
          "Expected getInitialURL(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getInitialURL, jsInvoker_, instance_);
    }
    jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) override {
      static_assert(
          bridging::getParameterCount(&T::canOpenURL) == 2,
          "Expected canOpenURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::canOpenURL, jsInvoker_, instance_, std::move(url));
    }
    jsi::Value openURL(jsi::Runtime &rt, jsi::String url) override {
      static_assert(
          bridging::getParameterCount(&T::openURL) == 2,
          "Expected openURL(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openURL, jsInvoker_, instance_, std::move(url));
    }
    jsi::Value openSettings(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::openSettings) == 1,
          "Expected openSettings(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openSettings, jsInvoker_, instance_);
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeLogBoxCxxSpecJSI : public TurboModule {
protected:
  NativeLogBoxCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void show(jsi::Runtime &rt) = 0;
  virtual void hide(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeLogBoxCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "LogBox";

protected:
  NativeLogBoxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeLogBoxCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeLogBoxCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeLogBoxCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void show(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::show) == 1,
          "Expected show(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::show, jsInvoker_, instance_);
    }
    void hide(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::hide) == 1,
          "Expected hide(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::hide, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeModalManagerCxxSpecJSI : public TurboModule {
protected:
  NativeModalManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeModalManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ModalManager";

protected:
  NativeModalManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeModalManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeModalManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeModalManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeMutationObserverCxxBaseNativeMutationObserverObserveOptions

template <typename P0, typename P1, typename P2>
struct [[deprecated("Use NativeMutationObserverCxxNativeMutationObserverObserveOptions instead.")]] NativeMutationObserverCxxBaseNativeMutationObserverObserveOptions {
  P0 mutationObserverId;
  P1 targetShadowNode;
  P2 subtree;
  bool operator==(const NativeMutationObserverCxxBaseNativeMutationObserverObserveOptions &other) const {
    return mutationObserverId == other.mutationObserverId && targetShadowNode == other.targetShadowNode && subtree == other.subtree;
  }
};

template <typename P0, typename P1, typename P2>
struct [[deprecated("Use NativeMutationObserverCxxNativeMutationObserverObserveOptionsBridging instead.")]] NativeMutationObserverCxxBaseNativeMutationObserverObserveOptionsBridging {
  static NativeMutationObserverCxxBaseNativeMutationObserverObserveOptions<P0, P1, P2> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeMutationObserverCxxBaseNativeMutationObserverObserveOptions<P0, P1, P2> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "mutationObserverId"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "targetShadowNode"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "subtree"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double mutationObserverIdToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value targetShadowNodeToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static bool subtreeToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativeMutationObserverCxxBaseNativeMutationObserverObserveOptions<P0, P1, P2> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "mutationObserverId", bridging::toJs(rt, value.mutationObserverId, jsInvoker));
    result.setProperty(rt, "targetShadowNode", bridging::toJs(rt, value.targetShadowNode, jsInvoker));
    result.setProperty(rt, "subtree", bridging::toJs(rt, value.subtree, jsInvoker));
    return result;
  }
};



#pragma mark - NativeMutationObserverCxxBaseNativeMutationRecord

template <typename P0, typename P1, typename P2, typename P3>
struct [[deprecated("Use NativeMutationObserverCxxNativeMutationRecord instead.")]] NativeMutationObserverCxxBaseNativeMutationRecord {
  P0 mutationObserverId;
  P1 target;
  P2 addedNodes;
  P3 removedNodes;
  bool operator==(const NativeMutationObserverCxxBaseNativeMutationRecord &other) const {
    return mutationObserverId == other.mutationObserverId && target == other.target && addedNodes == other.addedNodes && removedNodes == other.removedNodes;
  }
};

template <typename P0, typename P1, typename P2, typename P3>
struct [[deprecated("Use NativeMutationObserverCxxNativeMutationRecordBridging instead.")]] NativeMutationObserverCxxBaseNativeMutationRecordBridging {
  static NativeMutationObserverCxxBaseNativeMutationRecord<P0, P1, P2, P3> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativeMutationObserverCxxBaseNativeMutationRecord<P0, P1, P2, P3> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "mutationObserverId"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "target"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "addedNodes"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "removedNodes"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double mutationObserverIdToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value targetToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array addedNodesToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array removedNodesToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativeMutationObserverCxxBaseNativeMutationRecord<P0, P1, P2, P3> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "mutationObserverId", bridging::toJs(rt, value.mutationObserverId, jsInvoker));
    result.setProperty(rt, "target", bridging::toJs(rt, value.target, jsInvoker));
    result.setProperty(rt, "addedNodes", bridging::toJs(rt, value.addedNodes, jsInvoker));
    result.setProperty(rt, "removedNodes", bridging::toJs(rt, value.removedNodes, jsInvoker));
    return result;
  }
};


#pragma mark - NativeMutationObserverCxxNativeMutationObserverObserveOptions

template <typename P0, typename P1, typename P2>
struct NativeMutationObserverCxxNativeMutationObserverObserveOptions {
  P0 mutationObserverId;
  P1 targetShadowNode;
  P2 subtree;
  bool operator==(const NativeMutationObserverCxxNativeMutationObserverObserveOptions &other) const {
    return mutationObserverId == other.mutationObserverId && targetShadowNode == other.targetShadowNode && subtree == other.subtree;
  }
};

template <typename T>
struct NativeMutationObserverCxxNativeMutationObserverObserveOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.mutationObserverId)>(rt, value.getProperty(rt, "mutationObserverId"), jsInvoker),
      bridging::fromJs<decltype(types.targetShadowNode)>(rt, value.getProperty(rt, "targetShadowNode"), jsInvoker),
      bridging::fromJs<decltype(types.subtree)>(rt, value.getProperty(rt, "subtree"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double mutationObserverIdToJs(jsi::Runtime &rt, decltype(types.mutationObserverId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value targetShadowNodeToJs(jsi::Runtime &rt, decltype(types.targetShadowNode) value) {
    return bridging::toJs(rt, value);
  }

  static bool subtreeToJs(jsi::Runtime &rt, decltype(types.subtree) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "mutationObserverId", bridging::toJs(rt, value.mutationObserverId, jsInvoker));
    result.setProperty(rt, "targetShadowNode", bridging::toJs(rt, value.targetShadowNode, jsInvoker));
    result.setProperty(rt, "subtree", bridging::toJs(rt, value.subtree, jsInvoker));
    return result;
  }
};



#pragma mark - NativeMutationObserverCxxNativeMutationRecord

template <typename P0, typename P1, typename P2, typename P3>
struct NativeMutationObserverCxxNativeMutationRecord {
  P0 mutationObserverId;
  P1 target;
  P2 addedNodes;
  P3 removedNodes;
  bool operator==(const NativeMutationObserverCxxNativeMutationRecord &other) const {
    return mutationObserverId == other.mutationObserverId && target == other.target && addedNodes == other.addedNodes && removedNodes == other.removedNodes;
  }
};

template <typename T>
struct NativeMutationObserverCxxNativeMutationRecordBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.mutationObserverId)>(rt, value.getProperty(rt, "mutationObserverId"), jsInvoker),
      bridging::fromJs<decltype(types.target)>(rt, value.getProperty(rt, "target"), jsInvoker),
      bridging::fromJs<decltype(types.addedNodes)>(rt, value.getProperty(rt, "addedNodes"), jsInvoker),
      bridging::fromJs<decltype(types.removedNodes)>(rt, value.getProperty(rt, "removedNodes"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double mutationObserverIdToJs(jsi::Runtime &rt, decltype(types.mutationObserverId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Value targetToJs(jsi::Runtime &rt, decltype(types.target) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array addedNodesToJs(jsi::Runtime &rt, decltype(types.addedNodes) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array removedNodesToJs(jsi::Runtime &rt, decltype(types.removedNodes) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "mutationObserverId", bridging::toJs(rt, value.mutationObserverId, jsInvoker));
    result.setProperty(rt, "target", bridging::toJs(rt, value.target, jsInvoker));
    result.setProperty(rt, "addedNodes", bridging::toJs(rt, value.addedNodes, jsInvoker));
    result.setProperty(rt, "removedNodes", bridging::toJs(rt, value.removedNodes, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeMutationObserverCxxSpecJSI : public TurboModule {
protected:
  NativeMutationObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void observe(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual void unobserve(jsi::Runtime &rt, double mutationObserverId, jsi::Value targetShadowNode) = 0;
  virtual void connect(jsi::Runtime &rt, jsi::Function notifyMutationObservers, jsi::Function getPublicInstanceFromInstanceHandle) = 0;
  virtual void disconnect(jsi::Runtime &rt) = 0;
  virtual jsi::Array takeRecords(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeMutationObserverCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "NativeMutationObserverCxx";

protected:
  NativeMutationObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeMutationObserverCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeMutationObserverCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeMutationObserverCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void observe(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::observe) == 2,
          "Expected observe(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::observe, jsInvoker_, instance_, std::move(options));
    }
    void unobserve(jsi::Runtime &rt, double mutationObserverId, jsi::Value targetShadowNode) override {
      static_assert(
          bridging::getParameterCount(&T::unobserve) == 3,
          "Expected unobserve(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::unobserve, jsInvoker_, instance_, std::move(mutationObserverId), std::move(targetShadowNode));
    }
    void connect(jsi::Runtime &rt, jsi::Function notifyMutationObservers, jsi::Function getPublicInstanceFromInstanceHandle) override {
      static_assert(
          bridging::getParameterCount(&T::connect) == 3,
          "Expected connect(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connect, jsInvoker_, instance_, std::move(notifyMutationObservers), std::move(getPublicInstanceFromInstanceHandle));
    }
    void disconnect(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::disconnect) == 1,
          "Expected disconnect(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::disconnect, jsInvoker_, instance_);
    }
    jsi::Array takeRecords(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::takeRecords) == 1,
          "Expected takeRecords(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::takeRecords, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeNetworkingAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeNetworkingAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void sendRequest(jsi::Runtime &rt, jsi::String method, jsi::String url, double requestId, jsi::Array headers, jsi::Object data, jsi::String responseType, bool useIncrementalUpdates, double timeout, bool withCredentials) = 0;
  virtual void abortRequest(jsi::Runtime &rt, double requestId) = 0;
  virtual void clearCookies(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeNetworkingAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "Networking";

protected:
  NativeNetworkingAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeNetworkingAndroidCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeNetworkingAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNetworkingAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void sendRequest(jsi::Runtime &rt, jsi::String method, jsi::String url, double requestId, jsi::Array headers, jsi::Object data, jsi::String responseType, bool useIncrementalUpdates, double timeout, bool withCredentials) override {
      static_assert(
          bridging::getParameterCount(&T::sendRequest) == 10,
          "Expected sendRequest(...) to have 10 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendRequest, jsInvoker_, instance_, std::move(method), std::move(url), std::move(requestId), std::move(headers), std::move(data), std::move(responseType), std::move(useIncrementalUpdates), std::move(timeout), std::move(withCredentials));
    }
    void abortRequest(jsi::Runtime &rt, double requestId) override {
      static_assert(
          bridging::getParameterCount(&T::abortRequest) == 2,
          "Expected abortRequest(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::abortRequest, jsInvoker_, instance_, std::move(requestId));
    }
    void clearCookies(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::clearCookies) == 2,
          "Expected clearCookies(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::clearCookies, jsInvoker_, instance_, std::move(callback));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeNetworkingIOSCxxSpecJSI : public TurboModule {
protected:
  NativeNetworkingIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void sendRequest(jsi::Runtime &rt, jsi::Object query, jsi::Function callback) = 0;
  virtual void abortRequest(jsi::Runtime &rt, double requestId) = 0;
  virtual void clearCookies(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeNetworkingIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "Networking";

protected:
  NativeNetworkingIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeNetworkingIOSCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeNetworkingIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeNetworkingIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void sendRequest(jsi::Runtime &rt, jsi::Object query, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::sendRequest) == 3,
          "Expected sendRequest(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendRequest, jsInvoker_, instance_, std::move(query), std::move(callback));
    }
    void abortRequest(jsi::Runtime &rt, double requestId) override {
      static_assert(
          bridging::getParameterCount(&T::abortRequest) == 2,
          "Expected abortRequest(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::abortRequest, jsInvoker_, instance_, std::move(requestId));
    }
    void clearCookies(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::clearCookies) == 2,
          "Expected clearCookies(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::clearCookies, jsInvoker_, instance_, std::move(callback));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePermissionsAndroidCxxSpecJSI : public TurboModule {
protected:
  NativePermissionsAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value checkPermission(jsi::Runtime &rt, jsi::String permission) = 0;
  virtual jsi::Value requestPermission(jsi::Runtime &rt, jsi::String permission) = 0;
  virtual jsi::Value shouldShowRequestPermissionRationale(jsi::Runtime &rt, jsi::String permission) = 0;
  virtual jsi::Value requestMultiplePermissions(jsi::Runtime &rt, jsi::Array permissions) = 0;

};

template <typename T>
class JSI_EXPORT NativePermissionsAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "PermissionsAndroid";

protected:
  NativePermissionsAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePermissionsAndroidCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePermissionsAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePermissionsAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value checkPermission(jsi::Runtime &rt, jsi::String permission) override {
      static_assert(
          bridging::getParameterCount(&T::checkPermission) == 2,
          "Expected checkPermission(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::checkPermission, jsInvoker_, instance_, std::move(permission));
    }
    jsi::Value requestPermission(jsi::Runtime &rt, jsi::String permission) override {
      static_assert(
          bridging::getParameterCount(&T::requestPermission) == 2,
          "Expected requestPermission(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::requestPermission, jsInvoker_, instance_, std::move(permission));
    }
    jsi::Value shouldShowRequestPermissionRationale(jsi::Runtime &rt, jsi::String permission) override {
      static_assert(
          bridging::getParameterCount(&T::shouldShowRequestPermissionRationale) == 2,
          "Expected shouldShowRequestPermissionRationale(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::shouldShowRequestPermissionRationale, jsInvoker_, instance_, std::move(permission));
    }
    jsi::Value requestMultiplePermissions(jsi::Runtime &rt, jsi::Array permissions) override {
      static_assert(
          bridging::getParameterCount(&T::requestMultiplePermissions) == 2,
          "Expected requestMultiplePermissions(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::requestMultiplePermissions, jsInvoker_, instance_, std::move(permissions));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - PlatformConstantsBaseReactNativeVersionAndroid

template <typename P0, typename P1, typename P2, typename P3>
struct [[deprecated("Use PlatformConstantsReactNativeVersionAndroid instead.")]] PlatformConstantsBaseReactNativeVersionAndroid {
  P0 major;
  P1 minor;
  P2 patch;
  P3 prerelease;
  bool operator==(const PlatformConstantsBaseReactNativeVersionAndroid &other) const {
    return major == other.major && minor == other.minor && patch == other.patch && prerelease == other.prerelease;
  }
};

template <typename P0, typename P1, typename P2, typename P3>
struct [[deprecated("Use PlatformConstantsReactNativeVersionAndroidBridging instead.")]] PlatformConstantsBaseReactNativeVersionAndroidBridging {
  static PlatformConstantsBaseReactNativeVersionAndroid<P0, P1, P2, P3> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    PlatformConstantsBaseReactNativeVersionAndroid<P0, P1, P2, P3> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "major"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "minor"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "patch"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "prerelease"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double majorToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static double minorToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static double patchToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> prereleaseToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const PlatformConstantsBaseReactNativeVersionAndroid<P0, P1, P2, P3> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "major", bridging::toJs(rt, value.major, jsInvoker));
    result.setProperty(rt, "minor", bridging::toJs(rt, value.minor, jsInvoker));
    result.setProperty(rt, "patch", bridging::toJs(rt, value.patch, jsInvoker));
    result.setProperty(rt, "prerelease", bridging::toJs(rt, value.prerelease, jsInvoker));
    return result;
  }
};



#pragma mark - PlatformConstantsBasePlatformConstantsAndroid

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11>
struct [[deprecated("Use PlatformConstantsPlatformConstantsAndroid instead.")]] PlatformConstantsBasePlatformConstantsAndroid {
  P0 isTesting;
  P1 isDisableAnimations;
  P2 reactNativeVersion;
  P3 Version;
  P4 Release;
  P5 Serial;
  P6 Fingerprint;
  P7 Model;
  P8 ServerHost;
  P9 uiMode;
  P10 Brand;
  P11 Manufacturer;
  bool operator==(const PlatformConstantsBasePlatformConstantsAndroid &other) const {
    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && Version == other.Version && Release == other.Release && Serial == other.Serial && Fingerprint == other.Fingerprint && Model == other.Model && ServerHost == other.ServerHost && uiMode == other.uiMode && Brand == other.Brand && Manufacturer == other.Manufacturer;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11>
struct [[deprecated("Use PlatformConstantsPlatformConstantsAndroidBridging instead.")]] PlatformConstantsBasePlatformConstantsAndroidBridging {
  static PlatformConstantsBasePlatformConstantsAndroid<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    PlatformConstantsBasePlatformConstantsAndroid<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "Version"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "Release"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "Serial"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "Fingerprint"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "Model"), jsInvoker),
      bridging::fromJs<P8>(rt, value.getProperty(rt, "ServerHost"), jsInvoker),
      bridging::fromJs<P9>(rt, value.getProperty(rt, "uiMode"), jsInvoker),
      bridging::fromJs<P10>(rt, value.getProperty(rt, "Brand"), jsInvoker),
      bridging::fromJs<P11>(rt, value.getProperty(rt, "Manufacturer"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isTestingToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static bool isDisableAnimationsToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static double VersionToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ReleaseToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String SerialToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String FingerprintToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ModelToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ServerHostToJs(jsi::Runtime &rt, P8 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String uiModeToJs(jsi::Runtime &rt, P9 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String BrandToJs(jsi::Runtime &rt, P10 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ManufacturerToJs(jsi::Runtime &rt, P11 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const PlatformConstantsBasePlatformConstantsAndroid<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
    if (value.isDisableAnimations) {
      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
    }
    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
    result.setProperty(rt, "Version", bridging::toJs(rt, value.Version, jsInvoker));
    result.setProperty(rt, "Release", bridging::toJs(rt, value.Release, jsInvoker));
    result.setProperty(rt, "Serial", bridging::toJs(rt, value.Serial, jsInvoker));
    result.setProperty(rt, "Fingerprint", bridging::toJs(rt, value.Fingerprint, jsInvoker));
    result.setProperty(rt, "Model", bridging::toJs(rt, value.Model, jsInvoker));
    if (value.ServerHost) {
      result.setProperty(rt, "ServerHost", bridging::toJs(rt, value.ServerHost.value(), jsInvoker));
    }
    result.setProperty(rt, "uiMode", bridging::toJs(rt, value.uiMode, jsInvoker));
    result.setProperty(rt, "Brand", bridging::toJs(rt, value.Brand, jsInvoker));
    result.setProperty(rt, "Manufacturer", bridging::toJs(rt, value.Manufacturer, jsInvoker));
    return result;
  }
};


#pragma mark - PlatformConstantsReactNativeVersionAndroid

template <typename P0, typename P1, typename P2, typename P3>
struct PlatformConstantsReactNativeVersionAndroid {
  P0 major;
  P1 minor;
  P2 patch;
  P3 prerelease;
  bool operator==(const PlatformConstantsReactNativeVersionAndroid &other) const {
    return major == other.major && minor == other.minor && patch == other.patch && prerelease == other.prerelease;
  }
};

template <typename T>
struct PlatformConstantsReactNativeVersionAndroidBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.major)>(rt, value.getProperty(rt, "major"), jsInvoker),
      bridging::fromJs<decltype(types.minor)>(rt, value.getProperty(rt, "minor"), jsInvoker),
      bridging::fromJs<decltype(types.patch)>(rt, value.getProperty(rt, "patch"), jsInvoker),
      bridging::fromJs<decltype(types.prerelease)>(rt, value.getProperty(rt, "prerelease"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double majorToJs(jsi::Runtime &rt, decltype(types.major) value) {
    return bridging::toJs(rt, value);
  }

  static double minorToJs(jsi::Runtime &rt, decltype(types.minor) value) {
    return bridging::toJs(rt, value);
  }

  static double patchToJs(jsi::Runtime &rt, decltype(types.patch) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> prereleaseToJs(jsi::Runtime &rt, decltype(types.prerelease) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "major", bridging::toJs(rt, value.major, jsInvoker));
    result.setProperty(rt, "minor", bridging::toJs(rt, value.minor, jsInvoker));
    result.setProperty(rt, "patch", bridging::toJs(rt, value.patch, jsInvoker));
    result.setProperty(rt, "prerelease", bridging::toJs(rt, value.prerelease, jsInvoker));
    return result;
  }
};



#pragma mark - PlatformConstantsPlatformConstantsAndroid

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11>
struct PlatformConstantsPlatformConstantsAndroid {
  P0 isTesting;
  P1 isDisableAnimations;
  P2 reactNativeVersion;
  P3 Version;
  P4 Release;
  P5 Serial;
  P6 Fingerprint;
  P7 Model;
  P8 ServerHost;
  P9 uiMode;
  P10 Brand;
  P11 Manufacturer;
  bool operator==(const PlatformConstantsPlatformConstantsAndroid &other) const {
    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && Version == other.Version && Release == other.Release && Serial == other.Serial && Fingerprint == other.Fingerprint && Model == other.Model && ServerHost == other.ServerHost && uiMode == other.uiMode && Brand == other.Brand && Manufacturer == other.Manufacturer;
  }
};

template <typename T>
struct PlatformConstantsPlatformConstantsAndroidBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.isTesting)>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
      bridging::fromJs<decltype(types.isDisableAnimations)>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
      bridging::fromJs<decltype(types.reactNativeVersion)>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
      bridging::fromJs<decltype(types.Version)>(rt, value.getProperty(rt, "Version"), jsInvoker),
      bridging::fromJs<decltype(types.Release)>(rt, value.getProperty(rt, "Release"), jsInvoker),
      bridging::fromJs<decltype(types.Serial)>(rt, value.getProperty(rt, "Serial"), jsInvoker),
      bridging::fromJs<decltype(types.Fingerprint)>(rt, value.getProperty(rt, "Fingerprint"), jsInvoker),
      bridging::fromJs<decltype(types.Model)>(rt, value.getProperty(rt, "Model"), jsInvoker),
      bridging::fromJs<decltype(types.ServerHost)>(rt, value.getProperty(rt, "ServerHost"), jsInvoker),
      bridging::fromJs<decltype(types.uiMode)>(rt, value.getProperty(rt, "uiMode"), jsInvoker),
      bridging::fromJs<decltype(types.Brand)>(rt, value.getProperty(rt, "Brand"), jsInvoker),
      bridging::fromJs<decltype(types.Manufacturer)>(rt, value.getProperty(rt, "Manufacturer"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isTestingToJs(jsi::Runtime &rt, decltype(types.isTesting) value) {
    return bridging::toJs(rt, value);
  }

  static bool isDisableAnimationsToJs(jsi::Runtime &rt, decltype(types.isDisableAnimations) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, decltype(types.reactNativeVersion) value) {
    return bridging::toJs(rt, value);
  }

  static double VersionToJs(jsi::Runtime &rt, decltype(types.Version) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ReleaseToJs(jsi::Runtime &rt, decltype(types.Release) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String SerialToJs(jsi::Runtime &rt, decltype(types.Serial) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String FingerprintToJs(jsi::Runtime &rt, decltype(types.Fingerprint) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ModelToJs(jsi::Runtime &rt, decltype(types.Model) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ServerHostToJs(jsi::Runtime &rt, decltype(types.ServerHost) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String uiModeToJs(jsi::Runtime &rt, decltype(types.uiMode) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String BrandToJs(jsi::Runtime &rt, decltype(types.Brand) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String ManufacturerToJs(jsi::Runtime &rt, decltype(types.Manufacturer) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
    if (value.isDisableAnimations) {
      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
    }
    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
    result.setProperty(rt, "Version", bridging::toJs(rt, value.Version, jsInvoker));
    result.setProperty(rt, "Release", bridging::toJs(rt, value.Release, jsInvoker));
    result.setProperty(rt, "Serial", bridging::toJs(rt, value.Serial, jsInvoker));
    result.setProperty(rt, "Fingerprint", bridging::toJs(rt, value.Fingerprint, jsInvoker));
    result.setProperty(rt, "Model", bridging::toJs(rt, value.Model, jsInvoker));
    if (value.ServerHost) {
      result.setProperty(rt, "ServerHost", bridging::toJs(rt, value.ServerHost.value(), jsInvoker));
    }
    result.setProperty(rt, "uiMode", bridging::toJs(rt, value.uiMode, jsInvoker));
    result.setProperty(rt, "Brand", bridging::toJs(rt, value.Brand, jsInvoker));
    result.setProperty(rt, "Manufacturer", bridging::toJs(rt, value.Manufacturer, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativePlatformConstantsAndroidCxxSpecJSI : public TurboModule {
protected:
  NativePlatformConstantsAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::String getAndroidID(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativePlatformConstantsAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "PlatformConstants";

protected:
  NativePlatformConstantsAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePlatformConstantsAndroidCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePlatformConstantsAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePlatformConstantsAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::String getAndroidID(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getAndroidID) == 1,
          "Expected getAndroidID(...) to have 1 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getAndroidID, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - PlatformConstantsBasePlatformConstantsIOS

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct [[deprecated("Use PlatformConstantsPlatformConstantsIOS instead.")]] PlatformConstantsBasePlatformConstantsIOS {
  P0 isTesting;
  P1 isDisableAnimations;
  P2 reactNativeVersion;
  P3 forceTouchAvailable;
  P4 osVersion;
  P5 systemName;
  P6 interfaceIdiom;
  P7 isMacCatalyst;
  bool operator==(const PlatformConstantsBasePlatformConstantsIOS &other) const {
    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && forceTouchAvailable == other.forceTouchAvailable && osVersion == other.osVersion && systemName == other.systemName && interfaceIdiom == other.interfaceIdiom && isMacCatalyst == other.isMacCatalyst;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct [[deprecated("Use PlatformConstantsPlatformConstantsIOSBridging instead.")]] PlatformConstantsBasePlatformConstantsIOSBridging {
  static PlatformConstantsBasePlatformConstantsIOS<P0, P1, P2, P3, P4, P5, P6, P7> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    PlatformConstantsBasePlatformConstantsIOS<P0, P1, P2, P3, P4, P5, P6, P7> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "forceTouchAvailable"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "osVersion"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "systemName"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "interfaceIdiom"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "isMacCatalyst"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isTestingToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static bool isDisableAnimationsToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static bool forceTouchAvailableToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String osVersionToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String systemNameToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String interfaceIdiomToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }

  static bool isMacCatalystToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const PlatformConstantsBasePlatformConstantsIOS<P0, P1, P2, P3, P4, P5, P6, P7> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
    if (value.isDisableAnimations) {
      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
    }
    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
    result.setProperty(rt, "forceTouchAvailable", bridging::toJs(rt, value.forceTouchAvailable, jsInvoker));
    result.setProperty(rt, "osVersion", bridging::toJs(rt, value.osVersion, jsInvoker));
    result.setProperty(rt, "systemName", bridging::toJs(rt, value.systemName, jsInvoker));
    result.setProperty(rt, "interfaceIdiom", bridging::toJs(rt, value.interfaceIdiom, jsInvoker));
    if (value.isMacCatalyst) {
      result.setProperty(rt, "isMacCatalyst", bridging::toJs(rt, value.isMacCatalyst.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - PlatformConstantsPlatformConstantsIOS

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct PlatformConstantsPlatformConstantsIOS {
  P0 isTesting;
  P1 isDisableAnimations;
  P2 reactNativeVersion;
  P3 forceTouchAvailable;
  P4 osVersion;
  P5 systemName;
  P6 interfaceIdiom;
  P7 isMacCatalyst;
  bool operator==(const PlatformConstantsPlatformConstantsIOS &other) const {
    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && forceTouchAvailable == other.forceTouchAvailable && osVersion == other.osVersion && systemName == other.systemName && interfaceIdiom == other.interfaceIdiom && isMacCatalyst == other.isMacCatalyst;
  }
};

template <typename T>
struct PlatformConstantsPlatformConstantsIOSBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.isTesting)>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
      bridging::fromJs<decltype(types.isDisableAnimations)>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
      bridging::fromJs<decltype(types.reactNativeVersion)>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
      bridging::fromJs<decltype(types.forceTouchAvailable)>(rt, value.getProperty(rt, "forceTouchAvailable"), jsInvoker),
      bridging::fromJs<decltype(types.osVersion)>(rt, value.getProperty(rt, "osVersion"), jsInvoker),
      bridging::fromJs<decltype(types.systemName)>(rt, value.getProperty(rt, "systemName"), jsInvoker),
      bridging::fromJs<decltype(types.interfaceIdiom)>(rt, value.getProperty(rt, "interfaceIdiom"), jsInvoker),
      bridging::fromJs<decltype(types.isMacCatalyst)>(rt, value.getProperty(rt, "isMacCatalyst"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isTestingToJs(jsi::Runtime &rt, decltype(types.isTesting) value) {
    return bridging::toJs(rt, value);
  }

  static bool isDisableAnimationsToJs(jsi::Runtime &rt, decltype(types.isDisableAnimations) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, decltype(types.reactNativeVersion) value) {
    return bridging::toJs(rt, value);
  }

  static bool forceTouchAvailableToJs(jsi::Runtime &rt, decltype(types.forceTouchAvailable) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String osVersionToJs(jsi::Runtime &rt, decltype(types.osVersion) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String systemNameToJs(jsi::Runtime &rt, decltype(types.systemName) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String interfaceIdiomToJs(jsi::Runtime &rt, decltype(types.interfaceIdiom) value) {
    return bridging::toJs(rt, value);
  }

  static bool isMacCatalystToJs(jsi::Runtime &rt, decltype(types.isMacCatalyst) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
    if (value.isDisableAnimations) {
      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
    }
    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
    result.setProperty(rt, "forceTouchAvailable", bridging::toJs(rt, value.forceTouchAvailable, jsInvoker));
    result.setProperty(rt, "osVersion", bridging::toJs(rt, value.osVersion, jsInvoker));
    result.setProperty(rt, "systemName", bridging::toJs(rt, value.systemName, jsInvoker));
    result.setProperty(rt, "interfaceIdiom", bridging::toJs(rt, value.interfaceIdiom, jsInvoker));
    if (value.isMacCatalyst) {
      result.setProperty(rt, "isMacCatalyst", bridging::toJs(rt, value.isMacCatalyst.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativePlatformConstantsIOSCxxSpecJSI : public TurboModule {
protected:
  NativePlatformConstantsIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativePlatformConstantsIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "PlatformConstants";

protected:
  NativePlatformConstantsIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePlatformConstantsIOSCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePlatformConstantsIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePlatformConstantsIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - PlatformConstantsBasePlatformConstantsWindows

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct [[deprecated("Use PlatformConstantsPlatformConstantsWindows instead.")]] PlatformConstantsBasePlatformConstantsWindows {
  P0 isTesting;
  P1 isDisableAnimations;
  P2 reactNativeVersion;
  P3 reactNativeWindowsVersion;
  P4 osVersion;
  bool operator==(const PlatformConstantsBasePlatformConstantsWindows &other) const {
    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && reactNativeWindowsVersion == other.reactNativeWindowsVersion && osVersion == other.osVersion;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct [[deprecated("Use PlatformConstantsPlatformConstantsWindowsBridging instead.")]] PlatformConstantsBasePlatformConstantsWindowsBridging {
  static PlatformConstantsBasePlatformConstantsWindows<P0, P1, P2, P3, P4> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    PlatformConstantsBasePlatformConstantsWindows<P0, P1, P2, P3, P4> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "reactNativeWindowsVersion"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "osVersion"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isTestingToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static bool isDisableAnimationsToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object reactNativeWindowsVersionToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static double osVersionToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const PlatformConstantsBasePlatformConstantsWindows<P0, P1, P2, P3, P4> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
    if (value.isDisableAnimations) {
      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
    }
    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
    result.setProperty(rt, "reactNativeWindowsVersion", bridging::toJs(rt, value.reactNativeWindowsVersion, jsInvoker));
    result.setProperty(rt, "osVersion", bridging::toJs(rt, value.osVersion, jsInvoker));
    return result;
  }
};


#pragma mark - PlatformConstantsPlatformConstantsWindows

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct PlatformConstantsPlatformConstantsWindows {
  P0 isTesting;
  P1 isDisableAnimations;
  P2 reactNativeVersion;
  P3 reactNativeWindowsVersion;
  P4 osVersion;
  bool operator==(const PlatformConstantsPlatformConstantsWindows &other) const {
    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && reactNativeWindowsVersion == other.reactNativeWindowsVersion && osVersion == other.osVersion;
  }
};

template <typename T>
struct PlatformConstantsPlatformConstantsWindowsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.isTesting)>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
      bridging::fromJs<decltype(types.isDisableAnimations)>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
      bridging::fromJs<decltype(types.reactNativeVersion)>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
      bridging::fromJs<decltype(types.reactNativeWindowsVersion)>(rt, value.getProperty(rt, "reactNativeWindowsVersion"), jsInvoker),
      bridging::fromJs<decltype(types.osVersion)>(rt, value.getProperty(rt, "osVersion"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool isTestingToJs(jsi::Runtime &rt, decltype(types.isTesting) value) {
    return bridging::toJs(rt, value);
  }

  static bool isDisableAnimationsToJs(jsi::Runtime &rt, decltype(types.isDisableAnimations) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, decltype(types.reactNativeVersion) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object reactNativeWindowsVersionToJs(jsi::Runtime &rt, decltype(types.reactNativeWindowsVersion) value) {
    return bridging::toJs(rt, value);
  }

  static double osVersionToJs(jsi::Runtime &rt, decltype(types.osVersion) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
    if (value.isDisableAnimations) {
      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
    }
    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
    result.setProperty(rt, "reactNativeWindowsVersion", bridging::toJs(rt, value.reactNativeWindowsVersion, jsInvoker));
    result.setProperty(rt, "osVersion", bridging::toJs(rt, value.osVersion, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativePlatformConstantsWinCxxSpecJSI : public TurboModule {
protected:
  NativePlatformConstantsWinCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativePlatformConstantsWinCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "PlatformConstants";

protected:
  NativePlatformConstantsWinCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePlatformConstantsWinCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePlatformConstantsWinCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePlatformConstantsWinCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - PushNotificationManagerBasePermissions

template <typename P0, typename P1, typename P2>
struct [[deprecated("Use PushNotificationManagerPermissions instead.")]] PushNotificationManagerBasePermissions {
  P0 alert;
  P1 badge;
  P2 sound;
  bool operator==(const PushNotificationManagerBasePermissions &other) const {
    return alert == other.alert && badge == other.badge && sound == other.sound;
  }
};

template <typename P0, typename P1, typename P2>
struct [[deprecated("Use PushNotificationManagerPermissionsBridging instead.")]] PushNotificationManagerBasePermissionsBridging {
  static PushNotificationManagerBasePermissions<P0, P1, P2> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    PushNotificationManagerBasePermissions<P0, P1, P2> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "alert"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "badge"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "sound"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool alertToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static bool badgeToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static bool soundToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const PushNotificationManagerBasePermissions<P0, P1, P2> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "alert", bridging::toJs(rt, value.alert, jsInvoker));
    result.setProperty(rt, "badge", bridging::toJs(rt, value.badge, jsInvoker));
    result.setProperty(rt, "sound", bridging::toJs(rt, value.sound, jsInvoker));
    return result;
  }
};



#pragma mark - PushNotificationManagerBaseNotification

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10>
struct [[deprecated("Use PushNotificationManagerNotification instead.")]] PushNotificationManagerBaseNotification {
  P0 alertTitle;
  P1 alertBody;
  P2 userInfo;
  P3 category;
  P4 fireDate;
  P5 fireIntervalSeconds;
  P6 applicationIconBadgeNumber;
  P7 isSilent;
  P8 soundName;
  P9 alertAction;
  P10 repeatInterval;
  bool operator==(const PushNotificationManagerBaseNotification &other) const {
    return alertTitle == other.alertTitle && alertBody == other.alertBody && userInfo == other.userInfo && category == other.category && fireDate == other.fireDate && fireIntervalSeconds == other.fireIntervalSeconds && applicationIconBadgeNumber == other.applicationIconBadgeNumber && isSilent == other.isSilent && soundName == other.soundName && alertAction == other.alertAction && repeatInterval == other.repeatInterval;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10>
struct [[deprecated("Use PushNotificationManagerNotificationBridging instead.")]] PushNotificationManagerBaseNotificationBridging {
  static PushNotificationManagerBaseNotification<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    PushNotificationManagerBaseNotification<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "alertTitle"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "alertBody"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "userInfo"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "category"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "fireDate"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "fireIntervalSeconds"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "applicationIconBadgeNumber"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "isSilent"), jsInvoker),
      bridging::fromJs<P8>(rt, value.getProperty(rt, "soundName"), jsInvoker),
      bridging::fromJs<P9>(rt, value.getProperty(rt, "alertAction"), jsInvoker),
      bridging::fromJs<P10>(rt, value.getProperty(rt, "repeatInterval"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> alertTitleToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> alertBodyToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> userInfoToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> categoryToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> fireDateToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> fireIntervalSecondsToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> applicationIconBadgeNumberToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> isSilentToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> soundNameToJs(jsi::Runtime &rt, P8 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> alertActionToJs(jsi::Runtime &rt, P9 value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> repeatIntervalToJs(jsi::Runtime &rt, P10 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const PushNotificationManagerBaseNotification<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.alertTitle) {
      result.setProperty(rt, "alertTitle", bridging::toJs(rt, value.alertTitle.value(), jsInvoker));
    }
    if (value.alertBody) {
      result.setProperty(rt, "alertBody", bridging::toJs(rt, value.alertBody.value(), jsInvoker));
    }
    if (value.userInfo) {
      result.setProperty(rt, "userInfo", bridging::toJs(rt, value.userInfo.value(), jsInvoker));
    }
    if (value.category) {
      result.setProperty(rt, "category", bridging::toJs(rt, value.category.value(), jsInvoker));
    }
    if (value.fireDate) {
      result.setProperty(rt, "fireDate", bridging::toJs(rt, value.fireDate.value(), jsInvoker));
    }
    if (value.fireIntervalSeconds) {
      result.setProperty(rt, "fireIntervalSeconds", bridging::toJs(rt, value.fireIntervalSeconds.value(), jsInvoker));
    }
    if (value.applicationIconBadgeNumber) {
      result.setProperty(rt, "applicationIconBadgeNumber", bridging::toJs(rt, value.applicationIconBadgeNumber.value(), jsInvoker));
    }
    if (value.isSilent) {
      result.setProperty(rt, "isSilent", bridging::toJs(rt, value.isSilent.value(), jsInvoker));
    }
    if (value.soundName) {
      result.setProperty(rt, "soundName", bridging::toJs(rt, value.soundName.value(), jsInvoker));
    }
    if (value.alertAction) {
      result.setProperty(rt, "alertAction", bridging::toJs(rt, value.alertAction.value(), jsInvoker));
    }
    if (value.repeatInterval) {
      result.setProperty(rt, "repeatInterval", bridging::toJs(rt, value.repeatInterval.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - PushNotificationManagerPermissions

template <typename P0, typename P1, typename P2>
struct PushNotificationManagerPermissions {
  P0 alert;
  P1 badge;
  P2 sound;
  bool operator==(const PushNotificationManagerPermissions &other) const {
    return alert == other.alert && badge == other.badge && sound == other.sound;
  }
};

template <typename T>
struct PushNotificationManagerPermissionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.alert)>(rt, value.getProperty(rt, "alert"), jsInvoker),
      bridging::fromJs<decltype(types.badge)>(rt, value.getProperty(rt, "badge"), jsInvoker),
      bridging::fromJs<decltype(types.sound)>(rt, value.getProperty(rt, "sound"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool alertToJs(jsi::Runtime &rt, decltype(types.alert) value) {
    return bridging::toJs(rt, value);
  }

  static bool badgeToJs(jsi::Runtime &rt, decltype(types.badge) value) {
    return bridging::toJs(rt, value);
  }

  static bool soundToJs(jsi::Runtime &rt, decltype(types.sound) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "alert", bridging::toJs(rt, value.alert, jsInvoker));
    result.setProperty(rt, "badge", bridging::toJs(rt, value.badge, jsInvoker));
    result.setProperty(rt, "sound", bridging::toJs(rt, value.sound, jsInvoker));
    return result;
  }
};



#pragma mark - PushNotificationManagerNotification

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10>
struct PushNotificationManagerNotification {
  P0 alertTitle;
  P1 alertBody;
  P2 userInfo;
  P3 category;
  P4 fireDate;
  P5 fireIntervalSeconds;
  P6 applicationIconBadgeNumber;
  P7 isSilent;
  P8 soundName;
  P9 alertAction;
  P10 repeatInterval;
  bool operator==(const PushNotificationManagerNotification &other) const {
    return alertTitle == other.alertTitle && alertBody == other.alertBody && userInfo == other.userInfo && category == other.category && fireDate == other.fireDate && fireIntervalSeconds == other.fireIntervalSeconds && applicationIconBadgeNumber == other.applicationIconBadgeNumber && isSilent == other.isSilent && soundName == other.soundName && alertAction == other.alertAction && repeatInterval == other.repeatInterval;
  }
};

template <typename T>
struct PushNotificationManagerNotificationBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.alertTitle)>(rt, value.getProperty(rt, "alertTitle"), jsInvoker),
      bridging::fromJs<decltype(types.alertBody)>(rt, value.getProperty(rt, "alertBody"), jsInvoker),
      bridging::fromJs<decltype(types.userInfo)>(rt, value.getProperty(rt, "userInfo"), jsInvoker),
      bridging::fromJs<decltype(types.category)>(rt, value.getProperty(rt, "category"), jsInvoker),
      bridging::fromJs<decltype(types.fireDate)>(rt, value.getProperty(rt, "fireDate"), jsInvoker),
      bridging::fromJs<decltype(types.fireIntervalSeconds)>(rt, value.getProperty(rt, "fireIntervalSeconds"), jsInvoker),
      bridging::fromJs<decltype(types.applicationIconBadgeNumber)>(rt, value.getProperty(rt, "applicationIconBadgeNumber"), jsInvoker),
      bridging::fromJs<decltype(types.isSilent)>(rt, value.getProperty(rt, "isSilent"), jsInvoker),
      bridging::fromJs<decltype(types.soundName)>(rt, value.getProperty(rt, "soundName"), jsInvoker),
      bridging::fromJs<decltype(types.alertAction)>(rt, value.getProperty(rt, "alertAction"), jsInvoker),
      bridging::fromJs<decltype(types.repeatInterval)>(rt, value.getProperty(rt, "repeatInterval"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::String> alertTitleToJs(jsi::Runtime &rt, decltype(types.alertTitle) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> alertBodyToJs(jsi::Runtime &rt, decltype(types.alertBody) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> userInfoToJs(jsi::Runtime &rt, decltype(types.userInfo) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> categoryToJs(jsi::Runtime &rt, decltype(types.category) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> fireDateToJs(jsi::Runtime &rt, decltype(types.fireDate) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> fireIntervalSecondsToJs(jsi::Runtime &rt, decltype(types.fireIntervalSeconds) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> applicationIconBadgeNumberToJs(jsi::Runtime &rt, decltype(types.applicationIconBadgeNumber) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> isSilentToJs(jsi::Runtime &rt, decltype(types.isSilent) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> soundNameToJs(jsi::Runtime &rt, decltype(types.soundName) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> alertActionToJs(jsi::Runtime &rt, decltype(types.alertAction) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> repeatIntervalToJs(jsi::Runtime &rt, decltype(types.repeatInterval) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.alertTitle) {
      result.setProperty(rt, "alertTitle", bridging::toJs(rt, value.alertTitle.value(), jsInvoker));
    }
    if (value.alertBody) {
      result.setProperty(rt, "alertBody", bridging::toJs(rt, value.alertBody.value(), jsInvoker));
    }
    if (value.userInfo) {
      result.setProperty(rt, "userInfo", bridging::toJs(rt, value.userInfo.value(), jsInvoker));
    }
    if (value.category) {
      result.setProperty(rt, "category", bridging::toJs(rt, value.category.value(), jsInvoker));
    }
    if (value.fireDate) {
      result.setProperty(rt, "fireDate", bridging::toJs(rt, value.fireDate.value(), jsInvoker));
    }
    if (value.fireIntervalSeconds) {
      result.setProperty(rt, "fireIntervalSeconds", bridging::toJs(rt, value.fireIntervalSeconds.value(), jsInvoker));
    }
    if (value.applicationIconBadgeNumber) {
      result.setProperty(rt, "applicationIconBadgeNumber", bridging::toJs(rt, value.applicationIconBadgeNumber.value(), jsInvoker));
    }
    if (value.isSilent) {
      result.setProperty(rt, "isSilent", bridging::toJs(rt, value.isSilent.value(), jsInvoker));
    }
    if (value.soundName) {
      result.setProperty(rt, "soundName", bridging::toJs(rt, value.soundName.value(), jsInvoker));
    }
    if (value.alertAction) {
      result.setProperty(rt, "alertAction", bridging::toJs(rt, value.alertAction.value(), jsInvoker));
    }
    if (value.repeatInterval) {
      result.setProperty(rt, "repeatInterval", bridging::toJs(rt, value.repeatInterval.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativePushNotificationManagerIOSCxxSpecJSI : public TurboModule {
protected:
  NativePushNotificationManagerIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void onFinishRemoteNotification(jsi::Runtime &rt, jsi::String notificationId, jsi::String fetchResult) = 0;
  virtual void setApplicationIconBadgeNumber(jsi::Runtime &rt, double num) = 0;
  virtual void getApplicationIconBadgeNumber(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value requestPermissions(jsi::Runtime &rt, jsi::Object permission) = 0;
  virtual void abandonPermissions(jsi::Runtime &rt) = 0;
  virtual void checkPermissions(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void presentLocalNotification(jsi::Runtime &rt, jsi::Object notification) = 0;
  virtual void scheduleLocalNotification(jsi::Runtime &rt, jsi::Object notification) = 0;
  virtual void cancelAllLocalNotifications(jsi::Runtime &rt) = 0;
  virtual void cancelLocalNotifications(jsi::Runtime &rt, jsi::Object userInfo) = 0;
  virtual jsi::Value getInitialNotification(jsi::Runtime &rt) = 0;
  virtual void getScheduledLocalNotifications(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void removeAllDeliveredNotifications(jsi::Runtime &rt) = 0;
  virtual void removeDeliveredNotifications(jsi::Runtime &rt, jsi::Array identifiers) = 0;
  virtual void getDeliveredNotifications(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void getAuthorizationStatus(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventType) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativePushNotificationManagerIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "PushNotificationManager";

protected:
  NativePushNotificationManagerIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePushNotificationManagerIOSCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePushNotificationManagerIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePushNotificationManagerIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void onFinishRemoteNotification(jsi::Runtime &rt, jsi::String notificationId, jsi::String fetchResult) override {
      static_assert(
          bridging::getParameterCount(&T::onFinishRemoteNotification) == 3,
          "Expected onFinishRemoteNotification(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onFinishRemoteNotification, jsInvoker_, instance_, std::move(notificationId), std::move(fetchResult));
    }
    void setApplicationIconBadgeNumber(jsi::Runtime &rt, double num) override {
      static_assert(
          bridging::getParameterCount(&T::setApplicationIconBadgeNumber) == 2,
          "Expected setApplicationIconBadgeNumber(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setApplicationIconBadgeNumber, jsInvoker_, instance_, std::move(num));
    }
    void getApplicationIconBadgeNumber(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getApplicationIconBadgeNumber) == 2,
          "Expected getApplicationIconBadgeNumber(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getApplicationIconBadgeNumber, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value requestPermissions(jsi::Runtime &rt, jsi::Object permission) override {
      static_assert(
          bridging::getParameterCount(&T::requestPermissions) == 2,
          "Expected requestPermissions(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::requestPermissions, jsInvoker_, instance_, std::move(permission));
    }
    void abandonPermissions(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::abandonPermissions) == 1,
          "Expected abandonPermissions(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::abandonPermissions, jsInvoker_, instance_);
    }
    void checkPermissions(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::checkPermissions) == 2,
          "Expected checkPermissions(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::checkPermissions, jsInvoker_, instance_, std::move(callback));
    }
    void presentLocalNotification(jsi::Runtime &rt, jsi::Object notification) override {
      static_assert(
          bridging::getParameterCount(&T::presentLocalNotification) == 2,
          "Expected presentLocalNotification(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::presentLocalNotification, jsInvoker_, instance_, std::move(notification));
    }
    void scheduleLocalNotification(jsi::Runtime &rt, jsi::Object notification) override {
      static_assert(
          bridging::getParameterCount(&T::scheduleLocalNotification) == 2,
          "Expected scheduleLocalNotification(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::scheduleLocalNotification, jsInvoker_, instance_, std::move(notification));
    }
    void cancelAllLocalNotifications(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::cancelAllLocalNotifications) == 1,
          "Expected cancelAllLocalNotifications(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::cancelAllLocalNotifications, jsInvoker_, instance_);
    }
    void cancelLocalNotifications(jsi::Runtime &rt, jsi::Object userInfo) override {
      static_assert(
          bridging::getParameterCount(&T::cancelLocalNotifications) == 2,
          "Expected cancelLocalNotifications(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::cancelLocalNotifications, jsInvoker_, instance_, std::move(userInfo));
    }
    jsi::Value getInitialNotification(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getInitialNotification) == 1,
          "Expected getInitialNotification(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getInitialNotification, jsInvoker_, instance_);
    }
    void getScheduledLocalNotifications(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getScheduledLocalNotifications) == 2,
          "Expected getScheduledLocalNotifications(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getScheduledLocalNotifications, jsInvoker_, instance_, std::move(callback));
    }
    void removeAllDeliveredNotifications(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::removeAllDeliveredNotifications) == 1,
          "Expected removeAllDeliveredNotifications(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeAllDeliveredNotifications, jsInvoker_, instance_);
    }
    void removeDeliveredNotifications(jsi::Runtime &rt, jsi::Array identifiers) override {
      static_assert(
          bridging::getParameterCount(&T::removeDeliveredNotifications) == 2,
          "Expected removeDeliveredNotifications(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeDeliveredNotifications, jsInvoker_, instance_, std::move(identifiers));
    }
    void getDeliveredNotifications(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getDeliveredNotifications) == 2,
          "Expected getDeliveredNotifications(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getDeliveredNotifications, jsInvoker_, instance_, std::move(callback));
    }
    void getAuthorizationStatus(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getAuthorizationStatus) == 2,
          "Expected getAuthorizationStatus(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getAuthorizationStatus, jsInvoker_, instance_, std::move(callback));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventType) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventType));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRedBoxCxxSpecJSI : public TurboModule {
protected:
  NativeRedBoxCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::String forIdentifier) = 0;
  virtual void dismiss(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeRedBoxCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "RedBox";

protected:
  NativeRedBoxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRedBoxCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeRedBoxCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRedBoxCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::String forIdentifier) override {
      static_assert(
          bridging::getParameterCount(&T::setExtraData) == 3,
          "Expected setExtraData(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setExtraData, jsInvoker_, instance_, std::move(extraData), std::move(forIdentifier));
    }
    void dismiss(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::dismiss) == 1,
          "Expected dismiss(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dismiss, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


#pragma mark - SampleTurboModuleEnumInt

enum class SampleTurboModuleEnumInt { A, B };

template <>
struct Bridging<SampleTurboModuleEnumInt> {
  static SampleTurboModuleEnumInt fromJs(jsi::Runtime &rt, const jsi::Value &rawValue) {
    double value = (double)rawValue.asNumber();
    if (value == 23) {
      return SampleTurboModuleEnumInt::A;
    } else if (value == 42) {
      return SampleTurboModuleEnumInt::B;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, SampleTurboModuleEnumInt value) {
    if (value == SampleTurboModuleEnumInt::A) {
      return bridging::toJs(rt, 23);
    } else if (value == SampleTurboModuleEnumInt::B) {
      return bridging::toJs(rt, 42);
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value");
    }
  }
};
  class JSI_EXPORT NativeSampleTurboModuleCxxSpecJSI : public TurboModule {
protected:
  NativeSampleTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual bool getBool(jsi::Runtime &rt, bool arg) = 0;
  virtual jsi::Value getEnum(jsi::Runtime &rt, jsi::Value arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getUnsafeObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual double getRootTag(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String y, jsi::Object z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;
  virtual void voidFuncThrows(jsi::Runtime &rt) = 0;
  virtual jsi::Object getObjectThrows(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Value promiseThrows(jsi::Runtime &rt) = 0;
  virtual void voidFuncAssert(jsi::Runtime &rt) = 0;
  virtual jsi::Object getObjectAssert(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Value promiseAssert(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeSampleTurboModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "SampleTurboModule";

protected:
  NativeSampleTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSampleTurboModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSampleTurboModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSampleTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          "Expected voidFunc(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    bool getBool(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          "Expected getBool(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Value getEnum(jsi::Runtime &rt, jsi::Value arg) override {
      static_assert(
          bridging::getParameterCount(&T::getEnum) == 2,
          "Expected getEnum(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getEnum, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          "Expected getNumber(...) to have 2 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          "Expected getString(...) to have 2 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          "Expected getArray(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          "Expected getObject(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getUnsafeObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getUnsafeObject) == 2,
          "Expected getUnsafeObject(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getUnsafeObject, jsInvoker_, instance_, std::move(arg));
    }
    double getRootTag(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getRootTag) == 2,
          "Expected getRootTag(...) to have 2 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getRootTag, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String y, jsi::Object z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          "Expected getValue(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          "Expected getValueWithCallback(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          "Expected getValueWithPromise(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }
    void voidFuncThrows(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFuncThrows) == 1,
          "Expected voidFuncThrows(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::voidFuncThrows, jsInvoker_, instance_);
    }
    jsi::Object getObjectThrows(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectThrows) == 2,
          "Expected getObjectThrows(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectThrows, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Value promiseThrows(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::promiseThrows) == 1,
          "Expected promiseThrows(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::promiseThrows, jsInvoker_, instance_);
    }
    void voidFuncAssert(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFuncAssert) == 1,
          "Expected voidFuncAssert(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::voidFuncAssert, jsInvoker_, instance_);
    }
    jsi::Object getObjectAssert(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectAssert) == 2,
          "Expected getObjectAssert(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectAssert, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Value promiseAssert(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::promiseAssert) == 1,
          "Expected promiseAssert(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::promiseAssert, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeSegmentFetcherCxxSpecJSI : public TurboModule {
protected:
  NativeSegmentFetcherCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void fetchSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) = 0;
  virtual void getSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) = 0;

};

template <typename T>
class JSI_EXPORT NativeSegmentFetcherCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "SegmentFetcher";

protected:
  NativeSegmentFetcherCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSegmentFetcherCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSegmentFetcherCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSegmentFetcherCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void fetchSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::fetchSegment) == 4,
          "Expected fetchSegment(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::fetchSegment, jsInvoker_, instance_, std::move(segmentId), std::move(options), std::move(callback));
    }
    void getSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getSegment) == 4,
          "Expected getSegment(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getSegment, jsInvoker_, instance_, std::move(segmentId), std::move(options), std::move(callback));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeSettingsManagerCxxSpecJSI : public TurboModule {
protected:
  NativeSettingsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void setValues(jsi::Runtime &rt, jsi::Object values) = 0;
  virtual void deleteValues(jsi::Runtime &rt, jsi::Array values) = 0;

};

template <typename T>
class JSI_EXPORT NativeSettingsManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "SettingsManager";

protected:
  NativeSettingsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSettingsManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSettingsManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSettingsManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void setValues(jsi::Runtime &rt, jsi::Object values) override {
      static_assert(
          bridging::getParameterCount(&T::setValues) == 2,
          "Expected setValues(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setValues, jsInvoker_, instance_, std::move(values));
    }
    void deleteValues(jsi::Runtime &rt, jsi::Array values) override {
      static_assert(
          bridging::getParameterCount(&T::deleteValues) == 2,
          "Expected deleteValues(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::deleteValues, jsInvoker_, instance_, std::move(values));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeShareModuleCxxSpecJSI : public TurboModule {
protected:
  NativeShareModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value share(jsi::Runtime &rt, jsi::Object content, std::optional<jsi::String> dialogTitle) = 0;

};

template <typename T>
class JSI_EXPORT NativeShareModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ShareModule";

protected:
  NativeShareModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeShareModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeShareModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeShareModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value share(jsi::Runtime &rt, jsi::Object content, std::optional<jsi::String> dialogTitle) override {
      static_assert(
          bridging::getParameterCount(&T::share) == 3,
          "Expected share(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::share, jsInvoker_, instance_, std::move(content), std::move(dialogTitle));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeSoundManagerCxxSpecJSI : public TurboModule {
protected:
  NativeSoundManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void playTouchSound(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeSoundManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "SoundManager";

protected:
  NativeSoundManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSoundManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSoundManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSoundManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void playTouchSound(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::playTouchSound) == 1,
          "Expected playTouchSound(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::playTouchSound, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - SourceCodeBaseSourceCodeConstants

template <typename P0>
struct [[deprecated("Use SourceCodeSourceCodeConstants instead.")]] SourceCodeBaseSourceCodeConstants {
  P0 scriptURL;
  bool operator==(const SourceCodeBaseSourceCodeConstants &other) const {
    return scriptURL == other.scriptURL;
  }
};

template <typename P0>
struct [[deprecated("Use SourceCodeSourceCodeConstantsBridging instead.")]] SourceCodeBaseSourceCodeConstantsBridging {
  static SourceCodeBaseSourceCodeConstants<P0> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    SourceCodeBaseSourceCodeConstants<P0> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "scriptURL"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String scriptURLToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const SourceCodeBaseSourceCodeConstants<P0> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "scriptURL", bridging::toJs(rt, value.scriptURL, jsInvoker));
    return result;
  }
};


#pragma mark - SourceCodeSourceCodeConstants

template <typename P0>
struct SourceCodeSourceCodeConstants {
  P0 scriptURL;
  bool operator==(const SourceCodeSourceCodeConstants &other) const {
    return scriptURL == other.scriptURL;
  }
};

template <typename T>
struct SourceCodeSourceCodeConstantsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.scriptURL)>(rt, value.getProperty(rt, "scriptURL"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String scriptURLToJs(jsi::Runtime &rt, decltype(types.scriptURL) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "scriptURL", bridging::toJs(rt, value.scriptURL, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeSourceCodeCxxSpecJSI : public TurboModule {
protected:
  NativeSourceCodeCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeSourceCodeCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "SourceCode";

protected:
  NativeSourceCodeCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSourceCodeCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeSourceCodeCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSourceCodeCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeStatusBarManagerAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeStatusBarManagerAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void setColor(jsi::Runtime &rt, double color, bool animated) = 0;
  virtual void setTranslucent(jsi::Runtime &rt, bool translucent) = 0;
  virtual void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle) = 0;
  virtual void setHidden(jsi::Runtime &rt, bool hidden) = 0;

};

template <typename T>
class JSI_EXPORT NativeStatusBarManagerAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "StatusBarManager";

protected:
  NativeStatusBarManagerAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeStatusBarManagerAndroidCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeStatusBarManagerAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeStatusBarManagerAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void setColor(jsi::Runtime &rt, double color, bool animated) override {
      static_assert(
          bridging::getParameterCount(&T::setColor) == 3,
          "Expected setColor(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setColor, jsInvoker_, instance_, std::move(color), std::move(animated));
    }
    void setTranslucent(jsi::Runtime &rt, bool translucent) override {
      static_assert(
          bridging::getParameterCount(&T::setTranslucent) == 2,
          "Expected setTranslucent(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setTranslucent, jsInvoker_, instance_, std::move(translucent));
    }
    void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle) override {
      static_assert(
          bridging::getParameterCount(&T::setStyle) == 2,
          "Expected setStyle(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setStyle, jsInvoker_, instance_, std::move(statusBarStyle));
    }
    void setHidden(jsi::Runtime &rt, bool hidden) override {
      static_assert(
          bridging::getParameterCount(&T::setHidden) == 2,
          "Expected setHidden(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setHidden, jsInvoker_, instance_, std::move(hidden));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeStatusBarManagerIOSCxxSpecJSI : public TurboModule {
protected:
  NativeStatusBarManagerIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void getHeight(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual void setNetworkActivityIndicatorVisible(jsi::Runtime &rt, bool visible) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventType) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle, bool animated) = 0;
  virtual void setHidden(jsi::Runtime &rt, bool hidden, jsi::String withAnimation) = 0;

};

template <typename T>
class JSI_EXPORT NativeStatusBarManagerIOSCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "StatusBarManager";

protected:
  NativeStatusBarManagerIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeStatusBarManagerIOSCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeStatusBarManagerIOSCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeStatusBarManagerIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void getHeight(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getHeight) == 2,
          "Expected getHeight(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getHeight, jsInvoker_, instance_, std::move(callback));
    }
    void setNetworkActivityIndicatorVisible(jsi::Runtime &rt, bool visible) override {
      static_assert(
          bridging::getParameterCount(&T::setNetworkActivityIndicatorVisible) == 2,
          "Expected setNetworkActivityIndicatorVisible(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setNetworkActivityIndicatorVisible, jsInvoker_, instance_, std::move(visible));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventType) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventType));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle, bool animated) override {
      static_assert(
          bridging::getParameterCount(&T::setStyle) == 3,
          "Expected setStyle(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setStyle, jsInvoker_, instance_, std::move(statusBarStyle), std::move(animated));
    }
    void setHidden(jsi::Runtime &rt, bool hidden, jsi::String withAnimation) override {
      static_assert(
          bridging::getParameterCount(&T::setHidden) == 3,
          "Expected setHidden(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setHidden, jsInvoker_, instance_, std::move(hidden), std::move(withAnimation));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeTimingCxxSpecJSI : public TurboModule {
protected:
  NativeTimingCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void createTimer(jsi::Runtime &rt, double callbackID, double duration, double jsSchedulingTime, bool repeats) = 0;
  virtual void deleteTimer(jsi::Runtime &rt, double timerID) = 0;
  virtual void setSendIdleEvents(jsi::Runtime &rt, bool sendIdleEvents) = 0;

};

template <typename T>
class JSI_EXPORT NativeTimingCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "Timing";

protected:
  NativeTimingCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeTimingCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeTimingCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeTimingCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void createTimer(jsi::Runtime &rt, double callbackID, double duration, double jsSchedulingTime, bool repeats) override {
      static_assert(
          bridging::getParameterCount(&T::createTimer) == 5,
          "Expected createTimer(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createTimer, jsInvoker_, instance_, std::move(callbackID), std::move(duration), std::move(jsSchedulingTime), std::move(repeats));
    }
    void deleteTimer(jsi::Runtime &rt, double timerID) override {
      static_assert(
          bridging::getParameterCount(&T::deleteTimer) == 2,
          "Expected deleteTimer(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::deleteTimer, jsInvoker_, instance_, std::move(timerID));
    }
    void setSendIdleEvents(jsi::Runtime &rt, bool sendIdleEvents) override {
      static_assert(
          bridging::getParameterCount(&T::setSendIdleEvents) == 2,
          "Expected setSendIdleEvents(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setSendIdleEvents, jsInvoker_, instance_, std::move(sendIdleEvents));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeToastAndroidCxxSpecJSI : public TurboModule {
protected:
  NativeToastAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void show(jsi::Runtime &rt, jsi::String message, double duration) = 0;
  virtual void showWithGravity(jsi::Runtime &rt, jsi::String message, double duration, double gravity) = 0;
  virtual void showWithGravityAndOffset(jsi::Runtime &rt, jsi::String message, double duration, double gravity, double xOffset, double yOffset) = 0;

};

template <typename T>
class JSI_EXPORT NativeToastAndroidCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "ToastAndroid";

protected:
  NativeToastAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeToastAndroidCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeToastAndroidCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeToastAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void show(jsi::Runtime &rt, jsi::String message, double duration) override {
      static_assert(
          bridging::getParameterCount(&T::show) == 3,
          "Expected show(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::show, jsInvoker_, instance_, std::move(message), std::move(duration));
    }
    void showWithGravity(jsi::Runtime &rt, jsi::String message, double duration, double gravity) override {
      static_assert(
          bridging::getParameterCount(&T::showWithGravity) == 4,
          "Expected showWithGravity(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showWithGravity, jsInvoker_, instance_, std::move(message), std::move(duration), std::move(gravity));
    }
    void showWithGravityAndOffset(jsi::Runtime &rt, jsi::String message, double duration, double gravity, double xOffset, double yOffset) override {
      static_assert(
          bridging::getParameterCount(&T::showWithGravityAndOffset) == 6,
          "Expected showWithGravityAndOffset(...) to have 6 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showWithGravityAndOffset, jsInvoker_, instance_, std::move(message), std::move(duration), std::move(gravity), std::move(xOffset), std::move(yOffset));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeUIManagerCxxSpecJSI : public TurboModule {
protected:
  NativeUIManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void createView(jsi::Runtime &rt, double reactTag, jsi::String viewName, double rootTag, jsi::Object props) = 0;
  virtual void updateView(jsi::Runtime &rt, double reactTag, jsi::String viewName, jsi::Object props) = 0;
  virtual void findSubviewIn(jsi::Runtime &rt, double reactTag, jsi::Array point, jsi::Function callback) = 0;
  virtual void dispatchViewManagerCommand(jsi::Runtime &rt, double reactTag, double commandID, std::optional<jsi::Array> commandArgs) = 0;
  virtual void measure(jsi::Runtime &rt, double reactTag, jsi::Function callback) = 0;
  virtual void measureInWindow(jsi::Runtime &rt, double reactTag, jsi::Function callback) = 0;
  virtual void viewIsDescendantOf(jsi::Runtime &rt, double reactTag, double ancestorReactTag, jsi::Function callback) = 0;
  virtual void measureLayout(jsi::Runtime &rt, double reactTag, double ancestorReactTag, jsi::Function errorCallback, jsi::Function callback) = 0;
  virtual void measureLayoutRelativeToParent(jsi::Runtime &rt, double reactTag, jsi::Function errorCallback, jsi::Function callback) = 0;
  virtual void setJSResponder(jsi::Runtime &rt, double reactTag, bool blockNativeResponder) = 0;
  virtual void clearJSResponder(jsi::Runtime &rt) = 0;
  virtual void configureNextLayoutAnimation(jsi::Runtime &rt, jsi::Object config, jsi::Function callback, jsi::Function errorCallback) = 0;
  virtual void setChildren(jsi::Runtime &rt, double containerTag, jsi::Array reactTags) = 0;
  virtual void manageChildren(jsi::Runtime &rt, double containerTag, jsi::Array moveFromIndices, jsi::Array moveToIndices, jsi::Array addChildReactTags, jsi::Array addAtIndices, jsi::Array removeAtIndices) = 0;
  virtual std::optional<jsi::Object> getConstantsForViewManager(jsi::Runtime &rt, jsi::String viewManagerName) = 0;
  virtual jsi::Array getDefaultEventTypes(jsi::Runtime &rt) = 0;
  virtual void setLayoutAnimationEnabledExperimental(jsi::Runtime &rt, bool enabled) = 0;
  virtual void sendAccessibilityEvent(jsi::Runtime &rt, double reactTag, double eventType) = 0;
  virtual void showPopupMenu(jsi::Runtime &rt, double reactTag, jsi::Array items, jsi::Function error, jsi::Function success) = 0;
  virtual void dismissPopupMenu(jsi::Runtime &rt) = 0;
  virtual jsi::Object lazilyLoadView(jsi::Runtime &rt, jsi::String name) = 0;
  virtual void focus(jsi::Runtime &rt, double reactTag) = 0;
  virtual void blur(jsi::Runtime &rt, double reactTag) = 0;

};

template <typename T>
class JSI_EXPORT NativeUIManagerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "UIManager";

protected:
  NativeUIManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeUIManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeUIManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeUIManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void createView(jsi::Runtime &rt, double reactTag, jsi::String viewName, double rootTag, jsi::Object props) override {
      static_assert(
          bridging::getParameterCount(&T::createView) == 5,
          "Expected createView(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createView, jsInvoker_, instance_, std::move(reactTag), std::move(viewName), std::move(rootTag), std::move(props));
    }
    void updateView(jsi::Runtime &rt, double reactTag, jsi::String viewName, jsi::Object props) override {
      static_assert(
          bridging::getParameterCount(&T::updateView) == 4,
          "Expected updateView(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::updateView, jsInvoker_, instance_, std::move(reactTag), std::move(viewName), std::move(props));
    }
    void findSubviewIn(jsi::Runtime &rt, double reactTag, jsi::Array point, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::findSubviewIn) == 4,
          "Expected findSubviewIn(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::findSubviewIn, jsInvoker_, instance_, std::move(reactTag), std::move(point), std::move(callback));
    }
    void dispatchViewManagerCommand(jsi::Runtime &rt, double reactTag, double commandID, std::optional<jsi::Array> commandArgs) override {
      static_assert(
          bridging::getParameterCount(&T::dispatchViewManagerCommand) == 4,
          "Expected dispatchViewManagerCommand(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dispatchViewManagerCommand, jsInvoker_, instance_, std::move(reactTag), std::move(commandID), std::move(commandArgs));
    }
    void measure(jsi::Runtime &rt, double reactTag, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::measure) == 3,
          "Expected measure(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measure, jsInvoker_, instance_, std::move(reactTag), std::move(callback));
    }
    void measureInWindow(jsi::Runtime &rt, double reactTag, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::measureInWindow) == 3,
          "Expected measureInWindow(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measureInWindow, jsInvoker_, instance_, std::move(reactTag), std::move(callback));
    }
    void viewIsDescendantOf(jsi::Runtime &rt, double reactTag, double ancestorReactTag, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::viewIsDescendantOf) == 4,
          "Expected viewIsDescendantOf(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::viewIsDescendantOf, jsInvoker_, instance_, std::move(reactTag), std::move(ancestorReactTag), std::move(callback));
    }
    void measureLayout(jsi::Runtime &rt, double reactTag, double ancestorReactTag, jsi::Function errorCallback, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::measureLayout) == 5,
          "Expected measureLayout(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measureLayout, jsInvoker_, instance_, std::move(reactTag), std::move(ancestorReactTag), std::move(errorCallback), std::move(callback));
    }
    void measureLayoutRelativeToParent(jsi::Runtime &rt, double reactTag, jsi::Function errorCallback, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::measureLayoutRelativeToParent) == 4,
          "Expected measureLayoutRelativeToParent(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measureLayoutRelativeToParent, jsInvoker_, instance_, std::move(reactTag), std::move(errorCallback), std::move(callback));
    }
    void setJSResponder(jsi::Runtime &rt, double reactTag, bool blockNativeResponder) override {
      static_assert(
          bridging::getParameterCount(&T::setJSResponder) == 3,
          "Expected setJSResponder(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setJSResponder, jsInvoker_, instance_, std::move(reactTag), std::move(blockNativeResponder));
    }
    void clearJSResponder(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clearJSResponder) == 1,
          "Expected clearJSResponder(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::clearJSResponder, jsInvoker_, instance_);
    }
    void configureNextLayoutAnimation(jsi::Runtime &rt, jsi::Object config, jsi::Function callback, jsi::Function errorCallback) override {
      static_assert(
          bridging::getParameterCount(&T::configureNextLayoutAnimation) == 4,
          "Expected configureNextLayoutAnimation(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::configureNextLayoutAnimation, jsInvoker_, instance_, std::move(config), std::move(callback), std::move(errorCallback));
    }
    void setChildren(jsi::Runtime &rt, double containerTag, jsi::Array reactTags) override {
      static_assert(
          bridging::getParameterCount(&T::setChildren) == 3,
          "Expected setChildren(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setChildren, jsInvoker_, instance_, std::move(containerTag), std::move(reactTags));
    }
    void manageChildren(jsi::Runtime &rt, double containerTag, jsi::Array moveFromIndices, jsi::Array moveToIndices, jsi::Array addChildReactTags, jsi::Array addAtIndices, jsi::Array removeAtIndices) override {
      static_assert(
          bridging::getParameterCount(&T::manageChildren) == 7,
          "Expected manageChildren(...) to have 7 parameters");

      return bridging::callFromJs<void>(
          rt, &T::manageChildren, jsInvoker_, instance_, std::move(containerTag), std::move(moveFromIndices), std::move(moveToIndices), std::move(addChildReactTags), std::move(addAtIndices), std::move(removeAtIndices));
    }
    std::optional<jsi::Object> getConstantsForViewManager(jsi::Runtime &rt, jsi::String viewManagerName) override {
      static_assert(
          bridging::getParameterCount(&T::getConstantsForViewManager) == 2,
          "Expected getConstantsForViewManager(...) to have 2 parameters");

      return bridging::callFromJs<std::optional<jsi::Object>>(
          rt, &T::getConstantsForViewManager, jsInvoker_, instance_, std::move(viewManagerName));
    }
    jsi::Array getDefaultEventTypes(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getDefaultEventTypes) == 1,
          "Expected getDefaultEventTypes(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getDefaultEventTypes, jsInvoker_, instance_);
    }
    void setLayoutAnimationEnabledExperimental(jsi::Runtime &rt, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::setLayoutAnimationEnabledExperimental) == 2,
          "Expected setLayoutAnimationEnabledExperimental(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setLayoutAnimationEnabledExperimental, jsInvoker_, instance_, std::move(enabled));
    }
    void sendAccessibilityEvent(jsi::Runtime &rt, double reactTag, double eventType) override {
      static_assert(
          bridging::getParameterCount(&T::sendAccessibilityEvent) == 3,
          "Expected sendAccessibilityEvent(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendAccessibilityEvent, jsInvoker_, instance_, std::move(reactTag), std::move(eventType));
    }
    void showPopupMenu(jsi::Runtime &rt, double reactTag, jsi::Array items, jsi::Function error, jsi::Function success) override {
      static_assert(
          bridging::getParameterCount(&T::showPopupMenu) == 5,
          "Expected showPopupMenu(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::showPopupMenu, jsInvoker_, instance_, std::move(reactTag), std::move(items), std::move(error), std::move(success));
    }
    void dismissPopupMenu(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::dismissPopupMenu) == 1,
          "Expected dismissPopupMenu(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::dismissPopupMenu, jsInvoker_, instance_);
    }
    jsi::Object lazilyLoadView(jsi::Runtime &rt, jsi::String name) override {
      static_assert(
          bridging::getParameterCount(&T::lazilyLoadView) == 2,
          "Expected lazilyLoadView(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::lazilyLoadView, jsInvoker_, instance_, std::move(name));
    }
    void focus(jsi::Runtime &rt, double reactTag) override {
      static_assert(
          bridging::getParameterCount(&T::focus) == 2,
          "Expected focus(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::focus, jsInvoker_, instance_, std::move(reactTag));
    }
    void blur(jsi::Runtime &rt, double reactTag) override {
      static_assert(
          bridging::getParameterCount(&T::blur) == 2,
          "Expected blur(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::blur, jsInvoker_, instance_, std::move(reactTag));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeVibrationCxxSpecJSI : public TurboModule {
protected:
  NativeVibrationCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual void vibrate(jsi::Runtime &rt, double pattern) = 0;
  virtual void vibrateByPattern(jsi::Runtime &rt, jsi::Array pattern, double repeat) = 0;
  virtual void cancel(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeVibrationCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "Vibration";

protected:
  NativeVibrationCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeVibrationCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeVibrationCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeVibrationCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    void vibrate(jsi::Runtime &rt, double pattern) override {
      static_assert(
          bridging::getParameterCount(&T::vibrate) == 2,
          "Expected vibrate(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::vibrate, jsInvoker_, instance_, std::move(pattern));
    }
    void vibrateByPattern(jsi::Runtime &rt, jsi::Array pattern, double repeat) override {
      static_assert(
          bridging::getParameterCount(&T::vibrateByPattern) == 3,
          "Expected vibrateByPattern(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::vibrateByPattern, jsInvoker_, instance_, std::move(pattern), std::move(repeat));
    }
    void cancel(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::cancel) == 1,
          "Expected cancel(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::cancel, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeWebSocketModuleCxxSpecJSI : public TurboModule {
protected:
  NativeWebSocketModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void connect(jsi::Runtime &rt, jsi::String url, std::optional<jsi::Array> protocols, jsi::Object options, double socketID) = 0;
  virtual void send(jsi::Runtime &rt, jsi::String message, double forSocketID) = 0;
  virtual void sendBinary(jsi::Runtime &rt, jsi::String base64String, double forSocketID) = 0;
  virtual void ping(jsi::Runtime &rt, double socketID) = 0;
  virtual void close(jsi::Runtime &rt, double code, jsi::String reason, double socketID) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeWebSocketModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "WebSocketModule";

protected:
  NativeWebSocketModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeWebSocketModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeWebSocketModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeWebSocketModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void connect(jsi::Runtime &rt, jsi::String url, std::optional<jsi::Array> protocols, jsi::Object options, double socketID) override {
      static_assert(
          bridging::getParameterCount(&T::connect) == 5,
          "Expected connect(...) to have 5 parameters");

      return bridging::callFromJs<void>(
          rt, &T::connect, jsInvoker_, instance_, std::move(url), std::move(protocols), std::move(options), std::move(socketID));
    }
    void send(jsi::Runtime &rt, jsi::String message, double forSocketID) override {
      static_assert(
          bridging::getParameterCount(&T::send) == 3,
          "Expected send(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::send, jsInvoker_, instance_, std::move(message), std::move(forSocketID));
    }
    void sendBinary(jsi::Runtime &rt, jsi::String base64String, double forSocketID) override {
      static_assert(
          bridging::getParameterCount(&T::sendBinary) == 3,
          "Expected sendBinary(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::sendBinary, jsInvoker_, instance_, std::move(base64String), std::move(forSocketID));
    }
    void ping(jsi::Runtime &rt, double socketID) override {
      static_assert(
          bridging::getParameterCount(&T::ping) == 2,
          "Expected ping(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::ping, jsInvoker_, instance_, std::move(socketID));
    }
    void close(jsi::Runtime &rt, double code, jsi::String reason, double socketID) override {
      static_assert(
          bridging::getParameterCount(&T::close) == 4,
          "Expected close(...) to have 4 parameters");

      return bridging::callFromJs<void>(
          rt, &T::close, jsInvoker_, instance_, std::move(code), std::move(reason), std::move(socketID));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePerformanceCxxSpecJSI : public TurboModule {
protected:
  NativePerformanceCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void mark(jsi::Runtime &rt, jsi::String name, double startTime) = 0;
  virtual void measure(jsi::Runtime &rt, jsi::String name, double startTime, double endTime, std::optional<double> duration, std::optional<jsi::String> startMark, std::optional<jsi::String> endMark) = 0;
  virtual jsi::Object getSimpleMemoryInfo(jsi::Runtime &rt) = 0;
  virtual jsi::Object getReactNativeStartupTiming(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativePerformanceCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "NativePerformanceCxx";

protected:
  NativePerformanceCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePerformanceCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePerformanceCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePerformanceCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void mark(jsi::Runtime &rt, jsi::String name, double startTime) override {
      static_assert(
          bridging::getParameterCount(&T::mark) == 3,
          "Expected mark(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::mark, jsInvoker_, instance_, std::move(name), std::move(startTime));
    }
    void measure(jsi::Runtime &rt, jsi::String name, double startTime, double endTime, std::optional<double> duration, std::optional<jsi::String> startMark, std::optional<jsi::String> endMark) override {
      static_assert(
          bridging::getParameterCount(&T::measure) == 7,
          "Expected measure(...) to have 7 parameters");

      return bridging::callFromJs<void>(
          rt, &T::measure, jsInvoker_, instance_, std::move(name), std::move(startTime), std::move(endTime), std::move(duration), std::move(startMark), std::move(endMark));
    }
    jsi::Object getSimpleMemoryInfo(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSimpleMemoryInfo) == 1,
          "Expected getSimpleMemoryInfo(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getSimpleMemoryInfo, jsInvoker_, instance_);
    }
    jsi::Object getReactNativeStartupTiming(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getReactNativeStartupTiming) == 1,
          "Expected getReactNativeStartupTiming(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getReactNativeStartupTiming, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativePerformanceObserverCxxBaseRawPerformanceEntry

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct [[deprecated("Use NativePerformanceObserverCxxRawPerformanceEntry instead.")]] NativePerformanceObserverCxxBaseRawPerformanceEntry {
  P0 name;
  P1 entryType;
  P2 startTime;
  P3 duration;
  P4 processingStart;
  P5 processingEnd;
  P6 interactionId;
  bool operator==(const NativePerformanceObserverCxxBaseRawPerformanceEntry &other) const {
    return name == other.name && entryType == other.entryType && startTime == other.startTime && duration == other.duration && processingStart == other.processingStart && processingEnd == other.processingEnd && interactionId == other.interactionId;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct [[deprecated("Use NativePerformanceObserverCxxRawPerformanceEntryBridging instead.")]] NativePerformanceObserverCxxBaseRawPerformanceEntryBridging {
  static NativePerformanceObserverCxxBaseRawPerformanceEntry<P0, P1, P2, P3, P4, P5, P6> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativePerformanceObserverCxxBaseRawPerformanceEntry<P0, P1, P2, P3, P4, P5, P6> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "entryType"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "startTime"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "duration"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "processingStart"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "processingEnd"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "interactionId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static double entryTypeToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static double startTimeToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static double durationToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static double processingStartToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static double processingEndToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static double interactionIdToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativePerformanceObserverCxxBaseRawPerformanceEntry<P0, P1, P2, P3, P4, P5, P6> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "entryType", bridging::toJs(rt, value.entryType, jsInvoker));
    result.setProperty(rt, "startTime", bridging::toJs(rt, value.startTime, jsInvoker));
    result.setProperty(rt, "duration", bridging::toJs(rt, value.duration, jsInvoker));
    if (value.processingStart) {
      result.setProperty(rt, "processingStart", bridging::toJs(rt, value.processingStart.value(), jsInvoker));
    }
    if (value.processingEnd) {
      result.setProperty(rt, "processingEnd", bridging::toJs(rt, value.processingEnd.value(), jsInvoker));
    }
    if (value.interactionId) {
      result.setProperty(rt, "interactionId", bridging::toJs(rt, value.interactionId.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativePerformanceObserverCxxBaseGetPendingEntriesResult

template <typename P0, typename P1>
struct [[deprecated("Use NativePerformanceObserverCxxGetPendingEntriesResult instead.")]] NativePerformanceObserverCxxBaseGetPendingEntriesResult {
  P0 entries;
  P1 droppedEntriesCount;
  bool operator==(const NativePerformanceObserverCxxBaseGetPendingEntriesResult &other) const {
    return entries == other.entries && droppedEntriesCount == other.droppedEntriesCount;
  }
};

template <typename P0, typename P1>
struct [[deprecated("Use NativePerformanceObserverCxxGetPendingEntriesResultBridging instead.")]] NativePerformanceObserverCxxBaseGetPendingEntriesResultBridging {
  static NativePerformanceObserverCxxBaseGetPendingEntriesResult<P0, P1> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    NativePerformanceObserverCxxBaseGetPendingEntriesResult<P0, P1> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "entries"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "droppedEntriesCount"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array entriesToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static double droppedEntriesCountToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const NativePerformanceObserverCxxBaseGetPendingEntriesResult<P0, P1> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "entries", bridging::toJs(rt, value.entries, jsInvoker));
    result.setProperty(rt, "droppedEntriesCount", bridging::toJs(rt, value.droppedEntriesCount, jsInvoker));
    return result;
  }
};


#pragma mark - NativePerformanceObserverCxxRawPerformanceEntry

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct NativePerformanceObserverCxxRawPerformanceEntry {
  P0 name;
  P1 entryType;
  P2 startTime;
  P3 duration;
  P4 processingStart;
  P5 processingEnd;
  P6 interactionId;
  bool operator==(const NativePerformanceObserverCxxRawPerformanceEntry &other) const {
    return name == other.name && entryType == other.entryType && startTime == other.startTime && duration == other.duration && processingStart == other.processingStart && processingEnd == other.processingEnd && interactionId == other.interactionId;
  }
};

template <typename T>
struct NativePerformanceObserverCxxRawPerformanceEntryBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<decltype(types.entryType)>(rt, value.getProperty(rt, "entryType"), jsInvoker),
      bridging::fromJs<decltype(types.startTime)>(rt, value.getProperty(rt, "startTime"), jsInvoker),
      bridging::fromJs<decltype(types.duration)>(rt, value.getProperty(rt, "duration"), jsInvoker),
      bridging::fromJs<decltype(types.processingStart)>(rt, value.getProperty(rt, "processingStart"), jsInvoker),
      bridging::fromJs<decltype(types.processingEnd)>(rt, value.getProperty(rt, "processingEnd"), jsInvoker),
      bridging::fromJs<decltype(types.interactionId)>(rt, value.getProperty(rt, "interactionId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }

  static double entryTypeToJs(jsi::Runtime &rt, decltype(types.entryType) value) {
    return bridging::toJs(rt, value);
  }

  static double startTimeToJs(jsi::Runtime &rt, decltype(types.startTime) value) {
    return bridging::toJs(rt, value);
  }

  static double durationToJs(jsi::Runtime &rt, decltype(types.duration) value) {
    return bridging::toJs(rt, value);
  }

  static double processingStartToJs(jsi::Runtime &rt, decltype(types.processingStart) value) {
    return bridging::toJs(rt, value);
  }

  static double processingEndToJs(jsi::Runtime &rt, decltype(types.processingEnd) value) {
    return bridging::toJs(rt, value);
  }

  static double interactionIdToJs(jsi::Runtime &rt, decltype(types.interactionId) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "entryType", bridging::toJs(rt, value.entryType, jsInvoker));
    result.setProperty(rt, "startTime", bridging::toJs(rt, value.startTime, jsInvoker));
    result.setProperty(rt, "duration", bridging::toJs(rt, value.duration, jsInvoker));
    if (value.processingStart) {
      result.setProperty(rt, "processingStart", bridging::toJs(rt, value.processingStart.value(), jsInvoker));
    }
    if (value.processingEnd) {
      result.setProperty(rt, "processingEnd", bridging::toJs(rt, value.processingEnd.value(), jsInvoker));
    }
    if (value.interactionId) {
      result.setProperty(rt, "interactionId", bridging::toJs(rt, value.interactionId.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativePerformanceObserverCxxGetPendingEntriesResult

template <typename P0, typename P1>
struct NativePerformanceObserverCxxGetPendingEntriesResult {
  P0 entries;
  P1 droppedEntriesCount;
  bool operator==(const NativePerformanceObserverCxxGetPendingEntriesResult &other) const {
    return entries == other.entries && droppedEntriesCount == other.droppedEntriesCount;
  }
};

template <typename T>
struct NativePerformanceObserverCxxGetPendingEntriesResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.entries)>(rt, value.getProperty(rt, "entries"), jsInvoker),
      bridging::fromJs<decltype(types.droppedEntriesCount)>(rt, value.getProperty(rt, "droppedEntriesCount"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array entriesToJs(jsi::Runtime &rt, decltype(types.entries) value) {
    return bridging::toJs(rt, value);
  }

  static double droppedEntriesCountToJs(jsi::Runtime &rt, decltype(types.droppedEntriesCount) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "entries", bridging::toJs(rt, value.entries, jsInvoker));
    result.setProperty(rt, "droppedEntriesCount", bridging::toJs(rt, value.droppedEntriesCount, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativePerformanceObserverCxxSpecJSI : public TurboModule {
protected:
  NativePerformanceObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void startReporting(jsi::Runtime &rt, double entryType) = 0;
  virtual void stopReporting(jsi::Runtime &rt, double entryType) = 0;
  virtual void setIsBuffered(jsi::Runtime &rt, jsi::Array entryTypes, bool isBuffered) = 0;
  virtual jsi::Object popPendingEntries(jsi::Runtime &rt) = 0;
  virtual void setOnPerformanceEntryCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) = 0;
  virtual void logRawEntry(jsi::Runtime &rt, jsi::Object entry) = 0;
  virtual jsi::Array getEventCounts(jsi::Runtime &rt) = 0;
  virtual void setDurationThreshold(jsi::Runtime &rt, double entryType, double durationThreshold) = 0;
  virtual void clearEntries(jsi::Runtime &rt, double entryType, std::optional<jsi::String> entryName) = 0;
  virtual jsi::Array getEntries(jsi::Runtime &rt, std::optional<double> entryType, std::optional<jsi::String> entryName) = 0;
  virtual jsi::Array getSupportedPerformanceEntryTypes(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativePerformanceObserverCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "NativePerformanceObserverCxx";

protected:
  NativePerformanceObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePerformanceObserverCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativePerformanceObserverCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePerformanceObserverCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    void startReporting(jsi::Runtime &rt, double entryType) override {
      static_assert(
          bridging::getParameterCount(&T::startReporting) == 2,
          "Expected startReporting(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startReporting, jsInvoker_, instance_, std::move(entryType));
    }
    void stopReporting(jsi::Runtime &rt, double entryType) override {
      static_assert(
          bridging::getParameterCount(&T::stopReporting) == 2,
          "Expected stopReporting(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stopReporting, jsInvoker_, instance_, std::move(entryType));
    }
    void setIsBuffered(jsi::Runtime &rt, jsi::Array entryTypes, bool isBuffered) override {
      static_assert(
          bridging::getParameterCount(&T::setIsBuffered) == 3,
          "Expected setIsBuffered(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setIsBuffered, jsInvoker_, instance_, std::move(entryTypes), std::move(isBuffered));
    }
    jsi::Object popPendingEntries(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::popPendingEntries) == 1,
          "Expected popPendingEntries(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::popPendingEntries, jsInvoker_, instance_);
    }
    void setOnPerformanceEntryCallback(jsi::Runtime &rt, std::optional<jsi::Function> callback) override {
      static_assert(
          bridging::getParameterCount(&T::setOnPerformanceEntryCallback) == 2,
          "Expected setOnPerformanceEntryCallback(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setOnPerformanceEntryCallback, jsInvoker_, instance_, std::move(callback));
    }
    void logRawEntry(jsi::Runtime &rt, jsi::Object entry) override {
      static_assert(
          bridging::getParameterCount(&T::logRawEntry) == 2,
          "Expected logRawEntry(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::logRawEntry, jsInvoker_, instance_, std::move(entry));
    }
    jsi::Array getEventCounts(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getEventCounts) == 1,
          "Expected getEventCounts(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getEventCounts, jsInvoker_, instance_);
    }
    void setDurationThreshold(jsi::Runtime &rt, double entryType, double durationThreshold) override {
      static_assert(
          bridging::getParameterCount(&T::setDurationThreshold) == 3,
          "Expected setDurationThreshold(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setDurationThreshold, jsInvoker_, instance_, std::move(entryType), std::move(durationThreshold));
    }
    void clearEntries(jsi::Runtime &rt, double entryType, std::optional<jsi::String> entryName) override {
      static_assert(
          bridging::getParameterCount(&T::clearEntries) == 3,
          "Expected clearEntries(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::clearEntries, jsInvoker_, instance_, std::move(entryType), std::move(entryName));
    }
    jsi::Array getEntries(jsi::Runtime &rt, std::optional<double> entryType, std::optional<jsi::String> entryName) override {
      static_assert(
          bridging::getParameterCount(&T::getEntries) == 3,
          "Expected getEntries(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getEntries, jsInvoker_, instance_, std::move(entryType), std::move(entryName));
    }
    jsi::Array getSupportedPerformanceEntryTypes(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSupportedPerformanceEntryTypes) == 1,
          "Expected getSupportedPerformanceEntryTypes(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getSupportedPerformanceEntryTypes, jsInvoker_, instance_);
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
