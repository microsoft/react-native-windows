/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


template <typename T>
class JSI_EXPORT NativeMySimpleTurboModuleCxxCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "MySimpleTurboModuleCxx";

protected:
  NativeMySimpleTurboModuleCxxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeMySimpleTurboModuleCxxCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["getConstants"] = MethodMetadata {.argCount = 0, .invoker = __getConstants};
    methodMap_["logAction"] = MethodMetadata {.argCount = 2, .invoker = __logAction};
    methodMap_["voidFunc"] = MethodMetadata {.argCount = 0, .invoker = __voidFunc};
    methodMap_["getBool"] = MethodMetadata {.argCount = 1, .invoker = __getBool};
    methodMap_["getNumber"] = MethodMetadata {.argCount = 1, .invoker = __getNumber};
    methodMap_["getString"] = MethodMetadata {.argCount = 1, .invoker = __getString};
    methodMap_["getArray"] = MethodMetadata {.argCount = 1, .invoker = __getArray};
    methodMap_["getObject"] = MethodMetadata {.argCount = 1, .invoker = __getObject};
    methodMap_["getValue"] = MethodMetadata {.argCount = 3, .invoker = __getValue};
    methodMap_["getValueWithCallback"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithCallback};
    methodMap_["getValueWithPromise"] = MethodMetadata {.argCount = 1, .invoker = __getValueWithPromise};
  }
  
private:
  static jsi::Value __getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::getConstants) == 1,
      "Expected getConstants(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getConstants,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __logAction(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::logAction) == 3,
      "Expected logAction(...) to have 3 parameters");
    bridging::callFromJs<void>(rt, &T::logAction,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1]));return jsi::Value::undefined();
  }

  static jsi::Value __voidFunc(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::voidFunc) == 1,
      "Expected voidFunc(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::voidFunc,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }

  static jsi::Value __getBool(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getBool) == 2,
      "Expected getBool(...) to have 2 parameters");
    return bridging::callFromJs<bool>(rt, &T::getBool,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());
  }

  static jsi::Value __getNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getNumber) == 2,
      "Expected getNumber(...) to have 2 parameters");
    return bridging::callFromJs<double>(rt, &T::getNumber,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());
  }

  static jsi::Value __getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getString) == 2,
      "Expected getString(...) to have 2 parameters");
    return bridging::callFromJs<jsi::String>(rt, &T::getString,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __getArray(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getArray) == 2,
      "Expected getArray(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Array>(rt, &T::getArray,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getObject(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getObject) == 2,
      "Expected getObject(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getObject,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));
  }

  static jsi::Value __getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValue) == 4,
      "Expected getValue(...) to have 4 parameters");
    return bridging::callFromJs<jsi::Object>(rt, &T::getValue,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
      count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt));
  }

  static jsi::Value __getValueWithCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithCallback) == 2,
      "Expected getValueWithCallback(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::getValueWithCallback,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt));return jsi::Value::undefined();
  }

  static jsi::Value __getValueWithPromise(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getValueWithPromise) == 2,
      "Expected getValueWithPromise(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getValueWithPromise,  static_cast<NativeMySimpleTurboModuleCxxCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool());
  }
};


template <typename T>
class JSI_EXPORT NativeMyTrivialTurboModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "MyTrivialTurboModule";

protected:
  NativeMyTrivialTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeMyTrivialTurboModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["startFromJS"] = MethodMetadata {.argCount = 0, .invoker = __startFromJS};
  }
  
private:
  static jsi::Value __startFromJS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::startFromJS) == 1,
      "Expected startFromJS(...) to have 1 parameters");
    bridging::callFromJs<void>(rt, &T::startFromJS,  static_cast<NativeMyTrivialTurboModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));return jsi::Value::undefined();
  }
};

} // namespace facebook::react
