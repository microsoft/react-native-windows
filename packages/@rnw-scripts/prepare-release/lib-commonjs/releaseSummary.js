"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Parse bumped packages and generate PR description markdown.
 *
 * @format
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateConsoleSummary = exports.generatePRBody = exports.collectBumpedPackages = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/**
 * Collect information about packages that were bumped by beachball.
 *
 * For each changed package.json, reads the new version and parses
 * CHANGELOG.json for the latest changelog entry.
 *
 * @param changedPackageJsonPaths Relative paths to package.json files
 *   that were modified by beachball bump (from git status --porcelain)
 * @param repoRoot The repository root directory
 */
function collectBumpedPackages(changedPackageJsonPaths, repoRoot) {
    var _a;
    const bumped = [];
    for (const relPath of changedPackageJsonPaths) {
        const fullPath = path_1.default.join(repoRoot, relPath);
        if (!fs_1.default.existsSync(fullPath)) {
            continue;
        }
        let pkgJson;
        try {
            pkgJson = JSON.parse(fs_1.default.readFileSync(fullPath, 'utf8'));
        }
        catch (_b) {
            continue;
        }
        const name = pkgJson.name;
        const version = pkgJson.version;
        if (!name || !version) {
            continue;
        }
        // Try to read CHANGELOG.json from the same directory
        const pkgDir = path_1.default.dirname(fullPath);
        const changelogPath = path_1.default.join(pkgDir, 'CHANGELOG.json');
        const comments = [];
        if (fs_1.default.existsSync(changelogPath)) {
            try {
                const changelog = JSON.parse(fs_1.default.readFileSync(changelogPath, 'utf8'));
                // CHANGELOG.json structure:
                // { entries: [{ version, comments: { <changeType>: [{ comment, author }] } }] }
                const latest = (_a = changelog.entries) === null || _a === void 0 ? void 0 : _a[0];
                if (latest && latest.version === version) {
                    for (const typeComments of Object.values(latest.comments || {})) {
                        for (const c of typeComments) {
                            comments.push({
                                comment: c.comment || '',
                                author: c.author || '',
                            });
                        }
                    }
                }
            }
            catch (_c) {
                // If CHANGELOG.json is malformed, skip comments
            }
        }
        bumped.push({ name, version, comments });
    }
    // Sort by package name for consistent output
    bumped.sort((a, b) => a.name.localeCompare(b.name));
    return bumped;
}
exports.collectBumpedPackages = collectBumpedPackages;
/**
 * Generate the pull request body markdown.
 */
function generatePRBody(targetBranch, packages) {
    const lines = [];
    lines.push('> This PR was auto-generated by `prepare-release`.');
    lines.push(`> When ready to release, merge this PR into \`${targetBranch}\`.`);
    lines.push('> If not ready yet, this PR will be updated as more changes merge.');
    lines.push('');
    lines.push(`## Packages to Release (${packages.length})`);
    lines.push('');
    for (const pkg of packages) {
        lines.push(`### ${pkg.name}@${pkg.version}`);
        if (pkg.comments.length > 0) {
            for (const c of pkg.comments) {
                lines.push(`- ${c.comment}`);
            }
        }
        else {
            lines.push('- *(dependency update)*');
        }
        lines.push('');
    }
    return lines.join('\n');
}
exports.generatePRBody = generatePRBody;
/**
 * Generate a console-friendly summary of bumped packages.
 */
function generateConsoleSummary(packages) {
    if (packages.length === 0) {
        return 'No packages were bumped.';
    }
    const lines = [];
    lines.push(`Bumped ${packages.length} package(s):`);
    for (const pkg of packages) {
        lines.push(`  ${pkg.name} => ${pkg.version}`);
    }
    return lines.join('\n');
}
exports.generateConsoleSummary = generateConsoleSummary;
//# sourceMappingURL=releaseSummary.js.map