/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Parse bumped packages and generate PR description markdown.
 *
 * @format
 */

import fs from 'fs';
import path from 'path';

export interface BumpedPackage {
  name: string;
  version: string;
  comments: Array<{comment: string; author: string}>;
}

/**
 * Collect information about packages that were bumped by beachball.
 *
 * For each changed package.json, reads the new version and parses
 * CHANGELOG.json for the latest changelog entry.
 *
 * @param changedPackageJsonPaths Relative paths to package.json files
 *   that were modified by beachball bump (from git status --porcelain)
 * @param repoRoot The repository root directory
 */
export function collectBumpedPackages(
  changedPackageJsonPaths: string[],
  repoRoot: string,
): BumpedPackage[] {
  const bumped: BumpedPackage[] = [];

  for (const relPath of changedPackageJsonPaths) {
    const fullPath = path.join(repoRoot, relPath);
    if (!fs.existsSync(fullPath)) {
      continue;
    }

    let pkgJson: {name?: string; version?: string};
    try {
      pkgJson = JSON.parse(fs.readFileSync(fullPath, 'utf8'));
    } catch {
      continue;
    }

    const name = pkgJson.name;
    const version = pkgJson.version;
    if (!name || !version) {
      continue;
    }

    // Try to read CHANGELOG.json from the same directory
    const pkgDir = path.dirname(fullPath);
    const changelogPath = path.join(pkgDir, 'CHANGELOG.json');
    const comments: Array<{comment: string; author: string}> = [];

    if (fs.existsSync(changelogPath)) {
      try {
        const changelog = JSON.parse(
          fs.readFileSync(changelogPath, 'utf8'),
        );

        // CHANGELOG.json structure:
        // { entries: [{ version, comments: { <changeType>: [{ comment, author }] } }] }
        const latest = changelog.entries?.[0];
        if (latest && latest.version === version) {
          for (const typeComments of Object.values(
            latest.comments || {},
          )) {
            for (const c of typeComments as Array<{
              comment: string;
              author: string;
            }>) {
              comments.push({
                comment: c.comment || '',
                author: c.author || '',
              });
            }
          }
        }
      } catch {
        // If CHANGELOG.json is malformed, skip comments
      }
    }

    bumped.push({name, version, comments});
  }

  // Sort by package name for consistent output
  bumped.sort((a, b) => a.name.localeCompare(b.name));
  return bumped;
}

/**
 * Generate the pull request body markdown.
 */
export function generatePRBody(
  targetBranch: string,
  packages: BumpedPackage[],
): string {
  const lines: string[] = [];

  lines.push('> This PR was auto-generated by `prepare-release`.');
  lines.push(
    `> When ready to release, merge this PR into \`${targetBranch}\`.`,
  );
  lines.push(
    '> If not ready yet, this PR will be updated as more changes merge.',
  );
  lines.push('');
  lines.push(`## Packages to Release (${packages.length})`);
  lines.push('');

  for (const pkg of packages) {
    lines.push(`### ${pkg.name}@${pkg.version}`);
    if (pkg.comments.length > 0) {
      for (const c of pkg.comments) {
        lines.push(`- ${c.comment}`);
      }
    } else {
      lines.push('- *(dependency update)*');
    }
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate a console-friendly summary of bumped packages.
 */
export function generateConsoleSummary(packages: BumpedPackage[]): string {
  if (packages.length === 0) {
    return 'No packages were bumped.';
  }

  const lines: string[] = [];
  lines.push(`Bumped ${packages.length} package(s):`);
  for (const pkg of packages) {
    lines.push(`  ${pkg.name} => ${pkg.version}`);
  }
  return lines.join('\n');
}
