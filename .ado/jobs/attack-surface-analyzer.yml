# Job to run Attack Surface Analyzer (ASA) for SDL compliance
# Validates that installers or high-privilege programs do not weaken OS security
parameters:
  - name: buildEnvironment
    type: string
    default: PullRequest
    values:
      - PullRequest
      - SecurePullRequest
      - Continuous
  - name: AgentPool
    type: object
  - name: complianceWarnOnly
    displayName: Convert compliance errors to warnings
    type: boolean
    default: true

jobs:
  # Only run ASA for SecurePullRequest builds
  - ${{if eq(parameters.buildEnvironment, 'SecurePullRequest')}}:
    - job: AttackSurfaceAnalyzer
      displayName: Attack Surface Analyzer (ASA) üõ°Ô∏è
      pool: ${{ parameters.AgentPool.Medium }}
      timeoutInMinutes: 60
      cancelTimeoutInMinutes: 5

      variables:
        - template: ../variables/windows.yml

      steps:
        - template: ../templates/checkout-shallow.yml

        - template: ../templates/prepare-js-env.yml

        - template: ../templates/set-version-vars.yml
          parameters:
            buildEnvironment: ${{ parameters.buildEnvironment }}

        - template: ../templates/prepare-build-env.yml
          parameters:
            platform: x64
            configuration: Release
            buildEnvironment: ${{ parameters.buildEnvironment }}

        # Authenticate to NuGet feeds
        - task: NuGetAuthenticate@1
          displayName: 'üõ°Ô∏è Authenticate NuGet'

        # Install Attack Surface Analyzer CLI tool
        - task: PowerShell@2
          displayName: 'üõ°Ô∏è Install Attack Surface Analyzer'
          inputs:
            errorActionPreference: 'continue'
            targetType: inline
            script: |
              Write-Host "Installing Attack Surface Analyzer (ASA) CLI tool..."
              # Install from public NuGet.org feed
              dotnet tool install --global Microsoft.CST.AttackSurfaceAnalyzer.CLI --add-source https://api.nuget.org/v3/index.json
              
              if ($LASTEXITCODE -ne 0) {
                Write-Error "Failed to install ASA tool"
                exit 1
              }

        # Take "before" snapshot of the system
        - task: PowerShell@2
          displayName: 'üõ°Ô∏è ASA - Collect Before Snapshot'
          inputs:
            targetType: inline
            script: |
              # Refresh environment PATH to include .NET global tools
              $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" + [System.Environment]::GetEnvironmentVariable("PATH", "User")
              
              Write-Host "Taking 'before' snapshot of system state..."
              # Collect files (-f), registry (-r), services (-s), ports (-p), certificates (-c)
              asa collect -f -r -s -p -c --directories "$(Build.SourcesDirectory)" --verbose
              if ($LASTEXITCODE -ne 0) {
                Write-Error "Failed to collect 'before' snapshot"
                exit 1
              }
              Write-Host "‚úÖ Before snapshot collected successfully"

        # Build the React Native Windows solution
        # This simulates the "installation" that ASA will analyze
        - template: ../templates/msbuild-sln.yml
          parameters:
            solutionDir: vnext
            solutionName: Microsoft.ReactNative.sln
            buildPlatform: x64
            buildConfiguration: Release

        # Optional: Build NuGet packages if needed
        # This step simulates package creation which could modify system state
        - task: PowerShell@2
          displayName: 'üõ°Ô∏è ASA - Simulate Package Installation'
          inputs:
            targetType: inline
            script: |
              Write-Host "Simulating package installation for ASA analysis..."
              Write-Host "Build artifacts are in place for analysis"
              # Note: Actual NuGet package installation would go here if needed
              # For now, we're analyzing the build process itself

        # Take "after" snapshot of the system
        - task: PowerShell@2
          displayName: 'üõ°Ô∏è ASA - Collect After Snapshot'
          inputs:
            targetType: inline
            script: |
              # Refresh environment PATH to include .NET global tools
              $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" + [System.Environment]::GetEnvironmentVariable("PATH", "User")
              
              Write-Host "Taking 'after' snapshot of system state..."
              # Collect files (-f), registry (-r), services (-s), ports (-p), certificates (-c)
              asa collect -f -r -s -p -c --directories "$(Build.SourcesDirectory)" --verbose
              if ($LASTEXITCODE -ne 0) {
                Write-Error "Failed to collect 'after' snapshot"
                exit 1
              }
              Write-Host "‚úÖ After snapshot collected successfully"

        # Export comparison results
        - task: PowerShell@2
          displayName: 'üõ°Ô∏è ASA - Export Comparison Results'
          inputs:
            targetType: inline
            errorActionPreference: 'continue'
            script: |
              # Refresh environment PATH to include .NET global tools
              $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" + [System.Environment]::GetEnvironmentVariable("PATH", "User")

              Write-Host "Comparing before and after snapshots..."

              # Create output directory for results
              $resultsDir = "$(Build.ArtifactStagingDirectory)\ASA_Results"
              New-Item -ItemType Directory -Force -Path $resultsDir | Out-Null

              Write-Host "Generating comparison results (SARIF and JSON)..."

              # Export as SARIF format for security analysis
              $sarifOutput = "$resultsDir\asa-comparison.sarif"
              Write-Host "Attempting SARIF export to: $sarifOutput"
              try {
                asa export-collect --outputsarif "$sarifOutput" --verbose
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "‚úÖ SARIF export successful"
                } else {
                  Write-Warning "SARIF export command returned exit code: $LASTEXITCODE"
                }
              } catch {
                Write-Warning "SARIF export failed with exception: $($_.Exception.Message)"
              }

              # Export as JSON format for additional analysis  
              $jsonOutput = "$resultsDir\asa-comparison.json"
              Write-Host "Attempting JSON export to: $jsonOutput"
              try {
                asa export-collect "$jsonOutput" --verbose
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "‚úÖ JSON export successful"
                } else {
                  Write-Warning "JSON export command returned exit code: $LASTEXITCODE"
                }
              } catch {
                Write-Warning "JSON export failed with exception: $($_.Exception.Message)"
              }

              # ENHANCED: Check for actual generated files and copy them if needed
              Write-Host "Checking for generated ASA files..."
              
              # Initialize arrays to collect files
              $generatedFiles = @()
              
              # Check multiple possible locations where ASA might write files
              $searchLocations = @(
                "$(Build.SourcesDirectory)",    # Source directory
                (Get-Location).Path,             # Current working directory
                $env:TEMP,                       # Temp directory
                $env:USERPROFILE                 # User profile directory
              )
              
              Write-Host "Searching for ASA output files in multiple locations..."
              
              foreach ($location in $searchLocations) {
                if (Test-Path $location) {
                  Write-Host "Checking: $location"
                  
                  # Look for timestamp-based output files that ASA actually generates
                  $locationFiles = @()
                  $locationFiles += Get-ChildItem -Path $location -Filter "*summary*.json*" -ErrorAction SilentlyContinue
                  $locationFiles += Get-ChildItem -Path $location -Filter "*vs_*.json*" -ErrorAction SilentlyContinue
                  $locationFiles += Get-ChildItem -Path $location -Filter "*.sarif" -ErrorAction SilentlyContinue
                  
                  if ($locationFiles.Count -gt 0) {
                    Write-Host "  Found $($locationFiles.Count) files in $location"
                    $generatedFiles += $locationFiles
                  }
                }
              }
              
              if ($generatedFiles.Count -gt 0) {
                Write-Host "Found $($generatedFiles.Count) ASA output files total:"
                foreach ($file in $generatedFiles) {
                  Write-Host "  - $($file.FullName)"
                  
                  # Copy to results directory with descriptive names
                  $destinationName = $file.Name
                  if ($file.Name -like "*summary*" -or $file.Name -like "*vs_*") {
                    $destinationName = "asa-comparison-$($file.Name)"
                  }
                  
                  try {
                    Copy-Item $file.FullName "$resultsDir\$destinationName" -Force
                    Write-Host "    ‚úÖ Copied to: $destinationName"
                  } catch {
                    Write-Warning "    ‚ùå Failed to copy $($file.Name): $($_.Exception.Message)"
                  }
                }
              } else {
                Write-Warning "No ASA output files found in any search locations"
                Write-Host "Performing recursive search for ASA-related files..."
                
                # Try a broader recursive search from current directory
                try {
                  $allFiles = Get-ChildItem -Recurse -File -ErrorAction SilentlyContinue | 
                    Where-Object { 
                      $_.Name -like "*asa*" -or 
                      $_.Name -like "*summary*" -or 
                      $_.Name -like "*vs_*" -or
                      $_.Name -like "*attack*" -or
                      $_.Extension -eq ".sarif"
                    } | 
                    Select-Object -First 20
                    
                  if ($allFiles -and $allFiles.Count -gt 0) {
                    Write-Host "Found potential ASA files through recursive search:"
                    foreach ($file in $allFiles) {
                      Write-Host "  - $($file.FullName)"
                    }
                  } else {
                    Write-Host "No ASA-related files found through recursive search"
                  }
                } catch {
                  Write-Warning "Recursive search failed: $($_.Exception.Message)"
                }
              }

              Write-Host "‚úÖ Export process completed"
              Write-Host "Results location: $resultsDir"
              
              # Ensure we don't exit with error code even if file discovery had issues
              exit 0

        # Analyze results and check for security issues
        - task: PowerShell@2
          displayName: 'üõ°Ô∏è ASA - Analyze Results'
          inputs:
            targetType: inline
            script: |
              Write-Host "Analyzing ASA results for security regressions..."
              
              $resultsDir = "$(Build.ArtifactStagingDirectory)\ASA_Results"
              
              Write-Host "üìä ASA Analysis Summary:"
              Write-Host "========================"
              
              # Look for any ASA result files in the results directory
              $allResultFiles = Get-ChildItem -Path $resultsDir -File -ErrorAction SilentlyContinue
              
              if ($allResultFiles.Count -eq 0) {
                Write-Warning "No result files found in $resultsDir"
                return
              }
              
              Write-Host "Found $($allResultFiles.Count) result files:"
              foreach ($file in $allResultFiles) {
                Write-Host "  - $($file.Name) ($([math]::Round($file.Length/1KB, 2)) KB)"
              }
              
              # Analyze SARIF files if present
              $sarifFiles = $allResultFiles | Where-Object { $_.Extension -eq ".sarif" }
              foreach ($sarifFile in $sarifFiles) {
                Write-Host ""
                Write-Host "üìã SARIF Analysis: $($sarifFile.Name)"
                try {
                  $sarifContent = Get-Content $sarifFile.FullName | ConvertFrom-Json
                  $findingCount = 0
                  
                  if ($sarifContent.runs -and $sarifContent.runs.Count -gt 0) {
                    foreach ($run in $sarifContent.runs) {
                      if ($run.results) {
                        $findingCount += $run.results.Count
                        Write-Host "  Tool: $($run.tool.driver.name)"
                        Write-Host "  Findings: $($run.results.Count)"
                      }
                    }
                  }
                  
                  if ($findingCount -gt 0) {
                    Write-Host "‚ö†Ô∏è $findingCount security findings detected in SARIF report"
                  } else {
                    Write-Host "‚úÖ No security findings in SARIF report"
                  }
                } catch {
                  Write-Host "‚ö†Ô∏è Could not parse SARIF file: $($_.Exception.Message)"
                }
              }
              
              # Analyze JSON files
              $jsonFiles = $allResultFiles | Where-Object { $_.Extension -eq ".json" -or $_.Name -like "*.json*" }
              foreach ($jsonFile in $jsonFiles) {
                Write-Host ""
                Write-Host "üìã JSON Analysis: $($jsonFile.Name)"
                try {
                  $content = Get-Content $jsonFile.FullName -Raw
                  if ($content.Length -gt 0) {
                    Write-Host "  File size: $([math]::Round($jsonFile.Length/1KB, 2)) KB"
                    Write-Host "  Content preview:"
                    # Show first few lines of content
                    $lines = $content -split "`n" | Select-Object -First 5
                    foreach ($line in $lines) {
                      if ($line.Trim()) {
                        Write-Host "    $($line.Trim())"
                      }
                    }
                  }
                } catch {
                  Write-Host "‚ö†Ô∏è Could not analyze JSON file: $($_.Exception.Message)"
                }
              }
              
              Write-Host ""
              Write-Host "üõ°Ô∏è SDL Compliance Notes:"
              Write-Host "- Review all result files for security vulnerabilities"
              Write-Host "- Pay attention to privilege escalations"
              Write-Host "- Check for unsigned binaries or weak permissions"
              Write-Host "- Verify certificate and firewall changes"
              Write-Host ""
              Write-Host "Results available in build artifacts: ASA_Results"
              Write-Host "ASA analysis completed"
          continueOnError: ${{ parameters.complianceWarnOnly }}

        # Publish ASA results as build artifact
        - task: PublishBuildArtifacts@1
          displayName: 'üõ°Ô∏è Publish ASA Results'
          inputs:
            PathtoPublish: '$(Build.ArtifactStagingDirectory)\ASA_Results'
            ArtifactName: 'ASA_Results'
            publishLocation: 'Container'
          condition: always()

        # Generate summary for PR
        - task: PowerShell@2
          displayName: 'üõ°Ô∏è ASA - Generate PR Summary'
          inputs:
            targetType: inline
            script: |
              Write-Host "Generating ASA summary for PR..."
              
              $resultsDir = "$(Build.ArtifactStagingDirectory)\ASA_Results"
              
              # Check if results directory exists and has files
              if (Test-Path $resultsDir) {
                $resultFiles = Get-ChildItem -Path $resultsDir -File -ErrorAction SilentlyContinue
                
                if ($resultFiles.Count -gt 0) {
                  Write-Host "Found $($resultFiles.Count) ASA result files:"
                  
                  # Look for SARIF files to upload as summary
                  $sarifFiles = $resultFiles | Where-Object { $_.Extension -eq ".sarif" }
                  foreach ($sarifFile in $sarifFiles) {
                    Write-Host "Uploading SARIF summary: $($sarifFile.Name)"
                    Write-Host "##vso[task.uploadsummary]$($sarifFile.FullName)"
                  }
                  
                  # List all result files
                  foreach ($file in $resultFiles) {
                    Write-Host "  - $($file.Name) ($([math]::Round($file.Length/1KB, 2)) KB)"
                  }
                  
                  Write-Host "‚úÖ ASA results will be available in PR artifacts"
                } else {
                  Write-Host "‚ö†Ô∏è Results directory exists but contains no files"
                }
              } else {
                Write-Host "‚ö†Ô∏è Results directory not found: $resultsDir"
              }
              
              # Additional logging for troubleshooting
              Write-Host ""
              Write-Host "üîç Troubleshooting Info:"
              Write-Host "Build.SourcesDirectory: $(Build.SourcesDirectory)"
              Write-Host "Build.ArtifactStagingDirectory: $(Build.ArtifactStagingDirectory)"
              
              # Look for any ASA files in the source directory
              $sourceFiles = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter "*asa*" -ErrorAction SilentlyContinue
              $sourceFiles += Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter "*summary*" -ErrorAction SilentlyContinue
              $sourceFiles += Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter "*vs_*" -ErrorAction SilentlyContinue
              
              if ($sourceFiles.Count -gt 0) {
                Write-Host "ASA files found in source directory:"
                foreach ($file in $sourceFiles) {
                  Write-Host "  - $($file.FullName)"
                }
              }
          condition: always()
